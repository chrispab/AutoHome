// import java.util.concurrent.locks.ReentrantLock

// var Timer RouterTimer = null
// // var Timer Zb_THPSensor_01_Timer = null
// var Timer Zb_THSensor_01_Timer = null
// var Timer Zb_THSensor_02_Timer = null
// var Timer Zb_THSensor_03_Timer = null
// var Timer Zb_THSensor_04_Timer = null

// val ReentrantLock Router_Lock = new ReentrantLock
// val ReentrantLock THPSensor_01_Lock = new ReentrantLock
// val ReentrantLock THSensor_01_Lock = new ReentrantLock
// val ReentrantLock THSensor_02_Lock = new ReentrantLock
// val ReentrantLock THSensor_03_Lock = new ReentrantLock
// val ReentrantLock THSensor_04_Lock = new ReentrantLock

// var int routerTimeout = 61
// var int Zb_TempSensor_Timeout = 60*50 


// //-------------------------------------------------------
// rule "StartUp - set up Heating settings"
// when
//     System started
// then
//     RouterTimer = null
//     // Zb_THPSensor_01_Timer = null
//     Zb_THSensor_01_Timer = null
//     Zb_THSensor_02_Timer = null
//     Zb_THSensor_03_Timer = null
//     Zb_THSensor_04_Timer = null

//     ZbRouter_01_Reachable.postUpdate("Offline")
//     Zb_THPSensor_01_reachable.postUpdate("Offline")
//     Zb_THSensor_01_reachable.postUpdate("Offline")
//     Zb_THSensor_02_reachable.postUpdate("Offline")
//     Zb_THSensor_03_reachable.postUpdate("Offline")
//     Zb_THSensor_04_reachable.postUpdate("Offline")
//     logInfo("monitor ZB Router", "ZB Router STARTUP clear timers")

//             //         gHeatingModes.members.forEach[ String RoomHeatingMode | RoomHeatingMode.postUpdate("off") ] 
//             // gTemperatureSetpoints.members.forEach[ TSetpoint | TSetpoint.postUpdate(offTemp) ] 
// end

// //---------------------------------------------------
// // rule "monitor ZB Router availability"
// // when
// //     Item ZbRouter_01_Quality received update
// // then
// //    var boolean gotLock = Router_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    if (gotLock) {   // if we did get the lock
// //     logWarn("monitor ZB Router", "ZB Router received mqtt - mark as ONLINE")
// //     ZbRouter_01_Reachable.postUpdate("Online")
// //     RouterTimer?.cancel
// //     logWarn("monitor ZB Router", "ZB Router Starting a new Timer")
// //     RouterTimer = createTimer(now.plusSeconds(routerTimeout), [| 
// //         ZbRouter_01_Reachable.postUpdate("Offline")//execute if timer not reset - set as "Offline"
// //         logWarn("monitor ZB Router", "ZB Router timed out - mark as OFFLINE")
// //         RouterTimer = null
// //     ])
// //     Router_Lock.unlock()  // MUST release the lock
// //    }
// // end

// // rule "monitor ZB Zb_THPSensor_01 availability"
// // when
// //     Item Zb_THPSensor_01_temperature received update
// // then
// //    var boolean gotLock = THPSensor_01_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    if (gotLock) {   // if we did get the lock
// //         logInfo("monitor Zb_THPSensor_01", "Zb_THPSensor_01 mqtt received - mark as ONLINE")
// //         Zb_THPSensor_01_reachable.postUpdate("Online")
// //         Zb_THPSensor_01_Timer?.cancel
// //         logInfo("monitor Zb_THPSensor_01", "Zb_THPSensor_01 Starting a new Timer")
// //         Zb_THPSensor_01_Timer = createTimer(now.plusSeconds(Zb_TempSensor_Timeout), [| 
// //             Zb_THPSensor_01_reachable.postUpdate("Offline")//execute if timer not cancelled - set as "Offline"
// //             logInfo("monitor ZB Zb_THPSensor_01", "Zb_THPSensor_01 timed out - mark as OFFLINE")
// //             Zb_THPSensor_01_Timer = null
// //         ])
// //     THPSensor_01_Lock.unlock()  // MUST release the lock
// //    }
// // end

// // rule "monitor ZB Zb_THSensor_01 availability"
// // when
// //     Item Zb_THSensor_01_temperature received update
// // then
// //     logInfo("monitor Zb_THSensor_01", "?????Zb_THSensor_01 mqtt received - TRYING to mark as ONLINE???????")

// //    var boolean gotLock = THSensor_01_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    if (gotLock) {   // if we did get the lock
// //         logInfo("monitor Zb_THSensor_01", "Zb_THSensor_01 mqtt received - mark as ONLINE")
// //         Zb_THSensor_01_reachable.postUpdate("Online")
// //         Zb_THSensor_01_Timer?.cancel    //if timer is active, cancel it
// //         logInfo("monitor Zb_THSensor_01", "Zb_THSensor_01 Starting a new Timer")
// //         Zb_THSensor_01_Timer = createTimer(now.plusSeconds(Zb_TempSensor_Timeout), [| 
// //             Zb_THSensor_01_reachable.postUpdate("Offline")//execute if timer not cancelled - set as "Offline"
// //             logInfo("monitor ZB Zb_THSensor_01", "Zb_THSensor_01 timed out - mark as OFFLINE")
// //             Zb_THSensor_01_Timer = null
// //         ])
// //         THSensor_01_Lock.unlock()  // MUST release the lock
// //    }
// // end

// // rule "monitor ZB Zb_THSensor_02 availability"
// // when
// //     Item Zb_THSensor_02_temperature received update
// // then
// //    var boolean gotLock = THSensor_02_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    if (gotLock) {   // if we did get the lock
// //     logInfo("monitor Zb_THSensor_02", "Zb_THSensor_02 mqtt received - mark as ONLINE")
// //     Zb_THSensor_02_reachable.postUpdate("Online")
// //     Zb_THSensor_02_Timer?.cancel
// //     logInfo("monitor Zb_THSensor_02", "Zb_THSensor_02 Starting a new Timer")
// //     Zb_THSensor_02_Timer = createTimer(now.plusSeconds(Zb_TempSensor_Timeout), [| 
// //         Zb_THSensor_02_reachable.postUpdate("Offline")//execute if timer not cancelled - set as "Offline"
// //         logInfo("monitor ZB Zb_THSensor_02", "Zb_THSensor_02 timed out - mark as OFFLINE")
// //         Zb_THSensor_02_Timer = null
// //     ])
// //     THSensor_02_Lock.unlock()  // MUST release the lock
// //    }
// // end

// // //---------------------------------------------
// // rule "monitor ZB Zb_THSensor_03 availability"
// // when
// //     Item Zb_THSensor_03_temperature received update
// // then
// //    var boolean gotLock = THSensor_03_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    if (gotLock) {   // if we did get the lock
// //     logInfo("monitor Zb_THSensor_03", "Zb_THSensor_03 mqtt received - mark as ONLINE")
// //     Zb_THSensor_03_reachable.postUpdate("Online")
// //     Zb_THSensor_03_Timer?.cancel
// //     logInfo("monitor Zb_THSensor_03", "Zb_THSensor_03 Starting a new Timer")
// //     Zb_THSensor_03_Timer = createTimer(now.plusSeconds(Zb_TempSensor_Timeout), [| 
// //         Zb_THSensor_03_reachable.postUpdate("Offline")//execute if timer not cancelled - set as "Offline"
// //         logInfo("monitor ZB Zb_THSensor_03", "Zb_THSensor_03 timed out - mark as OFFLINE")
// //         Zb_THSensor_03_Timer = null
// //     ])
// //     THSensor_03_Lock.unlock()  // MUST release the lock
// //    }
// // end


// // rule "monitor ZB Zb_THSensor_04 availability"
// // when
// //     Item Zb_THSensor_04_temperature received update
// // then
// //    var boolean gotLock = THSensor_04_Lock.tryLock() // get the lock if we can, but as quick as we can
// //    logInfo("monitor Zb_THSensor_04", "$$$$$$$$$$$$$$$$$$$$$$$  Zb_THSensor_04 mqtt received - mark as ONLINE")

// //    if (gotLock) {   // if we did get the lock
// //     logInfo("monitor Zb_THSensor_04", "Zb_THSensor_04 mqtt received - mark as ONLINE")
// //     Zb_THSensor_04_reachable.postUpdate("Online")
// //     Zb_THSensor_04_Timer?.cancel
// //     logInfo("monitor Zb_THSensor_04", "Zb_THSensor_04 Starting a new Timer")
// //     Zb_THSensor_04_Timer = createTimer(now.plusSeconds(Zb_TempSensor_Timeout), [| 
// //         Zb_THSensor_04_reachable.postUpdate("Offline")//execute if timer not cancelled - set as "Offline"
// //         logInfo("monitor ZB Zb_THSensor_04", "Zb_THSensor_04 timed out - mark as OFFLINE")
// //         Zb_THSensor_04_Timer = null
// //     ])
// //     THSensor_04_Lock.unlock()  // MUST release the lock
// //    }
// // end


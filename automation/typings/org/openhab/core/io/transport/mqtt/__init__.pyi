import com.hivemq.client.mqtt.lifecycle
import java.lang
import java.util
import java.util.concurrent
import javax.net.ssl
import org
import org.openhab.core.io.transport.mqtt.reconnect
import typing


class MqttActionCallback(java.lang.Object):
    """
    @NonNullByDefault public interface MqttActionCallback
    
        Implement this to be notified of the success or error of a any method in
        :class:`~org.openhab.core.io.transport.mqtt.MqttBrokerConnection` that takes a callback.
    
    
    """
    def onFailure(self, topic: java.lang.String, error: java.lang.Throwable) -> None: ...
    def onSuccess(self, topic: java.lang.String) -> None: ...

class MqttBrokerConnection(java.lang.Object):
    """
    Java class 'org.openhab.core.io.transport.mqtt.MqttBrokerConnection'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * MqttBrokerConnection(java.lang.String, java.lang.Integer, boolean, java.lang.String)
        * MqttBrokerConnection(org.openhab.core.io.transport.mqtt.MqttBrokerConnection.Protocol, org.openhab.core.io.transport.mqtt.MqttBrokerConnection.MqttVersion, java.lang.String, java.lang.Integer, boolean, java.lang.String)
    
      Attributes:
        DEFAULT_KEEPALIVE_INTERVAL (int): final static field
        DEFAULT_QOS (int): final static field
    
    """
    DEFAULT_KEEPALIVE_INTERVAL: typing.ClassVar[int] = ...
    DEFAULT_QOS: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, host: java.lang.String, port: int, secure: bool, clientId: java.lang.String): ...
    @typing.overload
    def __init__(self, protocol: 'MqttBrokerConnection.Protocol', mqttVersion: 'MqttBrokerConnection.MqttVersion', host: java.lang.String, port: int, secure: bool, clientId: java.lang.String): ...
    def addConnectionObserver(self, connectionObserver: 'MqttConnectionObserver') -> None: ...
    def connectionState(self) -> 'MqttConnectionState': ...
    def getClientId(self) -> java.lang.String: ...
    def getHost(self) -> java.lang.String: ...
    def getKeepAliveInterval(self) -> int: ...
    def getLastWill(self) -> 'MqttWillAndTestament': ...
    def getMqttVersion(self) -> 'MqttBrokerConnection.MqttVersion': ...
    def getPassword(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getProtocol(self) -> 'MqttBrokerConnection.Protocol': ...
    def getQos(self) -> int: ...
    def getReconnectStrategy(self) -> org.openhab.core.io.transport.mqtt.reconnect.AbstractReconnectStrategy: ...
    def getTrustManagers(self) -> typing.List[javax.net.ssl.TrustManager]: ...
    def getUser(self) -> java.lang.String: ...
    def hasConnectionObservers(self) -> bool: ...
    def hasSubscribers(self) -> bool: ...
    def isSecure(self) -> bool: ...
    def publish(self, topic: java.lang.String, payload: typing.List[int], qos: int, retain: bool) -> java.util.concurrent.CompletableFuture[bool]: ...
    def removeConnectionObserver(self, connectionObserver: 'MqttConnectionObserver') -> None: ...
    def setCredentials(self, user: java.lang.String, password: java.lang.String) -> None: ...
    def setKeepAliveInterval(self, keepAliveInterval: int) -> None: ...
    @typing.overload
    def setLastWill(self, lastWill: 'MqttWillAndTestament') -> None: ...
    @typing.overload
    def setLastWill(self, lastWill: 'MqttWillAndTestament', applyImmediately: bool) -> None: ...
    def setQos(self, qos: int) -> None: ...
    def setReconnectStrategy(self, reconnectStrategy: org.openhab.core.io.transport.mqtt.reconnect.AbstractReconnectStrategy) -> None: ...
    def setTimeoutExecutor(self, executor: java.util.concurrent.ScheduledExecutorService, timeoutInMS: int) -> None: ...
    def setTrustManagers(self, trustManagers: typing.List[javax.net.ssl.TrustManager]) -> None: ...
    def setUnsubscribeOnStop(self, unsubscribeOnStop: bool) -> None: ...
    def start(self) -> java.util.concurrent.CompletableFuture[bool]: ...
    def stop(self) -> java.util.concurrent.CompletableFuture[bool]: ...
    def subscribe(self, topic: java.lang.String, subscriber: 'MqttMessageSubscriber') -> java.util.concurrent.CompletableFuture[bool]: ...
    def unsubscribe(self, topic: java.lang.String, subscriber: 'MqttMessageSubscriber') -> java.util.concurrent.CompletableFuture[bool]: ...
    def unsubscribeAll(self) -> java.util.concurrent.CompletableFuture[None]: ...
    class ConnectionCallback(com.hivemq.client.mqtt.lifecycle.MqttClientConnectedListener, com.hivemq.client.mqtt.lifecycle.MqttClientDisconnectedListener):
        """
        Java class 'org.openhab.core.io.transport.mqtt.MqttBrokerConnection$ConnectionCallback'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                com.hivemq.client.mqtt.lifecycle.MqttClientConnectedListener, 
                com.hivemq.client.mqtt.lifecycle.MqttClientDisconnectedListene
                r
        
          Constructors:
            * ConnectionCallback(org.openhab.core.io.transport.mqtt.MqttBrokerConnection, org.openhab.core.io.transport.mqtt.MqttBrokerConnection)
        
        """
        def __init__(self, mqttBrokerConnectionImpl: 'MqttBrokerConnection'): ...
        def createFuture(self) -> java.util.concurrent.CompletableFuture[bool]: ...
        def onConnected(self, context: com.hivemq.client.mqtt.lifecycle.MqttClientConnectedContext) -> None: ...
        @typing.overload
        def onDisconnected(self, context: com.hivemq.client.mqtt.lifecycle.MqttClientDisconnectedContext) -> None: ...
        @typing.overload
        def onDisconnected(self, t: java.lang.Throwable) -> None: ...
    class MqttVersion(java.lang.Enum[org.openhab.core.io.transport.mqtt.MqttBrokerConnection.MqttVersion]):
        """
        Java class 'org.openhab.core.io.transport.mqtt.MqttBrokerConnection$MqttVersion'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            V3 (org.openhab.core.io.transport.mqtt.MqttBrokerConnection$MqttVersion): final static enum constant
            V5 (org.openhab.core.io.transport.mqtt.MqttBrokerConnection$MqttVersion): final static enum constant
        
        """
        V3: typing.ClassVar['MqttBrokerConnection.MqttVersion'] = ...
        V5: typing.ClassVar['MqttBrokerConnection.MqttVersion'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, name: java.lang.String) -> 'MqttBrokerConnection.MqttVersion': ...
        @classmethod
        def values(cls) -> typing.List['MqttBrokerConnection.MqttVersion']: ...
    class Protocol(java.lang.Enum[org.openhab.core.io.transport.mqtt.MqttBrokerConnection.Protocol]):
        """
        Java class 'org.openhab.core.io.transport.mqtt.MqttBrokerConnection$Protocol'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            TCP (org.openhab.core.io.transport.mqtt.MqttBrokerConnection$Protocol): final static enum constant
            WEBSOCKETS (org.openhab.core.io.transport.mqtt.MqttBrokerConnection$Protocol): final static enum constant
        
        """
        TCP: typing.ClassVar['MqttBrokerConnection.Protocol'] = ...
        WEBSOCKETS: typing.ClassVar['MqttBrokerConnection.Protocol'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, name: java.lang.String) -> 'MqttBrokerConnection.Protocol': ...
        @classmethod
        def values(cls) -> typing.List['MqttBrokerConnection.Protocol']: ...

class MqttBrokerConnectionConfig(java.lang.Object):
    """
    Java class 'org.openhab.core.io.transport.mqtt.MqttBrokerConnectionConfig'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * MqttBrokerConnectionConfig()
    
      Attributes:
        name (java.lang.String): field
        host (java.lang.String): field
        port (java.lang.Integer): field
        secure (boolean): field
        username (java.lang.String): field
        password (java.lang.String): field
        clientID (java.lang.String): field
        qos (java.lang.Integer): field
        keepAlive (java.lang.Integer): field
        lwtTopic (java.lang.String): field
        lwtMessage (java.lang.String): field
        lwtQos (java.lang.Integer): field
        lwtRetain (java.lang.Boolean): field
    
    """
    name: java.lang.String = ...
    host: java.lang.String = ...
    port: int = ...
    secure: bool = ...
    username: java.lang.String = ...
    password: java.lang.String = ...
    clientID: java.lang.String = ...
    qos: int = ...
    keepAlive: int = ...
    lwtTopic: java.lang.String = ...
    lwtMessage: java.lang.String = ...
    lwtQos: int = ...
    lwtRetain: bool = ...
    def __init__(self): ...
    def getBrokerID(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class MqttConnectionObserver(java.lang.Object):
    """
    @NonNullByDefault public interface MqttConnectionObserver
    
        Implement this interface to get notified of connection state changes. Register this observer at {@see
        MqttBrokerConnection}.
    
    
    """
    def connectionStateChanged(self, state: 'MqttConnectionState', error: java.lang.Throwable) -> None: ...

class MqttConnectionState(java.lang.Enum[org.openhab.core.io.transport.mqtt.MqttConnectionState]):
    """
    Java class 'org.openhab.core.io.transport.mqtt.MqttConnectionState'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        DISCONNECTED (org.openhab.core.io.transport.mqtt.MqttConnectionState): final static enum constant
        CONNECTING (org.openhab.core.io.transport.mqtt.MqttConnectionState): final static enum constant
        CONNECTED (org.openhab.core.io.transport.mqtt.MqttConnectionState): final static enum constant
    
    """
    DISCONNECTED: typing.ClassVar['MqttConnectionState'] = ...
    CONNECTING: typing.ClassVar['MqttConnectionState'] = ...
    CONNECTED: typing.ClassVar['MqttConnectionState'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, name: java.lang.String) -> 'MqttConnectionState': ...
    @classmethod
    def values(cls) -> typing.List['MqttConnectionState']: ...

class MqttException(java.lang.Exception):
    """
    Java class 'org.openhab.core.io.transport.mqtt.MqttException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * MqttException(java.lang.String)
        * MqttException(java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, reason: java.lang.String): ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable): ...
    def getCause(self) -> java.lang.Throwable: ...
    def getMessage(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class MqttMessageSubscriber(java.lang.Object):
    """
    @NonNullByDefault public interface MqttMessageSubscriber
    
        Implement this interface and register on the {@see MqttBrokerConnection} to get notified of incoming Mqtt messages on
        the given topic.
    
    
    """
    def processMessage(self, topic: java.lang.String, payload: typing.List[int]) -> None: ...

class MqttService(java.lang.Object):
    """
    @NonNullByDefault public interface MqttService
    
        This service allows you to enumerate system-wide configured Mqtt broker connections. You do not need this service if you
        want to manage own/local Mqtt broker connections. If you add a broker connection, it will be available immediately for
        all MqttService users. A removed broker connection may still be in use by consuming services. Added/removed connections
        are not permanent. Use :code:`MqttBrokerConnectionServiceInstance` to configure permanent connections.
    
    
    """
    def addBrokerConnection(self, brokerID: java.lang.String, connection: MqttBrokerConnection) -> bool: ...
    def addBrokersListener(self, observer: 'MqttServiceObserver') -> None: ...
    def getAllBrokerConnections(self) -> java.util.Map[java.lang.String, MqttBrokerConnection]: ...
    def getBrokerConnection(self, brokerName: java.lang.String) -> MqttBrokerConnection: ...
    def hasBrokerObservers(self) -> bool: ...
    def removeBrokerConnection(self, brokerID: java.lang.String) -> MqttBrokerConnection: ...
    def removeBrokersListener(self, observer: 'MqttServiceObserver') -> None: ...

class MqttServiceObserver(java.lang.Object):
    """
    @NonNullByDefault public interface MqttServiceObserver
    
        Implement this interface to get notified of new and removed MQTT broker. Register this observer at {@see MqttService}.
    
    
    """
    def brokerAdded(self, brokerID: java.lang.String, broker: MqttBrokerConnection) -> None: ...
    def brokerRemoved(self, brokerID: java.lang.String, broker: MqttBrokerConnection) -> None: ...

class MqttWillAndTestament(java.lang.Object):
    """
    Java class 'org.openhab.core.io.transport.mqtt.MqttWillAndTestament'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * MqttWillAndTestament(java.lang.String, byte[], int, boolean)
    
    """
    def __init__(self, topic: java.lang.String, payload: typing.List[int], qos: int, retain: bool): ...
    @classmethod
    @typing.overload
    def fromString(cls, string: java.lang.String) -> 'MqttWillAndTestament': ...
    @classmethod
    @typing.overload
    def fromString(cls, string: java.lang.String, topic: java.lang.String, payload: typing.List[int], qos: int, retain: bool) -> 'MqttWillAndTestament': ...
    def getPayload(self) -> typing.List[int]: ...
    def getQos(self) -> int: ...
    def getTopic(self) -> java.lang.String: ...
    def isRetain(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

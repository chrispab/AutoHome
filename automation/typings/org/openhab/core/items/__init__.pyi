import java.lang
import java.util
import java.util.function
import org
import org.openhab.core.common
import org.openhab.core.common.registry
import org.openhab.core.events
import org.openhab.core.i18n
import org.openhab.core.service
import org.openhab.core.storage
import org.openhab.core.types
import typing


class Item(org.openhab.core.common.registry.Identifiable[java.lang.String]):
    """
    Java class 'org.openhab.core.items.Item'
    
        Interfaces:
            org.openhab.core.common.registry.Identifiable
    
    """
    def getAcceptedCommandTypes(self) -> java.util.List[typing.Type[org.openhab.core.types.Command]]: ...
    def getAcceptedDataTypes(self) -> java.util.List[typing.Type[org.openhab.core.types.State]]: ...
    def getCategory(self) -> java.lang.String: ...
    @typing.overload
    def getCommandDescription(self, locale: java.util.Locale) -> org.openhab.core.types.CommandDescription: ...
    @typing.overload
    def getCommandDescription(self) -> org.openhab.core.types.CommandDescription: ...
    def getGroupNames(self) -> java.util.List[java.lang.String]: ...
    def getLabel(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getState(self) -> org.openhab.core.types.State: ...
    _getStateAs__T = typing.TypeVar('_getStateAs__T', bound=org.openhab.core.types.State)  # <T>
    def getStateAs(self, typeClass: typing.Type[_getStateAs__T]) -> _getStateAs__T: ...
    @typing.overload
    def getStateDescription(self) -> org.openhab.core.types.StateDescription: ...
    @typing.overload
    def getStateDescription(self, locale: java.util.Locale) -> org.openhab.core.types.StateDescription: ...
    def getTags(self) -> java.util.Set[java.lang.String]: ...
    def getType(self) -> java.lang.String: ...
    def hasTag(self, tag: java.lang.String) -> bool: ...

class ItemBuilder(java.lang.Object):
    """
    @NonNullByDefault public interface ItemBuilder
    
        This class allows the easy construction of an :class:`~org.openhab.core.items.Item` using the builder pattern.
    
    
    """
    def build(self) -> Item: ...
    def withBaseItem(self, baseItem: Item) -> 'ItemBuilder': ...
    def withCategory(self, category: java.lang.String) -> 'ItemBuilder': ...
    def withGroupFunction(self, function: 'GroupFunction') -> 'ItemBuilder': ...
    def withGroups(self, groups: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'ItemBuilder': ...
    def withLabel(self, label: java.lang.String) -> 'ItemBuilder': ...
    def withTags(self, tags: java.util.Set[java.lang.String]) -> 'ItemBuilder': ...

class ItemBuilderFactory(java.lang.Object):
    """
    @NonNullByDefault public interface ItemBuilderFactory
    
        Creates a new :class:`~org.openhab.core.items.ItemBuilder` which is based on all available
        :class:`~org.openhab.core.items.ItemFactory`s.
    
    
    """
    @typing.overload
    def newItemBuilder(self, itemType: java.lang.String, itemName: java.lang.String) -> ItemBuilder: ...
    @typing.overload
    def newItemBuilder(self, item: Item) -> ItemBuilder: ...

class ItemFactory(java.lang.Object):
    """
    @NonNullByDefault public interface ItemFactory
    
        This Factory creates concrete instances of the known ItemTypes.
    
    
    """
    def createItem(self, itemTypeName: java.lang.String, itemName: java.lang.String) -> Item: ...
    def getSupportedItemTypes(self) -> typing.List[java.lang.String]: ...

class ItemLookupException(java.lang.Exception):
    """
    Java class 'org.openhab.core.items.ItemLookupException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * ItemLookupException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...

class ItemPredicates(java.lang.Object):
    """
    Java class 'org.openhab.core.items.ItemPredicates'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ItemPredicates()
    
    """
    def __init__(self): ...
    @classmethod
    def hasLabel(cls, label: java.lang.String) -> java.util.function.Predicate[Item]: ...

class ItemProvider(org.openhab.core.common.registry.Provider[Item]):
    """
    Java class 'org.openhab.core.items.ItemProvider'
    
        Interfaces:
            org.openhab.core.common.registry.Provider
    
    """

class ItemRegistry(org.openhab.core.common.registry.Registry[Item, java.lang.String]):
    """
    Java class 'org.openhab.core.items.ItemRegistry'
    
        Interfaces:
            org.openhab.core.common.registry.Registry
    
    """
    def addRegistryHook(self, hook: 'RegistryHook'[Item]) -> None: ...
    def getItem(self, name: java.lang.String) -> Item: ...
    def getItemByPattern(self, name: java.lang.String) -> Item: ...
    @typing.overload
    def getItems(self) -> java.util.Collection[Item]: ...
    @typing.overload
    def getItems(self, pattern: java.lang.String) -> java.util.Collection[Item]: ...
    _getItemsByTag_0__T = typing.TypeVar('_getItemsByTag_0__T', bound=Item)  # <T>
    @typing.overload
    def getItemsByTag(self, typeFilter: typing.Type[_getItemsByTag_0__T], tags: typing.List[java.lang.String]) -> java.util.Collection[_getItemsByTag_0__T]: ...
    @typing.overload
    def getItemsByTag(self, tags: typing.List[java.lang.String]) -> java.util.Collection[Item]: ...
    def getItemsByTagAndType(self, type: java.lang.String, tags: typing.List[java.lang.String]) -> java.util.Collection[Item]: ...
    def getItemsOfType(self, type: java.lang.String) -> java.util.Collection[Item]: ...
    @typing.overload
    def remove(self, key: typing.Any) -> org.openhab.core.common.registry.Identifiable: ...
    @typing.overload
    def remove(self, itemName: java.lang.String, recursive: bool) -> Item: ...
    def removeRegistryHook(self, hook: 'RegistryHook'[Item]) -> None: ...

class ItemRegistryChangeListener(org.openhab.core.common.registry.RegistryChangeListener[Item]):
    """
    Java class 'org.openhab.core.items.ItemRegistryChangeListener'
    
        Interfaces:
            org.openhab.core.common.registry.RegistryChangeListener
    
    """
    def allItemsChanged(self, oldItemNames: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> None: ...

class ItemStateConverter(java.lang.Object):
    """
    @NonNullByDefault public interface ItemStateConverter
    
        Convert a :class:`~org.openhab.core.types.State` to an :class:`~org.openhab.core.items.Item` accepted
        :class:`~org.openhab.core.types.State`.
    
    
    """
    def convertToAcceptedState(self, state: org.openhab.core.types.State, item: Item) -> org.openhab.core.types.State: ...

class ItemUtil(java.lang.Object):
    """
    Java class 'org.openhab.core.items.ItemUtil'
    
        Extends:
            java.lang.Object
    
      Attributes:
        EXTENSION_SEPARATOR (java.lang.String): final static field
    
    """
    EXTENSION_SEPARATOR: typing.ClassVar[java.lang.String] = ...
    @classmethod
    def assertValidItemName(cls, itemName: java.lang.String) -> None: ...
    @classmethod
    def getItemTypeExtension(cls, itemTypeName: java.lang.String) -> java.lang.String: ...
    @classmethod
    def getMainItemType(cls, itemTypeName: java.lang.String) -> java.lang.String: ...
    @classmethod
    def isValidItemName(cls, itemName: java.lang.String) -> bool: ...

class Metadata(org.openhab.core.common.registry.Identifiable[org.openhab.core.items.MetadataKey]):
    """
    Java class 'org.openhab.core.items.Metadata'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            org.openhab.core.common.registry.Identifiable
    
      Constructors:
        * Metadata(org.openhab.core.items.MetadataKey, java.lang.String, java.util.Map)
    
    """
    def __init__(self, key: 'MetadataKey', value: java.lang.String, configuration: typing.Union[java.util.Map[java.lang.String, typing.Any], typing.Mapping[java.lang.String, typing.Any]]): ...
    def equals(self, obj: typing.Any) -> bool: ...
    def getConfiguration(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    @typing.overload
    def getUID(self) -> typing.Any: ...
    @typing.overload
    def getUID(self) -> 'MetadataKey': ...
    def getValue(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class MetadataKey(org.openhab.core.common.AbstractUID):
    """
    Java class 'org.openhab.core.items.MetadataKey'
    
        Extends:
            org.openhab.core.common.AbstractUID
    
      Constructors:
        * MetadataKey(java.lang.String, java.lang.String)
    
    """
    def __init__(self, namespace: java.lang.String, itemName: java.lang.String): ...
    def getItemName(self) -> java.lang.String: ...
    def getNamespace(self) -> java.lang.String: ...

class MetadataPredicates(java.lang.Object):
    """
    Java class 'org.openhab.core.items.MetadataPredicates'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * MetadataPredicates()
    
    """
    def __init__(self): ...
    @classmethod
    def hasNamespace(cls, namespace: java.lang.String) -> java.util.function.Predicate[Metadata]: ...
    @classmethod
    def ofItem(cls, itemname: java.lang.String) -> java.util.function.Predicate[Metadata]: ...

class MetadataProvider(org.openhab.core.common.registry.Provider[Metadata]):
    """
    Java class 'org.openhab.core.items.MetadataProvider'
    
        Interfaces:
            org.openhab.core.common.registry.Provider
    
    """

class MetadataRegistry(org.openhab.core.common.registry.Registry[Metadata, MetadataKey]):
    """
    Java class 'org.openhab.core.items.MetadataRegistry'
    
        Interfaces:
            org.openhab.core.common.registry.Registry
    
      Attributes:
        INTERNAL_NAMESPACE_PREFIX (java.lang.String): final static field
    
    """
    INTERNAL_NAMESPACE_PREFIX: typing.ClassVar[java.lang.String] = ...
    def isInternalNamespace(self, namespace: java.lang.String) -> bool: ...
    def removeItemMetadata(self, name: java.lang.String) -> None: ...

_RegistryHook__E = typing.TypeVar('_RegistryHook__E', bound=org.openhab.core.common.registry.Identifiable)  # <E>
class RegistryHook(java.lang.Object, typing.Generic[_RegistryHook__E]):
    """
    public interface RegistryHook<E extends :class:`~org.openhab.core.common.registry.Identifiable`<?>&gt;
    
        A listener to be informed before entities are added respectively after they are removed.
    
    
    """
    def afterRemoving(self, element: _RegistryHook__E) -> None: ...
    def beforeAdding(self, element: _RegistryHook__E) -> None: ...

class StateChangeListener(java.lang.Object):
    """
    @NonNullByDefault public interface StateChangeListener
    
    
        This interface must be implemented by all classes that want to be notified about changes in the state of an item.
    
        The :class:`~org.openhab.core.items.GenericItem` class provides the possibility to register such listeners.
    
    
    """
    def stateChanged(self, item: Item, oldState: org.openhab.core.types.State, newState: org.openhab.core.types.State) -> None: ...
    def stateUpdated(self, item: Item, state: org.openhab.core.types.State) -> None: ...

class ActiveItem(Item):
    """
    Java class 'org.openhab.core.items.ActiveItem'
    
        Interfaces:
            org.openhab.core.items.Item
    
    """
    def addGroupName(self, groupItemName: java.lang.String) -> None: ...
    @typing.overload
    def addGroupNames(self, groupItemNames: typing.List[java.lang.String]) -> None: ...
    @typing.overload
    def addGroupNames(self, groupItemNames: java.util.List[java.lang.String]) -> None: ...
    def addTag(self, tag: java.lang.String) -> None: ...
    @typing.overload
    def addTags(self, tags: typing.List[java.lang.String]) -> None: ...
    @typing.overload
    def addTags(self, tags: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> None: ...
    def removeAllTags(self) -> None: ...
    def removeGroupName(self, groupItemName: java.lang.String) -> None: ...
    def removeTag(self, tag: java.lang.String) -> None: ...
    def setCategory(self, category: java.lang.String) -> None: ...
    def setLabel(self, label: java.lang.String) -> None: ...

class ItemNotFoundException(ItemLookupException):
    """
    Java class 'org.openhab.core.items.ItemNotFoundException'
    
        Extends:
            org.openhab.core.items.ItemLookupException
    
      Constructors:
        * ItemNotFoundException(java.lang.String)
    
    """
    def __init__(self, name: java.lang.String): ...

class ItemNotUniqueException(ItemLookupException):
    """
    Java class 'org.openhab.core.items.ItemNotUniqueException'
    
        Extends:
            org.openhab.core.items.ItemLookupException
    
      Constructors:
        * ItemNotUniqueException(java.lang.String, java.util.Collection)
    
    """
    def __init__(self, string: java.lang.String, items: typing.Union[java.util.Collection[Item], typing.Sequence[Item]]): ...
    def getMatchingItems(self) -> java.util.Collection[Item]: ...

class ManagedItemProvider(org.openhab.core.common.registry.AbstractManagedProvider[Item, java.lang.String, org.openhab.core.items.ManagedItemProvider.PersistedItem], ItemProvider):
    """
    Java class 'org.openhab.core.items.ManagedItemProvider'
    
        Extends:
            org.openhab.core.common.registry.AbstractManagedProvider
    
        Interfaces:
            org.openhab.core.items.ItemProvider
    
      Constructors:
        * ManagedItemProvider(org.openhab.core.storage.StorageService, org.openhab.core.items.ItemBuilderFactory)
    
    """
    def __init__(self, storageService: org.openhab.core.storage.StorageService, itemBuilderFactory: ItemBuilderFactory): ...
    @typing.overload
    def add(self, identifiable: org.openhab.core.common.registry.Identifiable) -> None: ...
    @typing.overload
    def add(self, element: Item) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> org.openhab.core.common.registry.Identifiable: ...
    @typing.overload
    def remove(self, key: java.lang.String) -> Item: ...
    @typing.overload
    def remove(self, itemName: java.lang.String, recursive: bool) -> Item: ...
    class PersistedItem(java.lang.Object):
        """
        Java class 'org.openhab.core.items.ManagedItemProvider$PersistedItem'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * PersistedItem(java.lang.String)
        
          Attributes:
            baseItemType (java.lang.String): field
            groupNames (java.util.List): field
            itemType (java.lang.String): field
            tags (java.util.Set): field
            label (java.lang.String): field
            category (java.lang.String): field
            functionName (java.lang.String): field
            functionParams (java.util.List): field
            dimension (java.lang.String): field
        
        """
        baseItemType: java.lang.String = ...
        groupNames: java.util.List = ...
        itemType: java.lang.String = ...
        tags: java.util.Set = ...
        label: java.lang.String = ...
        category: java.lang.String = ...
        functionName: java.lang.String = ...
        functionParams: java.util.List = ...
        dimension: java.lang.String = ...
        def __init__(self, itemType: java.lang.String): ...

class ManagedMetadataProvider(org.openhab.core.common.registry.ManagedProvider[Metadata, MetadataKey], MetadataProvider):
    """
    Java class 'org.openhab.core.items.ManagedMetadataProvider'
    
        Interfaces:
            org.openhab.core.common.registry.ManagedProvider,
            org.openhab.core.items.MetadataProvider
    
    """
    def removeItemMetadata(self, name: java.lang.String) -> None: ...

class GenericItem(ActiveItem):
    """
    Java class 'org.openhab.core.items.GenericItem'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            org.openhab.core.items.ActiveItem
    
      Constructors:
        * GenericItem(java.lang.String, java.lang.String)
    
    """
    def __init__(self, type: java.lang.String, name: java.lang.String): ...
    def addGroupName(self, groupItemName: java.lang.String) -> None: ...
    @typing.overload
    def addGroupNames(self, groupItemNames: typing.List[java.lang.String]) -> None: ...
    @typing.overload
    def addGroupNames(self, groupItemNames: java.util.List[java.lang.String]) -> None: ...
    def addStateChangeListener(self, listener: StateChangeListener) -> None: ...
    def addTag(self, tag: java.lang.String) -> None: ...
    @typing.overload
    def addTags(self, tags: typing.List[java.lang.String]) -> None: ...
    @typing.overload
    def addTags(self, tags: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> None: ...
    def dispose(self) -> None: ...
    def equals(self, obj: typing.Any) -> bool: ...
    def getCategory(self) -> java.lang.String: ...
    @typing.overload
    def getCommandDescription(self) -> org.openhab.core.types.CommandDescription: ...
    @typing.overload
    def getCommandDescription(self, locale: java.util.Locale) -> org.openhab.core.types.CommandDescription: ...
    def getGroupNames(self) -> java.util.List[java.lang.String]: ...
    def getLabel(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getState(self) -> org.openhab.core.types.State: ...
    _getStateAs__T = typing.TypeVar('_getStateAs__T', bound=org.openhab.core.types.State)  # <T>
    def getStateAs(self, typeClass: typing.Type[_getStateAs__T]) -> _getStateAs__T: ...
    @typing.overload
    def getStateDescription(self) -> org.openhab.core.types.StateDescription: ...
    @typing.overload
    def getStateDescription(self, locale: java.util.Locale) -> org.openhab.core.types.StateDescription: ...
    def getTags(self) -> java.util.Set[java.lang.String]: ...
    def getType(self) -> java.lang.String: ...
    @typing.overload
    def getUID(self) -> typing.Any: ...
    @typing.overload
    def getUID(self) -> java.lang.String: ...
    def hasTag(self, tag: java.lang.String) -> bool: ...
    def hashCode(self) -> int: ...
    def isAcceptedState(self, acceptedDataTypes: java.util.List[typing.Type[org.openhab.core.types.State]], state: org.openhab.core.types.State) -> bool: ...
    def removeAllTags(self) -> None: ...
    def removeGroupName(self, groupItemName: java.lang.String) -> None: ...
    def removeStateChangeListener(self, listener: StateChangeListener) -> None: ...
    def removeTag(self, tag: java.lang.String) -> None: ...
    def send(self, command: org.openhab.core.types.RefreshType) -> None: ...
    def setCategory(self, category: java.lang.String) -> None: ...
    def setCommandDescriptionService(self, commandDescriptionService: org.openhab.core.service.CommandDescriptionService) -> None: ...
    def setEventPublisher(self, eventPublisher: org.openhab.core.events.EventPublisher) -> None: ...
    def setItemStateConverter(self, itemStateConverter: ItemStateConverter) -> None: ...
    def setLabel(self, label: java.lang.String) -> None: ...
    def setState(self, state: org.openhab.core.types.State) -> None: ...
    def setStateDescriptionService(self, stateDescriptionService: org.openhab.core.service.StateDescriptionService) -> None: ...
    def setUnitProvider(self, unitProvider: org.openhab.core.i18n.UnitProvider) -> None: ...
    def toString(self) -> java.lang.String: ...

class GroupItem(GenericItem, StateChangeListener):
    """
    Java class 'org.openhab.core.items.GroupItem'
    
        Extends:
            org.openhab.core.items.GenericItem
    
        Interfaces:
            org.openhab.core.items.StateChangeListener
    
      Constructors:
        * GroupItem(java.lang.String, org.openhab.core.items.Item, org.openhab.core.items.GroupFunction)
        * GroupItem(java.lang.String, org.openhab.core.items.Item)
        * GroupItem(java.lang.String)
    
      Attributes:
        TYPE (java.lang.String): final static field
    
    """
    TYPE: typing.ClassVar[java.lang.String] = ...
    @typing.overload
    def __init__(self, name: java.lang.String): ...
    @typing.overload
    def __init__(self, name: java.lang.String, baseItem: Item): ...
    @typing.overload
    def __init__(self, name: java.lang.String, baseItem: Item, function: 'GroupFunction'): ...
    def addMember(self, item: Item) -> None: ...
    def dispose(self) -> None: ...
    def getAcceptedCommandTypes(self) -> java.util.List[typing.Type[org.openhab.core.types.Command]]: ...
    def getAcceptedDataTypes(self) -> java.util.List[typing.Type[org.openhab.core.types.State]]: ...
    def getAllMembers(self) -> java.util.Set[Item]: ...
    def getBaseItem(self) -> Item: ...
    def getFunction(self) -> 'GroupFunction': ...
    @typing.overload
    def getMembers(self) -> java.util.Set[Item]: ...
    @typing.overload
    def getMembers(self, filterItem: typing.Union[java.util.function.Predicate[Item], typing.Callable[[], Item]]) -> java.util.Set[Item]: ...
    _getStateAs__T = typing.TypeVar('_getStateAs__T', bound=org.openhab.core.types.State)  # <T>
    def getStateAs(self, typeClass: typing.Type[_getStateAs__T]) -> _getStateAs__T: ...
    def removeAllMembers(self) -> None: ...
    def removeMember(self, item: Item) -> None: ...
    def replaceMember(self, oldItem: Item, newItem: Item) -> None: ...
    @typing.overload
    def send(self, command: org.openhab.core.types.RefreshType) -> None: ...
    @typing.overload
    def send(self, command: org.openhab.core.types.Command) -> None: ...
    def setState(self, state: org.openhab.core.types.State) -> None: ...
    def setUnitProvider(self, unitProvider: org.openhab.core.i18n.UnitProvider) -> None: ...
    def stateChanged(self, item: Item, oldState: org.openhab.core.types.State, newState: org.openhab.core.types.State) -> None: ...
    def stateUpdated(self, item: Item, state: org.openhab.core.types.State) -> None: ...
    def toString(self) -> java.lang.String: ...

class GroupFunction(java.lang.Object):
    """
    @NonNullByDefault public interface GroupFunction
    
        Group functions are used by active group items to calculate a state for the group out of the states of all its member
        items.
    
    
    """
    def calculate(self, items: java.util.Set[Item]) -> org.openhab.core.types.State: ...
    def getParameters(self) -> typing.List[org.openhab.core.types.State]: ...
    _getStateAs__T = typing.TypeVar('_getStateAs__T', bound=org.openhab.core.types.State)  # <T>
    def getStateAs(self, items: java.util.Set[Item], stateClass: typing.Type[_getStateAs__T]) -> _getStateAs__T: ...
    class Equality(org.openhab.core.items.GroupFunction):
        """
        Java class 'org.openhab.core.items.GroupFunction$Equality'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                org.openhab.core.items.GroupFunction
        
          Constructors:
            * Equality()
        
        """
        def __init__(self): ...
        def calculate(self, items: java.util.Set[Item]) -> org.openhab.core.types.State: ...
        def getParameters(self) -> typing.List[org.openhab.core.types.State]: ...
        _getStateAs__T = typing.TypeVar('_getStateAs__T', bound=org.openhab.core.types.State)  # <T>
        def getStateAs(self, items: java.util.Set[Item], stateClass: typing.Type[_getStateAs__T]) -> _getStateAs__T: ...

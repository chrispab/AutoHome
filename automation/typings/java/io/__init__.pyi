import java
import java.lang
import java.net
import java.nio
import java.nio.channels
import java.nio.charset
import java.nio.file
import java.security
import java.util
import java.util.stream
import typing


class Closeable(java.lang.AutoCloseable):
    """
    public interface Closeable extends :class:`~java.lang.AutoCloseable`
    
        A :code:`Closeable` is a source or destination of data that can be closed. The close method is invoked to release
        resources that the object is holding (such as open files).
    
        Since:
            1.5
    
    
    """
    def close(self) -> None: ...

class DataInput(java.lang.Object):
    """
    public interface DataInput
    
        The :code:`DataInput` interface provides for reading bytes from a binary stream and reconstructing from them data in any
        of the Java primitive types. There is also a facility for reconstructing a :code:`String` from data in
        :meth:`~java.io.DataInput.modified` format.
    
        It is generally true of all the reading routines in this interface that if end of file is reached before the desired
        number of bytes has been read, an :code:`EOFException` (which is a kind of :code:`IOException`) is thrown. If any byte
        cannot be read for any reason other than end of file, an :code:`IOException` other than :code:`EOFException` is thrown.
        In particular, an :code:`IOException` may be thrown if the input stream has been closed.
    
        :class:`~java.io`
    -----------------
    
    
        Implementations of the DataInput and DataOutput interfaces represent Unicode strings in a format that is a slight
        modification of UTF-8. (For information regarding the standard UTF-8 format, see section *3.9 Unicode Encoding Forms* of
        *The Unicode Standard, Version 4.0*)
    
          - Characters in the range :code:`'\u0001'` to :code:`'\u007F'` are represented by a single byte.
          - The null character :code:`'\u0000'` and characters in the range :code:`'\u0080'` to :code:`'\u07FF'` are represented by
            a pair of bytes.
          - Characters in the range :code:`'\u0800'` to :code:`'\uFFFF'` are represented by three bytes.
    
    
        The differences between this format and the standard UTF-8 format are the following:
    
          - The null byte :code:`'\u0000'` is encoded in 2-byte format rather than 1-byte, so that the encoded strings never have
            embedded nulls.
          - Only the 1-byte, 2-byte, and 3-byte formats are used.
          - :meth:`~java.lang.Character.unicode` are represented in the form of surrogate pairs.
    
    
        Since:
            1.0
    
        Also see:
            :class:`~java.io.DataInputStream`, :class:`~java.io.DataOutput`
    
    
    """
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def skipBytes(self, int: int) -> int: ...

class DataOutput(java.lang.Object):
    """
    public interface DataOutput
    
        The :code:`DataOutput` interface provides for converting data from any of the Java primitive types to a series of bytes
        and writing these bytes to a binary stream. There is also a facility for converting a :code:`String` into
        :meth:`~java.io.DataInput.modified` format and writing the resulting series of bytes.
    
        For all the methods in this interface that write bytes, it is generally true that if a byte cannot be written for any
        reason, an :code:`IOException` is thrown.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.io.DataInput`, :class:`~java.io.DataOutputStream`
    
    
    """
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String) -> None: ...

class FileDescriptor(java.lang.Object):
    """
    public final class FileDescriptor extends :class:`~java.lang.Object`
    
        Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure
        representing an open file, an open socket, or another source or sink of bytes. The main practical use for a file
        descriptor is to create a :class:`~java.io.FileInputStream` or :class:`~java.io.FileOutputStream` to contain it.
    
        Applications should not create their own file descriptors.
    
        Since:
            1.0
    
    public FileDescriptor()
    
        Constructs an (invalid) FileDescriptor object. The fd or handle is set later.
    
    """
    in_: typing.ClassVar['FileDescriptor'] = ...
    out: typing.ClassVar['FileDescriptor'] = ...
    err: typing.ClassVar['FileDescriptor'] = ...
    def __init__(self): ...
    def sync(self) -> None: ...
    def valid(self) -> bool: ...

class FileFilter(java.lang.Object):
    """
    :class:`~java.lang.FunctionalInterface` public interface FileFilter
    
        A filter for abstract pathnames.
    
        Instances of this interface may be passed to the :meth:`~java.io.File.listFiles` method of the :class:`~java.io.File`
        class.
    
        Since:
            1.2
    
    
    """
    def accept(self, file: 'File') -> bool: ...

class FilenameFilter(java.lang.Object):
    """
    :class:`~java.lang.FunctionalInterface` public interface FilenameFilter
    
        Instances of classes that implement this interface are used to filter filenames. These instances are used to filter
        directory listings in the :code:`list` method of class :code:`File`, and by the Abstract Window Toolkit's file dialog
        component.
    
        Since:
            1.0
    
        Also see:
            :meth:`~java.awt.FileDialog.setFilenameFilter`, :class:`~java.io.File`, :meth:`~java.io.File.list`
    
    
    """
    def accept(self, file: 'File', string: java.lang.String) -> bool: ...

class Flushable(java.lang.Object):
    """
    public interface Flushable
    
        A :code:`Flushable` is a destination of data that can be flushed. The flush method is invoked to write any buffered
        output to the underlying stream.
    
        Since:
            1.5
    
    
    """
    def flush(self) -> None: ...

class IOError(java.lang.Error):
    """
    public class IOError extends :class:`~java.lang.Error`
    
        Thrown when a serious I/O error has occurred.
    
        Since:
            1.6
    
        Also see:
            Serialized Form
    
    public IOError​(:class:`~java.lang.Throwable` cause)
    
        Constructs a new instance of IOError with the specified cause. The IOError is created with the detail message of
        :code:`(cause==null ? null : cause.toString())` (which typically contains the class and detail message of cause).
    
        Parameters:
            cause (:class:`~java.lang.Throwable`): The cause of this error, or :code:`null` if the cause is not known
    
    
    """
    def __init__(self, throwable: java.lang.Throwable): ...

class IOException(java.lang.Exception):
    """
    public class IOException extends :class:`~java.lang.Exception`
    
        Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by
        failed or interrupted I/O operations.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.io.InputStream`, :class:`~java.io.OutputStream`, Serialized Form
    
    public IOException()
    
        Constructs an :code:`IOException` with :code:`null` as its error detail message.
    public IOException​(:class:`~java.lang.String` message)
    
        Constructs an :code:`IOException` with the specified detail message.
    
        Parameters:
            message (:class:`~java.lang.String`): The detail message (which is saved for later retrieval by the :meth:`~java.lang.Throwable.getMessage` method)
    
    public IOException​(:class:`~java.lang.String` message, :class:`~java.lang.Throwable` cause)
    
        Constructs an :code:`IOException` with the specified detail message and cause.
    
        Note that the detail message associated with :code:`cause` is *not* automatically incorporated into this exception's
        detail message.
    
        Parameters:
            message (:class:`~java.lang.String`): The detail message (which is saved for later retrieval by the :meth:`~java.lang.Throwable.getMessage` method)
            cause (:class:`~java.lang.Throwable`): The cause (which is saved for later retrieval by the :meth:`~java.lang.Throwable.getCause` method). (A null value is
                permitted, and indicates that the cause is nonexistent or unknown.)
    
        Since:
            1.6
    
    public IOException​(:class:`~java.lang.Throwable` cause)
    
        Constructs an :code:`IOException` with the specified cause and a detail message of :code:`(cause==null ? null :
        cause.toString())` (which typically contains the class and detail message of :code:`cause`). This constructor is useful
        for IO exceptions that are little more than wrappers for other throwables.
    
        Parameters:
            cause (:class:`~java.lang.Throwable`): The cause (which is saved for later retrieval by the :meth:`~java.lang.Throwable.getCause` method). (A null value is
                permitted, and indicates that the cause is nonexistent or unknown.)
    
        Since:
            1.6
    
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ObjectInputFilter(java.lang.Object):
    """
    :class:`~java.lang.FunctionalInterface` public interface ObjectInputFilter
    
        Filter classes, array lengths, and graph metrics during deserialization.
    
        **Warning: Deserialization of untrusted data is inherently dangerous and should be avoided. Untrusted data should be
        carefully validated according to the "Serialization and Deserialization" section of the
        :class:`~java.io.https:.www.oracle.com.pls.topic.lookup?ctx=javase11&amp;id=secure_coding_guidelines_javase`.
        :class:`~java.io.https:.www.oracle.com.pls.topic.lookup?ctx=javase11&amp;id=serialization_filter_guide` describes best
        practices for defensive use of serial filters.**
        If set on an :class:`~java.io.ObjectInputStream`, the :meth:`~java.io.ObjectInputFilter.checkInput` method is called to
        validate classes, the length of each array, the number of objects being read from the stream, the depth of the graph,
        and the total number of bytes read from the stream.
    
        A filter can be set via :meth:`~java.io.ObjectInputStream.setObjectInputFilter` for an individual ObjectInputStream. A
        filter can be set via :meth:`~java.io.ObjectInputFilter.Config.setSerialFilter` to affect every
        :code:`ObjectInputStream` that does not otherwise set a filter.
    
        A filter determines whether the arguments are :meth:`~java.io.ObjectInputFilter.Status.ALLOWED` or
        :meth:`~java.io.ObjectInputFilter.Status.REJECTED` and should return the appropriate status. If the filter cannot
        determine the status it should return :meth:`~java.io.ObjectInputFilter.Status.UNDECIDED`. Filters should be designed
        for the specific use case and expected types. A filter designed for a particular use may be passed a class that is
        outside of the scope of the filter. If the purpose of the filter is to black-list classes then it can reject a candidate
        class that matches and report UNDECIDED for others. A filter may be called with class equals :code:`null`,
        :code:`arrayLength` equal -1, the depth, number of references, and stream size and return a status that reflects only
        one or only some of the values. This allows a filter to specific about the choice it is reporting and to use other
        filters without forcing either allowed or rejected status.
    
        Typically, a custom filter should check if a process-wide filter is configured and defer to it if so. For example,
    
        .. code-block: java
        
         ObjectInputFilter.Status checkInput(FilterInfo info) {
             ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();
             if (serialFilter != null) {
                 ObjectInputFilter.Status status = serialFilter.checkInput(info);
                 if (status != ObjectInputFilter.Status.UNDECIDED) {
                     // The process-wide filter overrides this filter
                     return status;
                 }
             }
             if (info.serialClass() != null &&amp;
                 Remote.class.isAssignableFrom(info.serialClass())) {
                 return Status.REJECTED;      // Do not allow Remote objects
             }
             return Status.UNDECIDED;
         }
        
    
        Unless otherwise noted, passing a :code:`null` argument to a method in this interface and its nested classes will cause
        a :class:`~java.lang.NullPointerException` to be thrown.
    
        Since:
            9
    
        Also see:
            :meth:`~java.io.ObjectInputStream.setObjectInputFilter`
    
    
    """
    def checkInput(self, filterInfo: 'ObjectInputFilter.FilterInfo') -> 'ObjectInputFilter.Status': ...
    class Config(java.lang.Object):
        """
        Java class 'java.io.ObjectInputFilter$Config'
        
            Extends:
                java.lang.Object
        
        """
        @classmethod
        def createFilter(cls, string: java.lang.String) -> 'ObjectInputFilter': ...
        @classmethod
        def getSerialFilter(cls) -> 'ObjectInputFilter': ...
        @classmethod
        def setSerialFilter(cls, objectInputFilter: 'ObjectInputFilter') -> None: ...
    class FilterInfo(java.lang.Object):
        """
        Java class 'java.io.ObjectInputFilter$FilterInfo'
        
        """
        def arrayLength(self) -> int: ...
        def depth(self) -> int: ...
        def references(self) -> int: ...
        def serialClass(self) -> typing.Type[typing.Any]: ...
        def streamBytes(self) -> int: ...
    class Status(java.lang.Enum[java.io.ObjectInputFilter.Status]):
        """
        Java class 'java.io.ObjectInputFilter$Status'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            UNDECIDED (java.io.ObjectInputFilter$Status): final static enum constant
            ALLOWED (java.io.ObjectInputFilter$Status): final static enum constant
            REJECTED (java.io.ObjectInputFilter$Status): final static enum constant
        
        """
        UNDECIDED: typing.ClassVar['ObjectInputFilter.Status'] = ...
        ALLOWED: typing.ClassVar['ObjectInputFilter.Status'] = ...
        REJECTED: typing.ClassVar['ObjectInputFilter.Status'] = ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'ObjectInputFilter.Status': ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_1__T], string: java.lang.String) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> typing.List['ObjectInputFilter.Status']: ...

class ObjectInputValidation(java.lang.Object):
    """
    public interface ObjectInputValidation
    
        Callback interface to allow validation of objects within a graph. Allows an object to be called when a complete graph of
        objects has been deserialized.
    
        Since:
            1.1
    
        Also see:
            :class:`~java.io.ObjectInputStream`, :meth:`~java.io.ObjectInputStream.registerValidation`
    
    
    """
    def validateObject(self) -> None: ...

class ObjectStreamConstants(java.lang.Object):
    """
    public interface ObjectStreamConstants
    
        Constants written into the Object Serialization Stream.
    
        Since:
            1.1
    
    
    """
    STREAM_MAGIC: typing.ClassVar[int] = ...
    STREAM_VERSION: typing.ClassVar[int] = ...
    TC_BASE: typing.ClassVar[int] = ...
    TC_NULL: typing.ClassVar[int] = ...
    TC_REFERENCE: typing.ClassVar[int] = ...
    TC_CLASSDESC: typing.ClassVar[int] = ...
    TC_OBJECT: typing.ClassVar[int] = ...
    TC_STRING: typing.ClassVar[int] = ...
    TC_ARRAY: typing.ClassVar[int] = ...
    TC_CLASS: typing.ClassVar[int] = ...
    TC_BLOCKDATA: typing.ClassVar[int] = ...
    TC_ENDBLOCKDATA: typing.ClassVar[int] = ...
    TC_RESET: typing.ClassVar[int] = ...
    TC_BLOCKDATALONG: typing.ClassVar[int] = ...
    TC_EXCEPTION: typing.ClassVar[int] = ...
    TC_LONGSTRING: typing.ClassVar[int] = ...
    TC_PROXYCLASSDESC: typing.ClassVar[int] = ...
    TC_ENUM: typing.ClassVar[int] = ...
    TC_MAX: typing.ClassVar[int] = ...
    baseWireHandle: typing.ClassVar[int] = ...
    SC_WRITE_METHOD: typing.ClassVar[int] = ...
    SC_BLOCK_DATA: typing.ClassVar[int] = ...
    SC_SERIALIZABLE: typing.ClassVar[int] = ...
    SC_EXTERNALIZABLE: typing.ClassVar[int] = ...
    SC_ENUM: typing.ClassVar[int] = ...
    SUBSTITUTION_PERMISSION: typing.ClassVar['SerializablePermission'] = ...
    SUBCLASS_IMPLEMENTATION_PERMISSION: typing.ClassVar['SerializablePermission'] = ...
    SERIAL_FILTER_PERMISSION: typing.ClassVar['SerializablePermission'] = ...
    PROTOCOL_VERSION_1: typing.ClassVar[int] = ...
    PROTOCOL_VERSION_2: typing.ClassVar[int] = ...

class ObjectStreamField(java.lang.Comparable[typing.Any]):
    """
    public class ObjectStreamField extends :class:`~java.lang.Object` implements :class:`~java.lang.Comparable`<:class:`~java.lang.Object`>
    
        A description of a Serializable field from a Serializable class. An array of ObjectStreamFields is used to declare the
        Serializable fields of a class.
    
        Since:
            1.2
    
        Also see:
            :class:`~java.io.ObjectStreamClass`
    
    public ObjectStreamField​(:class:`~java.lang.String` name, :class:`~java.lang.Class`<?>&nbsp;type)
    
        Create a Serializable field with the specified type. This field should be documented with a :code:`serialField` tag.
    
        Parameters:
            name (:class:`~java.lang.String`): the name of the serializable field
            type (:class:`~java.lang.Class`<?>&nbsp;type): the :code:`Class` object of the serializable field
    
    public ObjectStreamField​(:class:`~java.lang.String` name, :class:`~java.lang.Class`<?>&nbsp;type, boolean unshared)
    
        Creates an ObjectStreamField representing a serializable field with the given name and type. If unshared is false,
        values of the represented field are serialized and deserialized in the default manner--if the field is non-primitive,
        object values are serialized and deserialized as if they had been written and read by calls to writeObject and
        readObject. If unshared is true, values of the represented field are serialized and deserialized as if they had been
        written and read by calls to writeUnshared and readUnshared.
    
        Parameters:
            name (:class:`~java.lang.String`): field name
            type (:class:`~java.lang.Class`<?>&nbsp;type): field type
            unshared (boolean): if false, write/read field values in the same manner as writeObject/readObject; if true, write/read in the same manner
                as writeUnshared/readUnshared
    
        Since:
            1.4
    
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, class_: typing.Type[typing.Any]): ...
    @typing.overload
    def __init__(self, string: java.lang.String, class_: typing.Type[typing.Any], boolean: bool): ...
    def compareTo(self, object: typing.Any) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getOffset(self) -> int: ...
    def getType(self) -> typing.Type[typing.Any]: ...
    def getTypeCode(self) -> str: ...
    def getTypeString(self) -> java.lang.String: ...
    def isPrimitive(self) -> bool: ...
    def isUnshared(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class Serializable(java.lang.Object):
    """
    public interface Serializable
    
        Serializability of a class is enabled by the class implementing the java.io.Serializable interface.
    
        **Warning: Deserialization of untrusted data is inherently dangerous and should be avoided. Untrusted data should be
        carefully validated according to the "Serialization and Deserialization" section of the
        :class:`~java.io.https:.www.oracle.com.pls.topic.lookup?ctx=javase11&amp;id=secure_coding_guidelines_javase`.
        :class:`~java.io.https:.www.oracle.com.pls.topic.lookup?ctx=javase11&amp;id=serialization_filter_guide` describes best
        practices for defensive use of serial filters.**
        Classes that do not implement this interface will not have any of their state serialized or deserialized. All subtypes
        of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves
        only to identify the semantics of being serializable.
    
        To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and
        restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume
        this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state.
        It is an error to declare a class Serializable if this is not the case. The error will be detected at runtime.
    
        During deserialization, the fields of non-serializable classes will be initialized using the public or protected no-arg
        constructor of the class. A no-arg constructor must be accessible to the subclass that is serializable. The fields of
        serializable subclasses will be restored from the stream.
    
        When traversing a graph, an object may be encountered that does not support the Serializable interface. In this case the
        NotSerializableException will be thrown and will identify the class of the non-serializable object.
    
        Classes that require special handling during the serialization and deserialization process must implement special
        methods with these exact signatures:
    
        .. code-block: java
        
         private void writeObject(java.io.ObjectOutputStream out)
             throws IOException
         private void readObject(java.io.ObjectInputStream in)
             throws IOException, ClassNotFoundException;
         private void readObjectNoData()
             throws ObjectStreamException;
         
    
        The writeObject method is responsible for writing the state of the object for its particular class so that the
        corresponding readObject method can restore it. The default mechanism for saving the Object's fields can be invoked by
        calling out.defaultWriteObject. The method does not need to concern itself with the state belonging to its superclasses
        or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or
        by using the methods for primitive data types supported by DataOutput.
    
        The readObject method is responsible for reading from the stream and restoring the classes fields. It may call
        in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The
        defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the
        correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields.
        The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored
        by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of
        the object. Reading primitive data types is supported by DataInput.
    
        The readObjectNoData method is responsible for initializing the state of the object for its particular class in the
        event that the serialization stream does not list the given class as a superclass of the object being deserialized. This
        may occur in cases where the receiving party uses a different version of the deserialized instance's class than the
        sending party, and the receiver's version extends classes that are not extended by the sender's version. This may also
        occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized
        objects properly despite a "hostile" or incomplete source stream.
    
        Serializable classes that need to designate an alternative object to be used when writing an object to the stream should
        implement this special method with the exact signature:
    
        .. code-block: java
        
         ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
         
    
        This writeReplace method is invoked by serialization if the method exists and it would be accessible from a method
        defined within the class of the object being serialized. Thus, the method can have private, protected and
        package-private access. Subclass access to this method follows java accessibility rules.
    
        Classes that need to designate a replacement when an instance of it is read from the stream should implement this
        special method with the exact signature.
    
        .. code-block: java
        
         ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
         
    
        This readResolve method follows the same invocation rules and accessibility rules as writeReplace.
    
        The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is
        used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that
        object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a
        different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an
        :class:`~java.io.InvalidClassException`. A serializable class can declare its own serialVersionUID explicitly by
        declaring a field named :code:`"serialVersionUID"` that must be static, final, and of type :code:`long`:
    
        .. code-block: java
        
         ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
         
        If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a
        default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object
        Serialization Specification. However, it is *strongly recommended* that all serializable classes explicitly declare
        serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may
        vary depending on compiler implementations, and can thus result in unexpected :code:`InvalidClassException`s during
        deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler
        implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that
        explicit serialVersionUID declarations use the :code:`private` modifier where possible, since such declarations apply
        only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes
        cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for
        matching serialVersionUID values is waived for array classes.
    
        Since:
            1.1
    
        Also see:
            :class:`~java.io.ObjectOutputStream`, :class:`~java.io.ObjectInputStream`, :class:`~java.io.ObjectOutput`,
            :class:`~java.io.ObjectInput`, :class:`~java.io.Externalizable`
    
    
    """

class SerializablePermission(java.security.BasicPermission):
    """
    Java class 'java.io.SerializablePermission'
    
        Extends:
            java.security.BasicPermission
    
      Constructors:
        * SerializablePermission(java.lang.String)
        * SerializablePermission(java.lang.String, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...

class StreamTokenizer(java.lang.Object):
    """
    public class StreamTokenizer extends :class:`~java.lang.Object`
    
        The :code:`StreamTokenizer` class takes an input stream and parses it into "tokens", allowing the tokens to be read one
        at a time. The parsing process is controlled by a table and a number of flags that can be set to various states. The
        stream tokenizer can recognize identifiers, numbers, quoted strings, and various comment styles.
    
        Each byte read from the input stream is regarded as a character in the range :code:`'\u0000'` through :code:`'\u00FF'`.
        The character value is used to look up five possible attributes of the character: *white space*, *alphabetic*,
        *numeric*, *string quote*, and *comment character*. Each character can have zero or more of these attributes.
    
        In addition, an instance has four flags. These flags indicate:
    
          - Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.
          - Whether C-style comments are to be recognized and skipped.
          - Whether C++-style comments are to be recognized and skipped.
          - Whether the characters of identifiers are converted to lowercase.
    
    
        A typical application first constructs an instance of this class, sets up the syntax tables, and then repeatedly loops
        calling the :code:`nextToken` method in each iteration of the loop until it returns the value :code:`TT_EOF`.
    
        Since:
            1.0
    
        Also see:
            :meth:`~java.io.StreamTokenizer.nextToken`, :meth:`~java.io.StreamTokenizer.TT_EOF`
    
    :class:`~java.lang.Deprecated` public StreamTokenizer​(:class:`~java.io.InputStream` is)
    
        Deprecated.
        As of JDK version 1.1, the preferred way to tokenize an input stream is to convert it into a character stream, for
        example:
    
            .. code-block: java
            
               Reader r = new BufferedReader(new InputStreamReader(is));
               StreamTokenizer st = new StreamTokenizer(r);
             
        Creates a stream tokenizer that parses the specified input stream. The stream tokenizer is initialized to the following
        default state:
    
          - All byte values :code:`'A'` through :code:`'Z'`, :code:`'a'` through :code:`'z'`, and :code:`'\u00A0'` through
            :code:`'\u00FF'` are considered to be alphabetic.
          - All byte values :code:`'\u0000'` through :code:`'\u0020'` are considered to be white space.
          - :code:`'/'` is a comment character.
          - Single quote :code:`'\''` and double quote :code:`'"'` are string quote characters.
          - Numbers are parsed.
          - Ends of lines are treated as white space, not as separate tokens.
          - C-style and C++-style comments are not recognized.
    
    
        Parameters:
            is (:class:`~java.io.InputStream`): an input stream.
    
        Also see:
            :class:`~java.io.BufferedReader`, :class:`~java.io.InputStreamReader`, :meth:`~java.io.StreamTokenizer.%3Cinit%3E`
    
    public StreamTokenizer​(:class:`~java.io.Reader` r)
    
        Create a tokenizer that parses the given character stream.
    
        Parameters:
            r (:class:`~java.io.Reader`): a Reader object providing the input stream.
    
        Since:
            1.1
    
    
    """
    ttype: int = ...
    TT_EOF: typing.ClassVar[int] = ...
    TT_EOL: typing.ClassVar[int] = ...
    TT_NUMBER: typing.ClassVar[int] = ...
    TT_WORD: typing.ClassVar[int] = ...
    sval: java.lang.String = ...
    nval: float = ...
    @typing.overload
    def __init__(self, inputStream: 'InputStream'): ...
    @typing.overload
    def __init__(self, reader: 'Reader'): ...
    def commentChar(self, int: int) -> None: ...
    def eolIsSignificant(self, boolean: bool) -> None: ...
    def lineno(self) -> int: ...
    def lowerCaseMode(self, boolean: bool) -> None: ...
    def nextToken(self) -> int: ...
    def ordinaryChar(self, int: int) -> None: ...
    def ordinaryChars(self, int: int, int2: int) -> None: ...
    def parseNumbers(self) -> None: ...
    def pushBack(self) -> None: ...
    def quoteChar(self, int: int) -> None: ...
    def resetSyntax(self) -> None: ...
    def slashSlashComments(self, boolean: bool) -> None: ...
    def slashStarComments(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...
    def whitespaceChars(self, int: int, int2: int) -> None: ...
    def wordChars(self, int: int, int2: int) -> None: ...

class UncheckedIOException(java.lang.RuntimeException):
    """
    Java class 'java.io.UncheckedIOException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * UncheckedIOException(java.lang.String, java.io.IOException)
        * UncheckedIOException(java.io.IOException)
    
    """
    @typing.overload
    def __init__(self, iOException: IOException): ...
    @typing.overload
    def __init__(self, string: java.lang.String, iOException: IOException): ...
    @typing.overload
    def getCause(self) -> IOException: ...
    @typing.overload
    def getCause(self) -> java.lang.Throwable: ...

class CharConversionException(IOException):
    """
    Java class 'java.io.CharConversionException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * CharConversionException()
        * CharConversionException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class Console(Flushable):
    """
    Java class 'java.io.Console'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Flushable
    
    """
    def flush(self) -> None: ...
    def format(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'Console': ...
    def printf(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'Console': ...
    @typing.overload
    def readLine(self) -> java.lang.String: ...
    @typing.overload
    def readLine(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> java.lang.String: ...
    @typing.overload
    def readPassword(self) -> typing.List[str]: ...
    @typing.overload
    def readPassword(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> typing.List[str]: ...
    def reader(self) -> 'Reader': ...
    def writer(self) -> 'PrintWriter': ...

class EOFException(IOException):
    """
    Java class 'java.io.EOFException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * EOFException()
        * EOFException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class Externalizable(Serializable):
    """
    Java class 'java.io.Externalizable'
    
        Interfaces:
            java.io.Serializable
    
    """
    def readExternal(self, objectInput: 'ObjectInput') -> None: ...
    def writeExternal(self, objectOutput: 'ObjectOutput') -> None: ...

class File(Serializable, java.lang.Comparable[java.io.File]):
    """
    Java class 'java.io.File'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable
    
      Constructors:
        * File(java.net.URI)
        * File(java.lang.String, java.lang.String)
        * File(java.io.File, java.lang.String)
        * File(java.lang.String)
    
      Attributes:
        separatorChar (char): final static field
        separator (java.lang.String): final static field
        pathSeparatorChar (char): final static field
        pathSeparator (java.lang.String): final static field
    
    """
    separatorChar: typing.ClassVar[str] = ...
    separator: typing.ClassVar[java.lang.String] = ...
    pathSeparatorChar: typing.ClassVar[str] = ...
    pathSeparator: typing.ClassVar[java.lang.String] = ...
    @typing.overload
    def __init__(self, file: 'File', string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, uRI: java.net.URI): ...
    def canExecute(self) -> bool: ...
    def canRead(self) -> bool: ...
    def canWrite(self) -> bool: ...
    @typing.overload
    def compareTo(self, file: 'File') -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    def createNewFile(self) -> bool: ...
    @classmethod
    @typing.overload
    def createTempFile(cls, string: java.lang.String, string2: java.lang.String) -> 'File': ...
    @classmethod
    @typing.overload
    def createTempFile(cls, string: java.lang.String, string2: java.lang.String, file: 'File') -> 'File': ...
    def delete(self) -> bool: ...
    def deleteOnExit(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exists(self) -> bool: ...
    def getAbsoluteFile(self) -> 'File': ...
    def getAbsolutePath(self) -> java.lang.String: ...
    def getCanonicalFile(self) -> 'File': ...
    def getCanonicalPath(self) -> java.lang.String: ...
    def getFreeSpace(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getParent(self) -> java.lang.String: ...
    def getParentFile(self) -> 'File': ...
    def getPath(self) -> java.lang.String: ...
    def getTotalSpace(self) -> int: ...
    def getUsableSpace(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isDirectory(self) -> bool: ...
    def isFile(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def lastModified(self) -> int: ...
    def length(self) -> int: ...
    @typing.overload
    def list(self) -> typing.List[java.lang.String]: ...
    @typing.overload
    def list(self, filenameFilter: FilenameFilter) -> typing.List[java.lang.String]: ...
    @typing.overload
    def listFiles(self) -> typing.List['File']: ...
    @typing.overload
    def listFiles(self, fileFilter: FileFilter) -> typing.List['File']: ...
    @typing.overload
    def listFiles(self, filenameFilter: FilenameFilter) -> typing.List['File']: ...
    @classmethod
    def listRoots(cls) -> typing.List['File']: ...
    def mkdir(self) -> bool: ...
    def mkdirs(self) -> bool: ...
    def renameTo(self, file: 'File') -> bool: ...
    @typing.overload
    def setExecutable(self, boolean: bool) -> bool: ...
    @typing.overload
    def setExecutable(self, boolean: bool, boolean2: bool) -> bool: ...
    def setLastModified(self, long: int) -> bool: ...
    def setReadOnly(self) -> bool: ...
    @typing.overload
    def setReadable(self, boolean: bool) -> bool: ...
    @typing.overload
    def setReadable(self, boolean: bool, boolean2: bool) -> bool: ...
    @typing.overload
    def setWritable(self, boolean: bool) -> bool: ...
    @typing.overload
    def setWritable(self, boolean: bool, boolean2: bool) -> bool: ...
    def toPath(self) -> java.nio.file.Path: ...
    def toString(self) -> java.lang.String: ...
    def toURI(self) -> java.net.URI: ...
    def toURL(self) -> java.net.URL: ...

class FileNotFoundException(IOException):
    """
    Java class 'java.io.FileNotFoundException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * FileNotFoundException()
        * FileNotFoundException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class FilePermission(java.security.Permission):
    """
    Java class 'java.io.FilePermission'
    
        Extends:
            java.security.Permission
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * FilePermission(java.lang.String, java.lang.String)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class InputStream(Closeable):
    """
    Java class 'java.io.InputStream'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * InputStream()
    
    """
    def __init__(self): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @classmethod
    def nullInputStream(cls) -> 'InputStream': ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def readAllBytes(self) -> typing.List[int]: ...
    @typing.overload
    def readNBytes(self, int: int) -> typing.List[int]: ...
    @typing.overload
    def readNBytes(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...
    def transferTo(self, outputStream: 'OutputStream') -> int: ...

class InterruptedIOException(IOException):
    """
    Java class 'java.io.InterruptedIOException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * InterruptedIOException()
        * InterruptedIOException(java.lang.String)
    
      Attributes:
        bytesTransferred (int): field
    
    """
    bytesTransferred: int = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ObjectInput(DataInput, java.lang.AutoCloseable):
    """
    Java class 'java.io.ObjectInput'
    
        Interfaces:
            java.io.DataInput, java.lang.AutoCloseable
    
    """
    def available(self) -> int: ...
    def close(self) -> None: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def readObject(self) -> typing.Any: ...
    def skip(self, long: int) -> int: ...

class ObjectOutput(DataOutput, java.lang.AutoCloseable):
    """
    Java class 'java.io.ObjectOutput'
    
        Interfaces:
            java.io.DataOutput, java.lang.AutoCloseable
    
    """
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    def writeObject(self, object: typing.Any) -> None: ...

class ObjectStreamClass(Serializable):
    """
    Java class 'java.io.ObjectStreamClass'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        NO_FIELDS ([Ljava.io.ObjectStreamField;): final static field
    
    """
    NO_FIELDS: typing.ClassVar[typing.List[ObjectStreamField]] = ...
    def forClass(self) -> typing.Type[typing.Any]: ...
    def getField(self, string: java.lang.String) -> ObjectStreamField: ...
    def getFields(self) -> typing.List[ObjectStreamField]: ...
    def getName(self) -> java.lang.String: ...
    def getSerialVersionUID(self) -> int: ...
    @classmethod
    def lookup(cls, class_: typing.Type[typing.Any]) -> 'ObjectStreamClass': ...
    @classmethod
    def lookupAny(cls, class_: typing.Type[typing.Any]) -> 'ObjectStreamClass': ...
    def toString(self) -> java.lang.String: ...

class ObjectStreamException(IOException):
    """
    Java class 'java.io.ObjectStreamException'
    
        Extends:
            java.io.IOException
    
    """

class OutputStream(Closeable, Flushable):
    """
    Java class 'java.io.OutputStream'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable, java.io.Flushable
    
      Constructors:
        * OutputStream()
    
    """
    def __init__(self): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @classmethod
    def nullOutputStream(cls) -> 'OutputStream': ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...

class RandomAccessFile(DataOutput, DataInput, Closeable):
    """
    Java class 'java.io.RandomAccessFile'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.DataOutput, java.io.DataInput, java.io.Closeable
    
      Constructors:
        * RandomAccessFile(java.lang.String, java.lang.String)
        * RandomAccessFile(java.io.File, java.lang.String)
    
      Raises:
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.FileChannel: ...
    def getFD(self) -> FileDescriptor: ...
    def getFilePointer(self) -> int: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def seek(self, long: int) -> None: ...
    def setLength(self, long: int) -> None: ...
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String) -> None: ...

class Reader(java.lang.Readable, Closeable):
    """
    Java class 'java.io.Reader'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Readable, java.io.Closeable
    
    """
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @classmethod
    def nullReader(cls) -> 'Reader': ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...
    def transferTo(self, writer: 'Writer') -> int: ...

class SyncFailedException(IOException):
    """
    Java class 'java.io.SyncFailedException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * SyncFailedException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...

class UTFDataFormatException(IOException):
    """
    Java class 'java.io.UTFDataFormatException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * UTFDataFormatException()
        * UTFDataFormatException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class UnsupportedEncodingException(IOException):
    """
    Java class 'java.io.UnsupportedEncodingException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * UnsupportedEncodingException()
        * UnsupportedEncodingException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class Writer(java.lang.Appendable, Closeable, Flushable):
    """
    Java class 'java.io.Writer'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Appendable, java.io.Closeable, java.io.Flushable
    
    """
    @typing.overload
    def append(self, char: str) -> 'Writer': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'Writer': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'Writer': ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @classmethod
    def nullWriter(cls) -> 'Writer': ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...

class BufferedReader(Reader):
    """
    Java class 'java.io.BufferedReader'
    
        Extends:
            java.io.Reader
    
      Constructors:
        * BufferedReader(java.io.Reader, int)
        * BufferedReader(java.io.Reader)
    
    """
    @typing.overload
    def __init__(self, reader: Reader): ...
    @typing.overload
    def __init__(self, reader: Reader, int: int): ...
    def close(self) -> None: ...
    def lines(self) -> java.util.stream.Stream[java.lang.String]: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class BufferedWriter(Writer):
    """
    Java class 'java.io.BufferedWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * BufferedWriter(java.io.Writer)
        * BufferedWriter(java.io.Writer, int)
    
    """
    @typing.overload
    def __init__(self, writer: Writer): ...
    @typing.overload
    def __init__(self, writer: Writer, int: int): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def newLine(self) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...

class ByteArrayInputStream(InputStream):
    """
    Java class 'java.io.ByteArrayInputStream'
    
        Extends:
            java.io.InputStream
    
      Constructors:
        * ByteArrayInputStream(byte[])
        * ByteArrayInputStream(byte[], int, int)
    
    """
    @typing.overload
    def __init__(self, byteArray: typing.List[int]): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def readAllBytes(self) -> typing.List[int]: ...
    @typing.overload
    def readNBytes(self, int: int) -> typing.List[int]: ...
    @typing.overload
    def readNBytes(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...
    def transferTo(self, outputStream: OutputStream) -> int: ...

class ByteArrayOutputStream(OutputStream):
    """
    Java class 'java.io.ByteArrayOutputStream'
    
        Extends:
            java.io.OutputStream
    
      Constructors:
        * ByteArrayOutputStream()
        * ByteArrayOutputStream(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def close(self) -> None: ...
    def reset(self) -> None: ...
    def size(self) -> int: ...
    def toByteArray(self) -> typing.List[int]: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def toString(self, int: int) -> java.lang.String: ...
    @typing.overload
    def toString(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def toString(self, charset: java.nio.charset.Charset) -> java.lang.String: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    def writeBytes(self, byteArray: typing.List[int]) -> None: ...
    def writeTo(self, outputStream: OutputStream) -> None: ...

class CharArrayReader(Reader):
    """
    Java class 'java.io.CharArrayReader'
    
        Extends:
            java.io.Reader
    
      Constructors:
        * CharArrayReader(char[])
        * CharArrayReader(char[], int, int)
    
    """
    @typing.overload
    def __init__(self, charArray: typing.List[str]): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str], int: int, int2: int): ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class CharArrayWriter(Writer):
    """
    Java class 'java.io.CharArrayWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * CharArrayWriter()
        * CharArrayWriter(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def append(self, char: str) -> 'CharArrayWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'CharArrayWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'CharArrayWriter': ...
    @typing.overload
    def append(self, char: str) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> Writer: ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def reset(self) -> None: ...
    def size(self) -> int: ...
    def toCharArray(self) -> typing.List[str]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...
    def writeTo(self, writer: Writer) -> None: ...

class FileInputStream(InputStream):
    """
    Java class 'java.io.FileInputStream'
    
        Extends:
            java.io.InputStream
    
      Constructors:
        * FileInputStream(java.io.FileDescriptor)
        * FileInputStream(java.io.File)
        * FileInputStream(java.lang.String)
    
      Raises:
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, fileDescriptor: FileDescriptor): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.FileChannel: ...
    def getFD(self) -> FileDescriptor: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def skip(self, long: int) -> int: ...

class FileOutputStream(OutputStream):
    """
    Java class 'java.io.FileOutputStream'
    
        Extends:
            java.io.OutputStream
    
      Constructors:
        * FileOutputStream(java.io.FileDescriptor)
        * FileOutputStream(java.io.File, boolean)
        * FileOutputStream(java.io.File)
        * FileOutputStream(java.lang.String, boolean)
        * FileOutputStream(java.lang.String)
    
      Raises:
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, file: File, boolean: bool): ...
    @typing.overload
    def __init__(self, fileDescriptor: FileDescriptor): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, boolean: bool): ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.FileChannel: ...
    def getFD(self) -> FileDescriptor: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class FilterInputStream(InputStream):
    """
    Java class 'java.io.FilterInputStream'
    
        Extends:
            java.io.InputStream
    
    """
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class FilterOutputStream(OutputStream):
    """
    Java class 'java.io.FilterOutputStream'
    
        Extends:
            java.io.OutputStream
    
      Constructors:
        * FilterOutputStream(java.io.OutputStream)
    
    """
    def __init__(self, outputStream: OutputStream): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class FilterReader(Reader):
    """
    Java class 'java.io.FilterReader'
    
        Extends:
            java.io.Reader
    
    """
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class FilterWriter(Writer):
    """
    Java class 'java.io.FilterWriter'
    
        Extends:
            java.io.Writer
    
    """
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...

class InputStreamReader(Reader):
    """
    Java class 'java.io.InputStreamReader'
    
        Extends:
            java.io.Reader
    
      Constructors:
        * InputStreamReader(java.io.InputStream, java.nio.charset.CharsetDecoder)
        * InputStreamReader(java.io.InputStream, java.nio.charset.Charset)
        * InputStreamReader(java.io.InputStream, java.lang.String)
        * InputStreamReader(java.io.InputStream)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
    
    """
    @typing.overload
    def __init__(self, inputStream: InputStream): ...
    @typing.overload
    def __init__(self, inputStream: InputStream, string: java.lang.String): ...
    @typing.overload
    def __init__(self, inputStream: InputStream, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, inputStream: InputStream, charsetDecoder: java.nio.charset.CharsetDecoder): ...
    def close(self) -> None: ...
    def getEncoding(self) -> java.lang.String: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def ready(self) -> bool: ...

class InvalidClassException(ObjectStreamException):
    """
    Java class 'java.io.InvalidClassException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * InvalidClassException(java.lang.String)
        * InvalidClassException(java.lang.String, java.lang.String)
    
      Attributes:
        classname (java.lang.String): field
    
    """
    classname: java.lang.String = ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def getMessage(self) -> java.lang.String: ...

class InvalidObjectException(ObjectStreamException):
    """
    Java class 'java.io.InvalidObjectException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * InvalidObjectException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...

class NotActiveException(ObjectStreamException):
    """
    Java class 'java.io.NotActiveException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * NotActiveException(java.lang.String)
        * NotActiveException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class NotSerializableException(ObjectStreamException):
    """
    Java class 'java.io.NotSerializableException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * NotSerializableException(java.lang.String)
        * NotSerializableException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ObjectInputStream(InputStream, ObjectInput, ObjectStreamConstants):
    """
    Java class 'java.io.ObjectInputStream'
    
        Extends:
            java.io.InputStream
    
        Interfaces:
            java.io.ObjectInput, java.io.ObjectStreamConstants
    
      Constructors:
        * ObjectInputStream(java.io.InputStream)
    
      Raises:
        java.io.IOException: from java
    
    """
    def __init__(self, inputStream: InputStream): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def defaultReadObject(self) -> None: ...
    def getObjectInputFilter(self) -> ObjectInputFilter: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFields(self) -> 'ObjectInputStream.GetField': ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readObject(self) -> typing.Any: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnshared(self) -> typing.Any: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def registerValidation(self, objectInputValidation: ObjectInputValidation, int: int) -> None: ...
    def setObjectInputFilter(self, objectInputFilter: ObjectInputFilter) -> None: ...
    def skipBytes(self, int: int) -> int: ...
    class GetField(java.lang.Object):
        """
        Java class 'java.io.ObjectInputStream$GetField'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * GetField()
        
        """
        def __init__(self): ...
        def defaulted(self, string: java.lang.String) -> bool: ...
        @typing.overload
        def get(self, string: java.lang.String, boolean: bool) -> bool: ...
        @typing.overload
        def get(self, string: java.lang.String, byte: int) -> int: ...
        @typing.overload
        def get(self, string: java.lang.String, char: str) -> str: ...
        @typing.overload
        def get(self, string: java.lang.String, double: float) -> float: ...
        @typing.overload
        def get(self, string: java.lang.String, float: float) -> float: ...
        @typing.overload
        def get(self, string: java.lang.String, int: int) -> int: ...
        @typing.overload
        def get(self, string: java.lang.String, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def get(self, string: java.lang.String, long: int) -> int: ...
        @typing.overload
        def get(self, string: java.lang.String, short: int) -> int: ...
        def getObjectStreamClass(self) -> ObjectStreamClass: ...

class ObjectOutputStream(OutputStream, ObjectOutput, ObjectStreamConstants):
    """
    Java class 'java.io.ObjectOutputStream'
    
        Extends:
            java.io.OutputStream
    
        Interfaces:
            java.io.ObjectOutput, java.io.ObjectStreamConstants
    
      Constructors:
        * ObjectOutputStream(java.io.OutputStream)
    
      Raises:
        java.io.IOException: from java
    
    """
    def __init__(self, outputStream: OutputStream): ...
    def close(self) -> None: ...
    def defaultWriteObject(self) -> None: ...
    def flush(self) -> None: ...
    def putFields(self) -> 'ObjectOutputStream.PutField': ...
    def reset(self) -> None: ...
    def useProtocolVersion(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFields(self) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeObject(self, object: typing.Any) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String) -> None: ...
    def writeUnshared(self, object: typing.Any) -> None: ...
    class PutField(java.lang.Object):
        """
        Java class 'java.io.ObjectOutputStream$PutField'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * PutField()
        
        """
        def __init__(self): ...
        @typing.overload
        def put(self, string: java.lang.String, boolean: bool) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, byte: int) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, char: str) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, double: float) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, float: float) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, int: int) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, object: typing.Any) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, long: int) -> None: ...
        @typing.overload
        def put(self, string: java.lang.String, short: int) -> None: ...
        def write(self, objectOutput: ObjectOutput) -> None: ...

class OptionalDataException(ObjectStreamException):
    """
    Java class 'java.io.OptionalDataException'
    
        Extends:
            java.io.ObjectStreamException
    
      Attributes:
        length (int): field
        eof (boolean): field
    
    """
    length: int = ...
    eof: bool = ...

class OutputStreamWriter(Writer):
    """
    Java class 'java.io.OutputStreamWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * OutputStreamWriter(java.io.OutputStream, java.nio.charset.CharsetEncoder)
        * OutputStreamWriter(java.io.OutputStream, java.nio.charset.Charset)
        * OutputStreamWriter(java.io.OutputStream)
        * OutputStreamWriter(java.io.OutputStream, java.lang.String)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
    
    """
    @typing.overload
    def __init__(self, outputStream: OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, string: java.lang.String): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, charsetEncoder: java.nio.charset.CharsetEncoder): ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> Writer: ...
    @typing.overload
    def append(self, char: str) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def getEncoding(self) -> java.lang.String: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...

class PipedInputStream(InputStream):
    """
    Java class 'java.io.PipedInputStream'
    
        Extends:
            java.io.InputStream
    
      Constructors:
        * PipedInputStream(int)
        * PipedInputStream()
        * PipedInputStream(java.io.PipedOutputStream, int)
        * PipedInputStream(java.io.PipedOutputStream)
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, pipedOutputStream: 'PipedOutputStream'): ...
    @typing.overload
    def __init__(self, pipedOutputStream: 'PipedOutputStream', int: int): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def connect(self, pipedOutputStream: 'PipedOutputStream') -> None: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...

class PipedOutputStream(OutputStream):
    """
    Java class 'java.io.PipedOutputStream'
    
        Extends:
            java.io.OutputStream
    
      Constructors:
        * PipedOutputStream(java.io.PipedInputStream)
        * PipedOutputStream()
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, pipedInputStream: PipedInputStream): ...
    def close(self) -> None: ...
    def connect(self, pipedInputStream: PipedInputStream) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class PipedReader(Reader):
    """
    Java class 'java.io.PipedReader'
    
        Extends:
            java.io.Reader
    
      Constructors:
        * PipedReader(int)
        * PipedReader()
        * PipedReader(java.io.PipedWriter, int)
        * PipedReader(java.io.PipedWriter)
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, pipedWriter: 'PipedWriter'): ...
    @typing.overload
    def __init__(self, pipedWriter: 'PipedWriter', int: int): ...
    def close(self) -> None: ...
    def connect(self, pipedWriter: 'PipedWriter') -> None: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    def ready(self) -> bool: ...

class PipedWriter(Writer):
    """
    Java class 'java.io.PipedWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * PipedWriter(java.io.PipedReader)
        * PipedWriter()
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, pipedReader: PipedReader): ...
    def close(self) -> None: ...
    def connect(self, pipedReader: PipedReader) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...

class PrintWriter(Writer):
    """
    Java class 'java.io.PrintWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * PrintWriter(java.lang.String)
        * PrintWriter(java.lang.String, java.lang.String)
        * PrintWriter(java.lang.String, java.nio.charset.Charset)
        * PrintWriter(java.io.File)
        * PrintWriter(java.io.File, java.lang.String)
        * PrintWriter(java.io.File, java.nio.charset.Charset)
        * PrintWriter(java.io.Writer)
        * PrintWriter(java.io.Writer, boolean)
        * PrintWriter(java.io.OutputStream, boolean, java.nio.charset.Charset)
        * PrintWriter(java.io.OutputStream, boolean)
        * PrintWriter(java.io.OutputStream)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
        java.io.IOException: from java
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, file: File, string: java.lang.String): ...
    @typing.overload
    def __init__(self, file: File, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, boolean: bool): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, boolean: bool, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, writer: Writer): ...
    @typing.overload
    def __init__(self, writer: Writer, boolean: bool): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset): ...
    @typing.overload
    def append(self, char: str) -> 'PrintWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'PrintWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'PrintWriter': ...
    @typing.overload
    def append(self, char: str) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> Writer: ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    def checkError(self) -> bool: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def format(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintWriter': ...
    @typing.overload
    def format(self, locale: java.util.Locale, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintWriter': ...
    @typing.overload
    def printf(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintWriter': ...
    @typing.overload
    def printf(self, locale: java.util.Locale, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintWriter': ...
    @typing.overload
    def println(self) -> None: ...
    @typing.overload
    def println(self, boolean: bool) -> None: ...
    @typing.overload
    def println(self, char: str) -> None: ...
    @typing.overload
    def println(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def println(self, double: float) -> None: ...
    @typing.overload
    def println(self, float: float) -> None: ...
    @typing.overload
    def println(self, int: int) -> None: ...
    @typing.overload
    def println(self, object: typing.Any) -> None: ...
    @typing.overload
    def println(self, string: java.lang.String) -> None: ...
    @typing.overload
    def println(self, long: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...

class SequenceInputStream(InputStream):
    """
    Java class 'java.io.SequenceInputStream'
    
        Extends:
            java.io.InputStream
    
      Constructors:
        * SequenceInputStream(java.util.Enumeration)
        * SequenceInputStream(java.io.InputStream, java.io.InputStream)
    
    """
    @typing.overload
    def __init__(self, inputStream: InputStream, inputStream2: InputStream): ...
    @typing.overload
    def __init__(self, enumeration: java.util.Enumeration[InputStream]): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...

class StreamCorruptedException(ObjectStreamException):
    """
    Java class 'java.io.StreamCorruptedException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * StreamCorruptedException(java.lang.String)
        * StreamCorruptedException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class StringBufferInputStream(InputStream):
    """
    Java class 'java.io.StringBufferInputStream'
    
        Extends:
            java.io.InputStream
    
      Constructors:
        * StringBufferInputStream(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def available(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class StringReader(Reader):
    """
    Java class 'java.io.StringReader'
    
        Extends:
            java.io.Reader
    
      Constructors:
        * StringReader(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class StringWriter(Writer):
    """
    Java class 'java.io.StringWriter'
    
        Extends:
            java.io.Writer
    
      Constructors:
        * StringWriter()
        * StringWriter(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def append(self, char: str) -> 'StringWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'StringWriter': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'StringWriter': ...
    @typing.overload
    def append(self, char: str) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> Writer: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> Writer: ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def getBuffer(self) -> java.lang.StringBuffer: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def write(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String) -> None: ...
    @typing.overload
    def write(self, string: java.lang.String, int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, charArray: typing.List[str]) -> None: ...

class WriteAbortedException(ObjectStreamException):
    """
    Java class 'java.io.WriteAbortedException'
    
        Extends:
            java.io.ObjectStreamException
    
      Constructors:
        * WriteAbortedException(java.lang.String, java.lang.Exception)
    
      Attributes:
        detail (java.lang.Exception): field
    
    """
    detail: java.lang.Exception = ...
    def __init__(self, string: java.lang.String, exception: java.lang.Exception): ...
    def getCause(self) -> java.lang.Throwable: ...
    def getMessage(self) -> java.lang.String: ...

class BufferedInputStream(FilterInputStream):
    """
    Java class 'java.io.BufferedInputStream'
    
        Extends:
            java.io.FilterInputStream
    
      Constructors:
        * BufferedInputStream(java.io.InputStream, int)
        * BufferedInputStream(java.io.InputStream)
    
    """
    @typing.overload
    def __init__(self, inputStream: InputStream): ...
    @typing.overload
    def __init__(self, inputStream: InputStream, int: int): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class BufferedOutputStream(FilterOutputStream):
    """
    Java class 'java.io.BufferedOutputStream'
    
        Extends:
            java.io.FilterOutputStream
    
      Constructors:
        * BufferedOutputStream(java.io.OutputStream)
        * BufferedOutputStream(java.io.OutputStream, int)
    
    """
    @typing.overload
    def __init__(self, outputStream: OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, int: int): ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...

class DataInputStream(FilterInputStream, DataInput):
    """
    Java class 'java.io.DataInputStream'
    
        Extends:
            java.io.FilterInputStream
    
        Interfaces:
            java.io.DataInput
    
      Constructors:
        * DataInputStream(java.io.InputStream)
    
    """
    def __init__(self, inputStream: InputStream): ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def readFully(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    @typing.overload
    def readUTF(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def readUTF(cls, dataInput: DataInput) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def skipBytes(self, int: int) -> int: ...

class DataOutputStream(FilterOutputStream, DataOutput):
    """
    Java class 'java.io.DataOutputStream'
    
        Extends:
            java.io.FilterOutputStream
    
        Interfaces:
            java.io.DataOutput
    
      Constructors:
        * DataOutputStream(java.io.OutputStream)
    
    """
    def __init__(self, outputStream: OutputStream): ...
    def flush(self) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String) -> None: ...

class FileReader(InputStreamReader):
    """
    Java class 'java.io.FileReader'
    
        Extends:
            java.io.InputStreamReader
    
      Constructors:
        * FileReader(java.io.File, java.nio.charset.Charset)
        * FileReader(java.lang.String, java.nio.charset.Charset)
        * FileReader(java.io.FileDescriptor)
        * FileReader(java.io.File)
        * FileReader(java.lang.String)
    
      Raises:
        java.io.IOException: from java
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, file: File, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, fileDescriptor: FileDescriptor): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset): ...

class FileWriter(OutputStreamWriter):
    """
    Java class 'java.io.FileWriter'
    
        Extends:
            java.io.OutputStreamWriter
    
      Constructors:
        * FileWriter(java.io.FileDescriptor)
        * FileWriter(java.lang.String, java.nio.charset.Charset)
        * FileWriter(java.lang.String, java.nio.charset.Charset, boolean)
        * FileWriter(java.io.File, java.nio.charset.Charset)
        * FileWriter(java.io.File, java.nio.charset.Charset, boolean)
        * FileWriter(java.lang.String)
        * FileWriter(java.lang.String, boolean)
        * FileWriter(java.io.File)
        * FileWriter(java.io.File, boolean)
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, file: File, boolean: bool): ...
    @typing.overload
    def __init__(self, file: File, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, file: File, charset: java.nio.charset.Charset, boolean: bool): ...
    @typing.overload
    def __init__(self, fileDescriptor: FileDescriptor): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, boolean: bool): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset, boolean: bool): ...

class LineNumberInputStream(FilterInputStream):
    """
    Java class 'java.io.LineNumberInputStream'
    
        Extends:
            java.io.FilterInputStream
    
      Constructors:
        * LineNumberInputStream(java.io.InputStream)
    
    """
    def __init__(self, inputStream: InputStream): ...
    def available(self) -> int: ...
    def getLineNumber(self) -> int: ...
    def mark(self, int: int) -> None: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def setLineNumber(self, int: int) -> None: ...
    def skip(self, long: int) -> int: ...

class LineNumberReader(BufferedReader):
    """
    Java class 'java.io.LineNumberReader'
    
        Extends:
            java.io.BufferedReader
    
      Constructors:
        * LineNumberReader(java.io.Reader)
        * LineNumberReader(java.io.Reader, int)
    
    """
    @typing.overload
    def __init__(self, reader: Reader): ...
    @typing.overload
    def __init__(self, reader: Reader, int: int): ...
    def getLineNumber(self) -> int: ...
    def mark(self, int: int) -> None: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def reset(self) -> None: ...
    def setLineNumber(self, int: int) -> None: ...
    def skip(self, long: int) -> int: ...

class PrintStream(FilterOutputStream, java.lang.Appendable, Closeable):
    """
    Java class 'java.io.PrintStream'
    
        Extends:
            java.io.FilterOutputStream
    
        Interfaces:
            java.lang.Appendable, java.io.Closeable
    
      Constructors:
        * PrintStream(java.lang.String, java.lang.String)
        * PrintStream(java.lang.String)
        * PrintStream(java.io.OutputStream, boolean, java.nio.charset.Charset)
        * PrintStream(java.io.OutputStream, boolean, java.lang.String)
        * PrintStream(java.lang.String, java.nio.charset.Charset)
        * PrintStream(java.io.File, java.lang.String)
        * PrintStream(java.io.File, java.nio.charset.Charset)
        * PrintStream(java.io.File)
        * PrintStream(java.io.OutputStream)
        * PrintStream(java.io.OutputStream, boolean)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
        java.io.IOException: from java
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: File): ...
    @typing.overload
    def __init__(self, file: File, string: java.lang.String): ...
    @typing.overload
    def __init__(self, file: File, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, boolean: bool): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, boolean: bool, string: java.lang.String): ...
    @typing.overload
    def __init__(self, outputStream: OutputStream, boolean: bool, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset): ...
    @typing.overload
    def append(self, char: str) -> 'PrintStream': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'PrintStream': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'PrintStream': ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    def checkError(self) -> bool: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def format(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintStream': ...
    @typing.overload
    def format(self, locale: java.util.Locale, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintStream': ...
    @typing.overload
    def printf(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintStream': ...
    @typing.overload
    def printf(self, locale: java.util.Locale, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'PrintStream': ...
    @typing.overload
    def println(self) -> None: ...
    @typing.overload
    def println(self, boolean: bool) -> None: ...
    @typing.overload
    def println(self, char: str) -> None: ...
    @typing.overload
    def println(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def println(self, double: float) -> None: ...
    @typing.overload
    def println(self, float: float) -> None: ...
    @typing.overload
    def println(self, int: int) -> None: ...
    @typing.overload
    def println(self, object: typing.Any) -> None: ...
    @typing.overload
    def println(self, string: java.lang.String) -> None: ...
    @typing.overload
    def println(self, long: int) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def write(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class PushbackInputStream(FilterInputStream):
    """
    Java class 'java.io.PushbackInputStream'
    
        Extends:
            java.io.FilterInputStream
    
      Constructors:
        * PushbackInputStream(java.io.InputStream, int)
        * PushbackInputStream(java.io.InputStream)
    
    """
    @typing.overload
    def __init__(self, inputStream: InputStream): ...
    @typing.overload
    def __init__(self, inputStream: InputStream, int: int): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self, byteArray: typing.List[int]) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.List[int], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...
    @typing.overload
    def unread(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def unread(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    def unread(self, int: int) -> None: ...

class PushbackReader(FilterReader):
    """
    Java class 'java.io.PushbackReader'
    
        Extends:
            java.io.FilterReader
    
      Constructors:
        * PushbackReader(java.io.Reader, int)
        * PushbackReader(java.io.Reader)
    
    """
    @typing.overload
    def __init__(self, reader: Reader): ...
    @typing.overload
    def __init__(self, reader: Reader, int: int): ...
    def close(self) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @typing.overload
    def read(self, charArray: typing.List[str]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    def ready(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...
    @typing.overload
    def unread(self, charArray: typing.List[str]) -> None: ...
    @typing.overload
    def unread(self, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    def unread(self, int: int) -> None: ...

import java
import java.lang
import java.util.stream
import typing


class Buffer(java.lang.Object):
    """
    Java class 'java.nio.Buffer'
    
        Extends:
            java.lang.Object
    
    """
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def capacity(self) -> int: ...
    def clear(self) -> 'Buffer': ...
    def duplicate(self) -> 'Buffer': ...
    def flip(self) -> 'Buffer': ...
    def hasArray(self) -> bool: ...
    def hasRemaining(self) -> bool: ...
    def isDirect(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'Buffer': ...
    def mark(self) -> 'Buffer': ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'Buffer': ...
    def remaining(self) -> int: ...
    def reset(self) -> 'Buffer': ...
    def rewind(self) -> 'Buffer': ...
    def slice(self) -> 'Buffer': ...

class BufferOverflowException(java.lang.RuntimeException):
    """
    Java class 'java.nio.BufferOverflowException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * BufferOverflowException()
    
    """
    def __init__(self): ...

class BufferUnderflowException(java.lang.RuntimeException):
    """
    Java class 'java.nio.BufferUnderflowException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * BufferUnderflowException()
    
    """
    def __init__(self): ...

class ByteOrder(java.lang.Object):
    """
    Java class 'java.nio.ByteOrder'
    
        Extends:
            java.lang.Object
    
      Attributes:
        BIG_ENDIAN (java.nio.ByteOrder): final static field
        LITTLE_ENDIAN (java.nio.ByteOrder): final static field
    
    """
    BIG_ENDIAN: typing.ClassVar['ByteOrder'] = ...
    LITTLE_ENDIAN: typing.ClassVar['ByteOrder'] = ...
    @classmethod
    def nativeOrder(cls) -> 'ByteOrder': ...
    def toString(self) -> java.lang.String: ...

class InvalidMarkException(java.lang.IllegalStateException):
    """
    Java class 'java.nio.InvalidMarkException'
    
        Extends:
            java.lang.IllegalStateException
    
      Constructors:
        * InvalidMarkException()
    
    """
    def __init__(self): ...

class ReadOnlyBufferException(java.lang.UnsupportedOperationException):
    """
    Java class 'java.nio.ReadOnlyBufferException'
    
        Extends:
            java.lang.UnsupportedOperationException
    
      Constructors:
        * ReadOnlyBufferException()
    
    """
    def __init__(self): ...

class ByteBuffer(Buffer, java.lang.Comparable[java.nio.ByteBuffer]):
    """
    Java class 'java.nio.ByteBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    def alignedSlice(self, int: int) -> 'ByteBuffer': ...
    def alignmentOffset(self, int: int, int2: int) -> int: ...
    @classmethod
    def allocate(cls, int: int) -> 'ByteBuffer': ...
    @classmethod
    def allocateDirect(cls, int: int) -> 'ByteBuffer': ...
    @typing.overload
    def array(self) -> typing.List[int]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asCharBuffer(self) -> 'CharBuffer': ...
    def asDoubleBuffer(self) -> 'DoubleBuffer': ...
    def asFloatBuffer(self) -> 'FloatBuffer': ...
    def asIntBuffer(self) -> 'IntBuffer': ...
    def asLongBuffer(self) -> 'LongBuffer': ...
    def asReadOnlyBuffer(self) -> 'ByteBuffer': ...
    def asShortBuffer(self) -> 'ShortBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    @typing.overload
    def clear(self) -> 'ByteBuffer': ...
    def compact(self) -> 'ByteBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, byteBuffer: 'ByteBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'ByteBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def flip(self) -> 'ByteBuffer': ...
    @typing.overload
    def get(self) -> int: ...
    @typing.overload
    def get(self, int: int) -> int: ...
    @typing.overload
    def get(self, byteArray: typing.List[int]) -> 'ByteBuffer': ...
    @typing.overload
    def get(self, byteArray: typing.List[int], int: int, int2: int) -> 'ByteBuffer': ...
    @typing.overload
    def getChar(self) -> str: ...
    @typing.overload
    def getChar(self, int: int) -> str: ...
    @typing.overload
    def getDouble(self) -> float: ...
    @typing.overload
    def getDouble(self, int: int) -> float: ...
    @typing.overload
    def getFloat(self) -> float: ...
    @typing.overload
    def getFloat(self, int: int) -> float: ...
    @typing.overload
    def getInt(self) -> int: ...
    @typing.overload
    def getInt(self, int: int) -> int: ...
    @typing.overload
    def getLong(self) -> int: ...
    @typing.overload
    def getLong(self, int: int) -> int: ...
    @typing.overload
    def getShort(self) -> int: ...
    @typing.overload
    def getShort(self, int: int) -> int: ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def limit(self, int: int) -> 'ByteBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'ByteBuffer': ...
    def mismatch(self, byteBuffer: 'ByteBuffer') -> int: ...
    @typing.overload
    def order(self, byteOrder: ByteOrder) -> 'ByteBuffer': ...
    @typing.overload
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def position(self, int: int) -> 'ByteBuffer': ...
    @typing.overload
    def put(self, byte: int) -> 'ByteBuffer': ...
    @typing.overload
    def put(self, int: int, byte: int) -> 'ByteBuffer': ...
    @typing.overload
    def put(self, byteArray: typing.List[int]) -> 'ByteBuffer': ...
    @typing.overload
    def put(self, byteArray: typing.List[int], int: int, int2: int) -> 'ByteBuffer': ...
    @typing.overload
    def put(self, byteBuffer: 'ByteBuffer') -> 'ByteBuffer': ...
    @typing.overload
    def putChar(self, char: str) -> 'ByteBuffer': ...
    @typing.overload
    def putChar(self, int: int, char: str) -> 'ByteBuffer': ...
    @typing.overload
    def putDouble(self, double: float) -> 'ByteBuffer': ...
    @typing.overload
    def putDouble(self, int: int, double: float) -> 'ByteBuffer': ...
    @typing.overload
    def putFloat(self, float: float) -> 'ByteBuffer': ...
    @typing.overload
    def putFloat(self, int: int, float: float) -> 'ByteBuffer': ...
    @typing.overload
    def putInt(self, int: int) -> 'ByteBuffer': ...
    @typing.overload
    def putInt(self, int: int, int2: int) -> 'ByteBuffer': ...
    @typing.overload
    def putLong(self, int: int, long: int) -> 'ByteBuffer': ...
    @typing.overload
    def putLong(self, long: int) -> 'ByteBuffer': ...
    @typing.overload
    def putShort(self, int: int, short: int) -> 'ByteBuffer': ...
    @typing.overload
    def putShort(self, short: int) -> 'ByteBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def reset(self) -> 'ByteBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'ByteBuffer': ...
    @typing.overload
    def slice(self) -> 'ByteBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, byteArray: typing.List[int]) -> 'ByteBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, byteArray: typing.List[int], int: int, int2: int) -> 'ByteBuffer': ...

class CharBuffer(Buffer, java.lang.Comparable[java.nio.CharBuffer], java.lang.Appendable, java.lang.CharSequence, java.lang.Readable):
    """
    Java class 'java.nio.CharBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable, java.lang.Appendable,
            java.lang.CharSequence, java.lang.Readable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'CharBuffer': ...
    @typing.overload
    def append(self, char: str) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> java.lang.Appendable: ...
    @typing.overload
    def append(self, char: str) -> 'CharBuffer': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence) -> 'CharBuffer': ...
    @typing.overload
    def append(self, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'CharBuffer': ...
    @typing.overload
    def array(self) -> typing.List[str]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'CharBuffer': ...
    def charAt(self, int: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def clear(self) -> 'CharBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'CharBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, charBuffer: 'CharBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'CharBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'CharBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> str: ...
    @typing.overload
    def get(self, int: int) -> str: ...
    @typing.overload
    def get(self, charArray: typing.List[str]) -> 'CharBuffer': ...
    @typing.overload
    def get(self, charArray: typing.List[str], int: int, int2: int) -> 'CharBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    def length(self) -> int: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'CharBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'CharBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, charBuffer: 'CharBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'CharBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, char: str) -> 'CharBuffer': ...
    @typing.overload
    def put(self, int: int, char: str) -> 'CharBuffer': ...
    @typing.overload
    def put(self, charArray: typing.List[str]) -> 'CharBuffer': ...
    @typing.overload
    def put(self, string: java.lang.String) -> 'CharBuffer': ...
    @typing.overload
    def put(self, charArray: typing.List[str], int: int, int2: int) -> 'CharBuffer': ...
    @typing.overload
    def put(self, string: java.lang.String, int: int, int2: int) -> 'CharBuffer': ...
    @typing.overload
    def put(self, charBuffer: 'CharBuffer') -> 'CharBuffer': ...
    def read(self, charBuffer: 'CharBuffer') -> int: ...
    @typing.overload
    def reset(self) -> 'CharBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'CharBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'CharBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    @typing.overload
    def subSequence(self, int: int, int2: int) -> 'CharBuffer': ...
    @typing.overload
    def subSequence(self, int: int, int2: int) -> java.lang.CharSequence: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, charArray: typing.List[str]) -> 'CharBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, charArray: typing.List[str], int: int, int2: int) -> 'CharBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, charSequence: java.lang.CharSequence) -> 'CharBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, charSequence: java.lang.CharSequence, int: int, int2: int) -> 'CharBuffer': ...

class DoubleBuffer(Buffer, java.lang.Comparable[java.nio.DoubleBuffer]):
    """
    Java class 'java.nio.DoubleBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'DoubleBuffer': ...
    @typing.overload
    def array(self) -> typing.List[float]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'DoubleBuffer': ...
    @typing.overload
    def clear(self) -> 'DoubleBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'DoubleBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, doubleBuffer: 'DoubleBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'DoubleBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'DoubleBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> float: ...
    @typing.overload
    def get(self, int: int) -> float: ...
    @typing.overload
    def get(self, doubleArray: typing.List[float]) -> 'DoubleBuffer': ...
    @typing.overload
    def get(self, doubleArray: typing.List[float], int: int, int2: int) -> 'DoubleBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'DoubleBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'DoubleBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, doubleBuffer: 'DoubleBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'DoubleBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, double: float) -> 'DoubleBuffer': ...
    @typing.overload
    def put(self, int: int, double: float) -> 'DoubleBuffer': ...
    @typing.overload
    def put(self, doubleArray: typing.List[float]) -> 'DoubleBuffer': ...
    @typing.overload
    def put(self, doubleArray: typing.List[float], int: int, int2: int) -> 'DoubleBuffer': ...
    @typing.overload
    def put(self, doubleBuffer: 'DoubleBuffer') -> 'DoubleBuffer': ...
    @typing.overload
    def reset(self) -> 'DoubleBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'DoubleBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'DoubleBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, doubleArray: typing.List[float]) -> 'DoubleBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, doubleArray: typing.List[float], int: int, int2: int) -> 'DoubleBuffer': ...

class FloatBuffer(Buffer, java.lang.Comparable[java.nio.FloatBuffer]):
    """
    Java class 'java.nio.FloatBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'FloatBuffer': ...
    @typing.overload
    def array(self) -> typing.List[float]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'FloatBuffer': ...
    @typing.overload
    def clear(self) -> 'FloatBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'FloatBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, floatBuffer: 'FloatBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'FloatBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'FloatBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> float: ...
    @typing.overload
    def get(self, int: int) -> float: ...
    @typing.overload
    def get(self, floatArray: typing.List[float]) -> 'FloatBuffer': ...
    @typing.overload
    def get(self, floatArray: typing.List[float], int: int, int2: int) -> 'FloatBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'FloatBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'FloatBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, floatBuffer: 'FloatBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'FloatBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, float: float) -> 'FloatBuffer': ...
    @typing.overload
    def put(self, int: int, float: float) -> 'FloatBuffer': ...
    @typing.overload
    def put(self, floatArray: typing.List[float]) -> 'FloatBuffer': ...
    @typing.overload
    def put(self, floatArray: typing.List[float], int: int, int2: int) -> 'FloatBuffer': ...
    @typing.overload
    def put(self, floatBuffer: 'FloatBuffer') -> 'FloatBuffer': ...
    @typing.overload
    def reset(self) -> 'FloatBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'FloatBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'FloatBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, floatArray: typing.List[float]) -> 'FloatBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, floatArray: typing.List[float], int: int, int2: int) -> 'FloatBuffer': ...

class IntBuffer(Buffer, java.lang.Comparable[java.nio.IntBuffer]):
    """
    Java class 'java.nio.IntBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'IntBuffer': ...
    @typing.overload
    def array(self) -> typing.List[int]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'IntBuffer': ...
    @typing.overload
    def clear(self) -> 'IntBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'IntBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, intBuffer: 'IntBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'IntBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'IntBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> int: ...
    @typing.overload
    def get(self, int: int) -> int: ...
    @typing.overload
    def get(self, intArray: typing.List[int]) -> 'IntBuffer': ...
    @typing.overload
    def get(self, intArray: typing.List[int], int2: int, int3: int) -> 'IntBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'IntBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'IntBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, intBuffer: 'IntBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'IntBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, int: int) -> 'IntBuffer': ...
    @typing.overload
    def put(self, int: int, int2: int) -> 'IntBuffer': ...
    @typing.overload
    def put(self, intArray: typing.List[int]) -> 'IntBuffer': ...
    @typing.overload
    def put(self, intArray: typing.List[int], int2: int, int3: int) -> 'IntBuffer': ...
    @typing.overload
    def put(self, intBuffer: 'IntBuffer') -> 'IntBuffer': ...
    @typing.overload
    def reset(self) -> 'IntBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'IntBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'IntBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, intArray: typing.List[int]) -> 'IntBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, intArray: typing.List[int], int2: int, int3: int) -> 'IntBuffer': ...

class LongBuffer(Buffer, java.lang.Comparable[java.nio.LongBuffer]):
    """
    Java class 'java.nio.LongBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'LongBuffer': ...
    @typing.overload
    def array(self) -> typing.List[int]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'LongBuffer': ...
    @typing.overload
    def clear(self) -> 'LongBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'LongBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, longBuffer: 'LongBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'LongBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'LongBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> int: ...
    @typing.overload
    def get(self, int: int) -> int: ...
    @typing.overload
    def get(self, longArray: typing.List[int]) -> 'LongBuffer': ...
    @typing.overload
    def get(self, longArray: typing.List[int], int: int, int2: int) -> 'LongBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'LongBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'LongBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, longBuffer: 'LongBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'LongBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, int: int, long: int) -> 'LongBuffer': ...
    @typing.overload
    def put(self, long: int) -> 'LongBuffer': ...
    @typing.overload
    def put(self, longArray: typing.List[int]) -> 'LongBuffer': ...
    @typing.overload
    def put(self, longBuffer: 'LongBuffer') -> 'LongBuffer': ...
    @typing.overload
    def put(self, longArray: typing.List[int], int: int, int2: int) -> 'LongBuffer': ...
    @typing.overload
    def reset(self) -> 'LongBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'LongBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'LongBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, longArray: typing.List[int]) -> 'LongBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, longArray: typing.List[int], int: int, int2: int) -> 'LongBuffer': ...

class ShortBuffer(Buffer, java.lang.Comparable[java.nio.ShortBuffer]):
    """
    Java class 'java.nio.ShortBuffer'
    
        Extends:
            java.nio.Buffer
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allocate(cls, int: int) -> 'ShortBuffer': ...
    @typing.overload
    def array(self) -> typing.List[int]: ...
    @typing.overload
    def array(self) -> typing.Any: ...
    def arrayOffset(self) -> int: ...
    def asReadOnlyBuffer(self) -> 'ShortBuffer': ...
    @typing.overload
    def clear(self) -> 'ShortBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    def compact(self) -> 'ShortBuffer': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, shortBuffer: 'ShortBuffer') -> int: ...
    @typing.overload
    def duplicate(self) -> 'ShortBuffer': ...
    @typing.overload
    def duplicate(self) -> Buffer: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self) -> 'ShortBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def get(self) -> int: ...
    @typing.overload
    def get(self, int: int) -> int: ...
    @typing.overload
    def get(self, shortArray: typing.List[int]) -> 'ShortBuffer': ...
    @typing.overload
    def get(self, shortArray: typing.List[int], int: int, int2: int) -> 'ShortBuffer': ...
    def hasArray(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isDirect(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'ShortBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def mark(self) -> 'ShortBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    def mismatch(self, shortBuffer: 'ShortBuffer') -> int: ...
    def order(self) -> ByteOrder: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'ShortBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def put(self, int: int, short: int) -> 'ShortBuffer': ...
    @typing.overload
    def put(self, short: int) -> 'ShortBuffer': ...
    @typing.overload
    def put(self, shortArray: typing.List[int]) -> 'ShortBuffer': ...
    @typing.overload
    def put(self, shortBuffer: 'ShortBuffer') -> 'ShortBuffer': ...
    @typing.overload
    def put(self, shortArray: typing.List[int], int: int, int2: int) -> 'ShortBuffer': ...
    @typing.overload
    def reset(self) -> 'ShortBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> 'ShortBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def slice(self) -> 'ShortBuffer': ...
    @typing.overload
    def slice(self) -> Buffer: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def wrap(cls, shortArray: typing.List[int]) -> 'ShortBuffer': ...
    @classmethod
    @typing.overload
    def wrap(cls, shortArray: typing.List[int], int: int, int2: int) -> 'ShortBuffer': ...

class MappedByteBuffer(ByteBuffer):
    """
    Java class 'java.nio.MappedByteBuffer'
    
        Extends:
            java.nio.ByteBuffer
    
    """
    @typing.overload
    def clear(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def clear(self) -> Buffer: ...
    @typing.overload
    def clear(self) -> ByteBuffer: ...
    @typing.overload
    def flip(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def flip(self) -> Buffer: ...
    @typing.overload
    def flip(self) -> ByteBuffer: ...
    def force(self) -> 'MappedByteBuffer': ...
    def isLoaded(self) -> bool: ...
    @typing.overload
    def limit(self) -> int: ...
    @typing.overload
    def limit(self, int: int) -> 'MappedByteBuffer': ...
    @typing.overload
    def limit(self, int: int) -> Buffer: ...
    @typing.overload
    def limit(self, int: int) -> ByteBuffer: ...
    def load(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def mark(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def mark(self) -> Buffer: ...
    @typing.overload
    def mark(self) -> ByteBuffer: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, int: int) -> 'MappedByteBuffer': ...
    @typing.overload
    def position(self, int: int) -> Buffer: ...
    @typing.overload
    def position(self, int: int) -> ByteBuffer: ...
    @typing.overload
    def reset(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def reset(self) -> Buffer: ...
    @typing.overload
    def reset(self) -> ByteBuffer: ...
    @typing.overload
    def rewind(self) -> 'MappedByteBuffer': ...
    @typing.overload
    def rewind(self) -> Buffer: ...
    @typing.overload
    def rewind(self) -> ByteBuffer: ...

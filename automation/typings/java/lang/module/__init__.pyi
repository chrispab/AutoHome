import java
import java.io
import java.lang
import java.net
import java.nio
import java.nio.file
import java.util
import java.util.function
import java.util.stream
import typing


class Configuration(java.lang.Object):
    """
    Java class 'java.lang.module.Configuration'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def empty(cls) -> 'Configuration': ...
    def findModule(self, string: java.lang.String) -> java.util.Optional['ResolvedModule']: ...
    def modules(self) -> java.util.Set['ResolvedModule']: ...
    def parents(self) -> java.util.List['Configuration']: ...
    @typing.overload
    def resolve(self, moduleFinder: 'ModuleFinder', moduleFinder2: 'ModuleFinder', collection: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'Configuration': ...
    @classmethod
    @typing.overload
    def resolve(cls, moduleFinder: 'ModuleFinder', list: java.util.List['Configuration'], moduleFinder2: 'ModuleFinder', collection: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'Configuration': ...
    @typing.overload
    def resolveAndBind(self, moduleFinder: 'ModuleFinder', moduleFinder2: 'ModuleFinder', collection: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'Configuration': ...
    @classmethod
    @typing.overload
    def resolveAndBind(cls, moduleFinder: 'ModuleFinder', list: java.util.List['Configuration'], moduleFinder2: 'ModuleFinder', collection: typing.Union[java.util.Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'Configuration': ...
    def toString(self) -> java.lang.String: ...

class FindException(java.lang.RuntimeException):
    """
    Java class 'java.lang.module.FindException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * FindException(java.lang.String, java.lang.Throwable)
        * FindException(java.lang.Throwable)
        * FindException(java.lang.String)
        * FindException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class InvalidModuleDescriptorException(java.lang.RuntimeException):
    """
    Java class 'java.lang.module.InvalidModuleDescriptorException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * InvalidModuleDescriptorException()
        * InvalidModuleDescriptorException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ModuleDescriptor(java.lang.Comparable[java.lang.module.ModuleDescriptor]):
    """
    Java class 'java.lang.module.ModuleDescriptor'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Comparable
    
    """
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, moduleDescriptor: 'ModuleDescriptor') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exports(self) -> java.util.Set['ModuleDescriptor.Exports']: ...
    def hashCode(self) -> int: ...
    def isAutomatic(self) -> bool: ...
    def isOpen(self) -> bool: ...
    def mainClass(self) -> java.util.Optional[java.lang.String]: ...
    def modifiers(self) -> java.util.Set['ModuleDescriptor.Modifier']: ...
    def name(self) -> java.lang.String: ...
    @classmethod
    def newAutomaticModule(cls, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
    @classmethod
    @typing.overload
    def newModule(cls, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
    @classmethod
    @typing.overload
    def newModule(cls, string: java.lang.String, set: java.util.Set['ModuleDescriptor.Modifier']) -> 'ModuleDescriptor.Builder': ...
    @classmethod
    def newOpenModule(cls, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
    def opens(self) -> java.util.Set['ModuleDescriptor.Opens']: ...
    def packages(self) -> java.util.Set[java.lang.String]: ...
    def provides(self) -> java.util.Set['ModuleDescriptor.Provides']: ...
    def rawVersion(self) -> java.util.Optional[java.lang.String]: ...
    @classmethod
    @typing.overload
    def read(cls, inputStream: java.io.InputStream) -> 'ModuleDescriptor': ...
    @classmethod
    @typing.overload
    def read(cls, inputStream: java.io.InputStream, supplier: typing.Union[java.util.function.Supplier[java.util.Set[java.lang.String]], typing.Callable[[], java.util.Set[java.lang.String]]]) -> 'ModuleDescriptor': ...
    @classmethod
    @typing.overload
    def read(cls, byteBuffer: java.nio.ByteBuffer) -> 'ModuleDescriptor': ...
    @classmethod
    @typing.overload
    def read(cls, byteBuffer: java.nio.ByteBuffer, supplier: typing.Union[java.util.function.Supplier[java.util.Set[java.lang.String]], typing.Callable[[], java.util.Set[java.lang.String]]]) -> 'ModuleDescriptor': ...
    def requires(self) -> java.util.Set['ModuleDescriptor.Requires']: ...
    def toNameAndVersion(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def uses(self) -> java.util.Set[java.lang.String]: ...
    def version(self) -> java.util.Optional['ModuleDescriptor.Version']: ...
    class Builder(java.lang.Object):
        """
        Java class 'java.lang.module.ModuleDescriptor$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def build(self) -> 'ModuleDescriptor': ...
        @typing.overload
        def exports(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def exports(self, string: java.lang.String, set: java.util.Set[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def exports(self, exports: 'ModuleDescriptor.Exports') -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def exports(self, set: java.util.Set['ModuleDescriptor.Exports.Modifier'], string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def exports(self, set: java.util.Set['ModuleDescriptor.Exports.Modifier'], string: java.lang.String, set2: java.util.Set[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        def mainClass(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def opens(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def opens(self, string: java.lang.String, set: java.util.Set[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def opens(self, opens: 'ModuleDescriptor.Opens') -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def opens(self, set: java.util.Set['ModuleDescriptor.Opens.Modifier'], string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def opens(self, set: java.util.Set['ModuleDescriptor.Opens.Modifier'], string: java.lang.String, set2: java.util.Set[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        def packages(self, set: java.util.Set[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def provides(self, string: java.lang.String, list: java.util.List[java.lang.String]) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def provides(self, provides: 'ModuleDescriptor.Provides') -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def requires(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def requires(self, requires: 'ModuleDescriptor.Requires') -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def requires(self, set: java.util.Set['ModuleDescriptor.Requires.Modifier'], string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def requires(self, set: java.util.Set['ModuleDescriptor.Requires.Modifier'], string: java.lang.String, version: 'ModuleDescriptor.Version') -> 'ModuleDescriptor.Builder': ...
        def uses(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def version(self, string: java.lang.String) -> 'ModuleDescriptor.Builder': ...
        @typing.overload
        def version(self, version: 'ModuleDescriptor.Version') -> 'ModuleDescriptor.Builder': ...
    class Exports(java.lang.Comparable[java.lang.module.ModuleDescriptor.Exports]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Exports'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, exports: 'ModuleDescriptor.Exports') -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isQualified(self) -> bool: ...
        def modifiers(self) -> java.util.Set['ModuleDescriptor.Exports.Modifier']: ...
        def source(self) -> java.lang.String: ...
        def targets(self) -> java.util.Set[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum[java.lang.module.ModuleDescriptor.Exports.Modifier]):
            """
            Java class 'java.lang.module.ModuleDescriptor$Exports$Modifier'
            
                Extends:
                    java.lang.Enum
            
              Attributes:
                SYNTHETIC (java.lang.module.ModuleDescriptor$Exports$Modifier): final static enum constant
                MANDATED (java.lang.module.ModuleDescriptor$Exports$Modifier): final static enum constant
            
            """
            SYNTHETIC: typing.ClassVar['ModuleDescriptor.Exports.Modifier'] = ...
            MANDATED: typing.ClassVar['ModuleDescriptor.Exports.Modifier'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @classmethod
            @typing.overload
            def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
            @classmethod
            @typing.overload
            def valueOf(cls, string: java.lang.String) -> 'ModuleDescriptor.Exports.Modifier': ...
            @classmethod
            def values(cls) -> typing.List['ModuleDescriptor.Exports.Modifier']: ...
    class Modifier(java.lang.Enum[java.lang.module.ModuleDescriptor.Modifier]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Modifier'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            OPEN (java.lang.module.ModuleDescriptor$Modifier): final static enum constant
            AUTOMATIC (java.lang.module.ModuleDescriptor$Modifier): final static enum constant
            SYNTHETIC (java.lang.module.ModuleDescriptor$Modifier): final static enum constant
            MANDATED (java.lang.module.ModuleDescriptor$Modifier): final static enum constant
        
        """
        OPEN: typing.ClassVar['ModuleDescriptor.Modifier'] = ...
        AUTOMATIC: typing.ClassVar['ModuleDescriptor.Modifier'] = ...
        SYNTHETIC: typing.ClassVar['ModuleDescriptor.Modifier'] = ...
        MANDATED: typing.ClassVar['ModuleDescriptor.Modifier'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'ModuleDescriptor.Modifier': ...
        @classmethod
        def values(cls) -> typing.List['ModuleDescriptor.Modifier']: ...
    class Opens(java.lang.Comparable[java.lang.module.ModuleDescriptor.Opens]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Opens'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, opens: 'ModuleDescriptor.Opens') -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isQualified(self) -> bool: ...
        def modifiers(self) -> java.util.Set['ModuleDescriptor.Opens.Modifier']: ...
        def source(self) -> java.lang.String: ...
        def targets(self) -> java.util.Set[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum[java.lang.module.ModuleDescriptor.Opens.Modifier]):
            """
            Java class 'java.lang.module.ModuleDescriptor$Opens$Modifier'
            
                Extends:
                    java.lang.Enum
            
              Attributes:
                SYNTHETIC (java.lang.module.ModuleDescriptor$Opens$Modifier): final static enum constant
                MANDATED (java.lang.module.ModuleDescriptor$Opens$Modifier): final static enum constant
            
            """
            SYNTHETIC: typing.ClassVar['ModuleDescriptor.Opens.Modifier'] = ...
            MANDATED: typing.ClassVar['ModuleDescriptor.Opens.Modifier'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @classmethod
            @typing.overload
            def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
            @classmethod
            @typing.overload
            def valueOf(cls, string: java.lang.String) -> 'ModuleDescriptor.Opens.Modifier': ...
            @classmethod
            def values(cls) -> typing.List['ModuleDescriptor.Opens.Modifier']: ...
    class Provides(java.lang.Comparable[java.lang.module.ModuleDescriptor.Provides]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Provides'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, provides: 'ModuleDescriptor.Provides') -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def providers(self) -> java.util.List[java.lang.String]: ...
        def service(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class Requires(java.lang.Comparable[java.lang.module.ModuleDescriptor.Requires]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Requires'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, requires: 'ModuleDescriptor.Requires') -> int: ...
        def compiledVersion(self) -> java.util.Optional['ModuleDescriptor.Version']: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def modifiers(self) -> java.util.Set['ModuleDescriptor.Requires.Modifier']: ...
        def name(self) -> java.lang.String: ...
        def rawCompiledVersion(self) -> java.util.Optional[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum[java.lang.module.ModuleDescriptor.Requires.Modifier]):
            """
            Java class 'java.lang.module.ModuleDescriptor$Requires$Modifier'
            
                Extends:
                    java.lang.Enum
            
              Attributes:
                TRANSITIVE (java.lang.module.ModuleDescriptor$Requires$Modifier): final static enum constant
                STATIC (java.lang.module.ModuleDescriptor$Requires$Modifier): final static enum constant
                SYNTHETIC (java.lang.module.ModuleDescriptor$Requires$Modifier): final static enum constant
                MANDATED (java.lang.module.ModuleDescriptor$Requires$Modifier): final static enum constant
            
            """
            TRANSITIVE: typing.ClassVar['ModuleDescriptor.Requires.Modifier'] = ...
            STATIC: typing.ClassVar['ModuleDescriptor.Requires.Modifier'] = ...
            SYNTHETIC: typing.ClassVar['ModuleDescriptor.Requires.Modifier'] = ...
            MANDATED: typing.ClassVar['ModuleDescriptor.Requires.Modifier'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @classmethod
            @typing.overload
            def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
            @classmethod
            @typing.overload
            def valueOf(cls, string: java.lang.String) -> 'ModuleDescriptor.Requires.Modifier': ...
            @classmethod
            def values(cls) -> typing.List['ModuleDescriptor.Requires.Modifier']: ...
    class Version(java.lang.Comparable[java.lang.module.ModuleDescriptor.Version]):
        """
        Java class 'java.lang.module.ModuleDescriptor$Version'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, version: 'ModuleDescriptor.Version') -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        @classmethod
        def parse(cls, string: java.lang.String) -> 'ModuleDescriptor.Version': ...
        def toString(self) -> java.lang.String: ...

class ModuleFinder(java.lang.Object):
    """
    public interface ModuleFinder
    
        A finder of modules. A :code:`ModuleFinder` is used to find modules during :meth:`~java.lang.module.package` or
        :meth:`~java.lang.module.Configuration.service`.
    
        A :code:`ModuleFinder` can only find one module with a given name. A :code:`ModuleFinder` that finds modules in a
        sequence of directories, for example, will locate the first occurrence of a module of a given name and will ignore other
        modules of that name that appear in directories later in the sequence.
    
        Example usage:
    
        .. code-block: java
        
             Path dir1, dir2, dir3;
        
             ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
        
             Optional<ModuleReference> omref = finder.find("jdk.foo");
             omref.ifPresent(mref -> ... );
        
         
    
        The :meth:`~java.lang.module.ModuleFinder.find` and :meth:`~java.lang.module.ModuleFinder.findAll` methods defined here
        can fail for several reasons. These include I/O errors, errors detected parsing a module descriptor
        (:code:`module-info.class`), or in the case of :code:`ModuleFinder` returned by
        :meth:`~java.lang.module.ModuleFinder.of`, that two or more modules with the same name are found in a directory. When an
        error is detected then these methods throw :class:`~java.lang.module.FindException` with an appropriate
        :meth:`~java.lang.Throwable.getCause`. The behavior of a :code:`ModuleFinder` after a :code:`FindException` is thrown is
        undefined. For example, invoking :code:`find` after an exception is thrown may or may not scan the same modules that
        lead to the exception. It is recommended that a module finder be discarded after an exception is thrown.
    
        A :code:`ModuleFinder` is not required to be thread safe.
    
        Since:
            9
    
    
    """
    @classmethod
    def compose(cls, moduleFinderArray: typing.List['ModuleFinder']) -> 'ModuleFinder': ...
    def find(self, string: java.lang.String) -> java.util.Optional['ModuleReference']: ...
    def findAll(self) -> java.util.Set['ModuleReference']: ...
    @classmethod
    def of(cls, pathArray: typing.List[java.nio.file.Path]) -> 'ModuleFinder': ...
    @classmethod
    def ofSystem(cls) -> 'ModuleFinder': ...

class ModuleReader(java.io.Closeable):
    """
    Java class 'java.lang.module.ModuleReader'
    
        Interfaces:
            java.io.Closeable
    
    """
    def close(self) -> None: ...
    def find(self, string: java.lang.String) -> java.util.Optional[java.net.URI]: ...
    def list(self) -> java.util.stream.Stream[java.lang.String]: ...
    def open(self, string: java.lang.String) -> java.util.Optional[java.io.InputStream]: ...
    def read(self, string: java.lang.String) -> java.util.Optional[java.nio.ByteBuffer]: ...
    def release(self, byteBuffer: java.nio.ByteBuffer) -> None: ...

class ModuleReference(java.lang.Object):
    """
    Java class 'java.lang.module.ModuleReference'
    
        Extends:
            java.lang.Object
    
    """
    def descriptor(self) -> ModuleDescriptor: ...
    def location(self) -> java.util.Optional[java.net.URI]: ...
    def open(self) -> ModuleReader: ...

class ResolutionException(java.lang.RuntimeException):
    """
    Java class 'java.lang.module.ResolutionException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ResolutionException(java.lang.String, java.lang.Throwable)
        * ResolutionException(java.lang.Throwable)
        * ResolutionException(java.lang.String)
        * ResolutionException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ResolvedModule(java.lang.Object):
    """
    Java class 'java.lang.module.ResolvedModule'
    
        Extends:
            java.lang.Object
    
    """
    def configuration(self) -> Configuration: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def name(self) -> java.lang.String: ...
    def reads(self) -> java.util.Set['ResolvedModule']: ...
    def reference(self) -> ModuleReference: ...
    def toString(self) -> java.lang.String: ...

import java
import java.io
import java.lang.annotation
import java.lang.invoke
import java.lang.module
import java.lang.reflect
import java.net
import java.nio
import java.nio.channels
import java.nio.charset
import java.security
import java.time
import java.util
import java.util.concurrent
import java.util.function
import java.util.stream
import typing


_Class__T = typing.TypeVar('_Class__T')  # <T>
class Class(java.io.Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, typing.Generic[_Class__T]):
    """
    Java class 'java.lang.Class'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.reflect.GenericDeclaration,
            java.lang.reflect.Type, java.lang.reflect.AnnotatedElement
    
    """
    _asSubclass__U = typing.TypeVar('_asSubclass__U')  # <U>
    def asSubclass(self, class_: typing.Type[_asSubclass__U]) -> typing.Type[_asSubclass__U]: ...
    def cast(self, object: typing.Any) -> _Class__T: ...
    def desiredAssertionStatus(self) -> bool: ...
    @classmethod
    @typing.overload
    def forName(cls, module: 'Module', string: 'String') -> typing.Type[typing.Any]: ...
    @classmethod
    @typing.overload
    def forName(cls, string: 'String') -> typing.Type[typing.Any]: ...
    @classmethod
    @typing.overload
    def forName(cls, string: 'String', boolean: bool, classLoader: 'ClassLoader') -> typing.Type[typing.Any]: ...
    def getAnnotatedInterfaces(self) -> typing.List[java.lang.reflect.AnnotatedType]: ...
    def getAnnotatedSuperclass(self) -> java.lang.reflect.AnnotatedType: ...
    _getAnnotation__A = typing.TypeVar('_getAnnotation__A', bound=java.lang.annotation.Annotation)  # <A>
    def getAnnotation(self, class_: typing.Type[_getAnnotation__A]) -> _getAnnotation__A: ...
    def getAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__A = typing.TypeVar('_getAnnotationsByType__A', bound=java.lang.annotation.Annotation)  # <A>
    def getAnnotationsByType(self, class_: typing.Type[_getAnnotationsByType__A]) -> typing.List[_getAnnotationsByType__A]: ...
    def getCanonicalName(self) -> 'String': ...
    def getClassLoader(self) -> 'ClassLoader': ...
    def getClasses(self) -> typing.List[typing.Type[typing.Any]]: ...
    def getComponentType(self) -> typing.Type[typing.Any]: ...
    def getConstructor(self, classArray: typing.List[typing.Type[typing.Any]]) -> java.lang.reflect.Constructor[_Class__T]: ...
    def getConstructors(self) -> typing.List[java.lang.reflect.Constructor[typing.Any]]: ...
    _getDeclaredAnnotation__A = typing.TypeVar('_getDeclaredAnnotation__A', bound=java.lang.annotation.Annotation)  # <A>
    def getDeclaredAnnotation(self, class_: typing.Type[_getDeclaredAnnotation__A]) -> _getDeclaredAnnotation__A: ...
    def getDeclaredAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__A = typing.TypeVar('_getDeclaredAnnotationsByType__A', bound=java.lang.annotation.Annotation)  # <A>
    def getDeclaredAnnotationsByType(self, class_: typing.Type[_getDeclaredAnnotationsByType__A]) -> typing.List[_getDeclaredAnnotationsByType__A]: ...
    def getDeclaredClasses(self) -> typing.List[typing.Type[typing.Any]]: ...
    def getDeclaredConstructor(self, classArray: typing.List[typing.Type[typing.Any]]) -> java.lang.reflect.Constructor[_Class__T]: ...
    def getDeclaredConstructors(self) -> typing.List[java.lang.reflect.Constructor[typing.Any]]: ...
    def getDeclaredField(self, string: 'String') -> java.lang.reflect.Field: ...
    def getDeclaredFields(self) -> typing.List[java.lang.reflect.Field]: ...
    def getDeclaredMethod(self, string: 'String', classArray: typing.List[typing.Type[typing.Any]]) -> java.lang.reflect.Method: ...
    def getDeclaredMethods(self) -> typing.List[java.lang.reflect.Method]: ...
    def getDeclaringClass(self) -> typing.Type[typing.Any]: ...
    def getEnclosingClass(self) -> typing.Type[typing.Any]: ...
    def getEnclosingConstructor(self) -> java.lang.reflect.Constructor[typing.Any]: ...
    def getEnclosingMethod(self) -> java.lang.reflect.Method: ...
    def getEnumConstants(self) -> typing.List[_Class__T]: ...
    def getField(self, string: 'String') -> java.lang.reflect.Field: ...
    def getFields(self) -> typing.List[java.lang.reflect.Field]: ...
    def getGenericInterfaces(self) -> typing.List[java.lang.reflect.Type]: ...
    def getGenericSuperclass(self) -> java.lang.reflect.Type: ...
    def getInterfaces(self) -> typing.List[typing.Type[typing.Any]]: ...
    def getMethod(self, string: 'String', classArray: typing.List[typing.Type[typing.Any]]) -> java.lang.reflect.Method: ...
    def getMethods(self) -> typing.List[java.lang.reflect.Method]: ...
    def getModifiers(self) -> int: ...
    def getModule(self) -> 'Module': ...
    def getName(self) -> 'String': ...
    def getNestHost(self) -> typing.Type[typing.Any]: ...
    def getNestMembers(self) -> typing.List[typing.Type[typing.Any]]: ...
    def getPackage(self) -> 'Package': ...
    def getPackageName(self) -> 'String': ...
    def getProtectionDomain(self) -> java.security.ProtectionDomain: ...
    def getResource(self, string: 'String') -> java.net.URL: ...
    def getResourceAsStream(self, string: 'String') -> java.io.InputStream: ...
    def getSigners(self) -> typing.List[typing.Any]: ...
    def getSimpleName(self) -> 'String': ...
    def getSuperclass(self) -> typing.Type[_Class__T]: ...
    def getTypeName(self) -> 'String': ...
    def getTypeParameters(self) -> typing.List[java.lang.reflect.TypeVariable[typing.Type[_Class__T]]]: ...
    def isAnnotation(self) -> bool: ...
    def isAnnotationPresent(self, class_: typing.Type[java.lang.annotation.Annotation]) -> bool: ...
    def isAnonymousClass(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isAssignableFrom(self, class_: typing.Type[typing.Any]) -> bool: ...
    def isEnum(self) -> bool: ...
    def isInstance(self, object: typing.Any) -> bool: ...
    def isInterface(self) -> bool: ...
    def isLocalClass(self) -> bool: ...
    def isMemberClass(self) -> bool: ...
    def isNestmateOf(self, class_: typing.Type[typing.Any]) -> bool: ...
    def isPrimitive(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def newInstance(self) -> _Class__T: ...
    def toGenericString(self) -> 'String': ...
    def toString(self) -> 'String': ...

class Deprecated(java.lang.annotation.Annotation):
    """
    :class:`~java.lang.annotation.Documented` :class:`~java.lang.annotation.Retention`(:meth:`~java.lang.annotation.RetentionPolicy.RUNTIME`) :class:`~java.lang.annotation.Target`({:meth:`~java.lang.annotation.ElementType.CONSTRUCTOR`,:meth:`~java.lang.annotation.ElementType.FIELD`,:meth:`~java.lang.annotation.ElementType.LOCAL_VARIABLE`,:meth:`~java.lang.annotation.ElementType.METHOD`,:meth:`~java.lang.annotation.ElementType.PACKAGE`,:meth:`~java.lang.annotation.ElementType.MODULE`,:meth:`~java.lang.annotation.ElementType.PARAMETER`,:meth:`~java.lang.annotation.ElementType.TYPE`}) public @interface Deprecated
    
        A program element annotated :code:`@Deprecated` is one that programmers are discouraged from using. An element may be
        deprecated for any of several reasons, for example, its usage is likely to lead to errors; it may be changed
        incompatibly or removed in a future version; it has been superseded by a newer, usually preferable alternative; or it is
        obsolete.
    
        Compilers issue warnings when a deprecated program element is used or overridden in non-deprecated code. Use of the
        :code:`@Deprecated` annotation on a local variable declaration or on a parameter declaration or a package declaration
        has no effect on the warnings issued by a compiler.
    
        When a module is deprecated, the use of that module in :code:`requires`, but not in :code:`exports` or :code:`opens`
        clauses causes a warning to be issued. A module being deprecated does *not* cause warnings to be issued for uses of
        types within the module.
    
        This annotation type has a string-valued element :code:`since`. The value of this element indicates the version in which
        the annotated program element was first deprecated.
    
        This annotation type has a boolean-valued element :code:`forRemoval`. A value of :code:`true` indicates intent to remove
        the annotated program element in a future version. A value of :code:`false` indicates that use of the annotated program
        element is discouraged, but at the time the program element was annotated, there was no specific intent to remove it.
    
        API Note:
            It is strongly recommended that the reason for deprecating a program element be explained in the documentation, using
            the :code:`@deprecated` javadoc tag. The documentation should also suggest and link to a recommended replacement API, if
            applicable. A replacement API often has subtly different semantics, so such issues should be discussed as well.
    
            It is recommended that a :code:`since` value be provided with all newly annotated program elements. Note that
            :code:`since` cannot be mandatory, as there are many existing annotations that lack this element value.
    
            There is no defined order among annotation elements. As a matter of style, the :code:`since` element should be placed
            first.
    
            The :code:`@Deprecated` annotation should always be present if the :code:`@deprecated` javadoc tag is present, and
            vice-versa.
    
        Since:
            1.5
    
        See Javaâ„¢ specification:
            9.6.4.6 @Deprecated
    
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def forRemoval(self) -> bool: ...
    def hashCode(self) -> int: ...
    def since(self) -> 'String': ...
    def toString(self) -> 'String': ...

class FunctionalInterface(java.lang.annotation.Annotation):
    """
    :class:`~java.lang.annotation.Documented` :class:`~java.lang.annotation.Retention`(:meth:`~java.lang.annotation.RetentionPolicy.RUNTIME`) :class:`~java.lang.annotation.Target`(:meth:`~java.lang.annotation.ElementType.TYPE`) public @interface FunctionalInterface
    
        An informative annotation type used to indicate that an interface type declaration is intended to be a *functional
        interface* as defined by the Java Language Specification. Conceptually, a functional interface has exactly one abstract
        method. Since :meth:`~java.lang.reflect.Method.isDefault` have an implementation, they are not abstract. If an interface
        declares an abstract method overriding one of the public methods of :code:`java.lang.Object`, that also does *not* count
        toward the interface's abstract method count since any implementation of the interface will have an implementation from
        :code:`java.lang.Object` or elsewhere.
    
        Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor
        references.
    
        If a type is annotated with this annotation type, compilers are required to generate an error message unless:
    
          - The type is an interface type and not an annotation type, enum, or class.
          - The annotated type satisfies the requirements of a functional interface.
    
    
        However, the compiler will treat any interface meeting the definition of a functional interface as a functional
        interface regardless of whether or not a :code:`FunctionalInterface` annotation is present on the interface declaration.
    
        Since:
            1.8
    
        See Javaâ„¢ specification:
            4.3.2. The Class Object, 9.8 Functional Interfaces, 9.4.3 Interface Method Body, 9.6.4.9 @FunctionalInterface
    
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> 'String': ...

class Module(java.lang.reflect.AnnotatedElement):
    """
    public final class Module extends :class:`~java.lang.Object` implements :class:`~java.lang.reflect.AnnotatedElement`
    
        Represents a run-time module, either :meth:`~java.lang.Module.isNamed` or unnamed.
    
        Named modules have a :meth:`~java.lang.Module.getName` and are constructed by the Java Virtual Machine when a graph of
        modules is defined to the Java virtual machine to create a :class:`~java.lang.ModuleLayer`.
    
        An unnamed module does not have a name. There is an unnamed module for each :class:`~java.lang.ClassLoader`, obtained by
        invoking its :meth:`~java.lang.ClassLoader.getUnnamedModule` method. All types that are not in a named module are
        members of their defining class loader's unnamed module.
    
        The package names that are parameters or returned by methods defined in this class are the fully-qualified names of the
        packages as defined in section 6.5.3 of "The Javaâ„¢ Language Specification", for example, :code:`"java.lang"`.
    
        Unless otherwise specified, passing a :code:`null` argument to a method in this class causes a
        :class:`~java.lang.NullPointerException` to be thrown.
    
        Since:
            9
    
        Also see:
            :meth:`~java.lang.Class.getModule`
    
    
    """
    def addExports(self, string: 'String', module: 'Module') -> 'Module': ...
    def addOpens(self, string: 'String', module: 'Module') -> 'Module': ...
    def addReads(self, module: 'Module') -> 'Module': ...
    def addUses(self, class_: typing.Type[typing.Any]) -> 'Module': ...
    def canRead(self, module: 'Module') -> bool: ...
    def canUse(self, class_: typing.Type[typing.Any]) -> bool: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T', bound=java.lang.annotation.Annotation)  # <T>
    def getAnnotation(self, class_: typing.Type[_getAnnotation__T]) -> _getAnnotation__T: ...
    def getAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    def getClassLoader(self) -> 'ClassLoader': ...
    def getDeclaredAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    def getDescriptor(self) -> java.lang.module.ModuleDescriptor: ...
    def getLayer(self) -> 'ModuleLayer': ...
    def getName(self) -> 'String': ...
    def getPackages(self) -> java.util.Set['String']: ...
    def getResourceAsStream(self, string: 'String') -> java.io.InputStream: ...
    @typing.overload
    def isExported(self, string: 'String') -> bool: ...
    @typing.overload
    def isExported(self, string: 'String', module: 'Module') -> bool: ...
    def isNamed(self) -> bool: ...
    @typing.overload
    def isOpen(self, string: 'String') -> bool: ...
    @typing.overload
    def isOpen(self, string: 'String', module: 'Module') -> bool: ...
    def toString(self) -> 'String': ...

class Number(java.io.Serializable):
    """
    Java class 'java.lang.Number'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * Number()
    
    """
    def __init__(self): ...
    def byteValue(self) -> int: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def shortValue(self) -> int: ...

class Object:
    """
    public class Object
    
        Class :code:`Object` is the root of the class hierarchy. Every class has :code:`Object` as a superclass. All objects,
        including arrays, implement the methods of this class.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.lang.Class`
    
    publicÂ Object()
    
        Constructs a new object.
    
    """
    def __init__(self): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getClass(self) -> typing.Type[typing.Any]: ...
    def hashCode(self) -> int: ...
    def notify(self) -> None: ...
    def notifyAll(self) -> None: ...
    def toString(self) -> 'String': ...
    @typing.overload
    def wait(self, long: int) -> None: ...
    @typing.overload
    def wait(self) -> None: ...
    @typing.overload
    def wait(self, long: int, int: int) -> None: ...

class Override(java.lang.annotation.Annotation):
    """
    :class:`~java.lang.annotation.Target`(:meth:`~java.lang.annotation.ElementType.METHOD`) :class:`~java.lang.annotation.Retention`(:meth:`~java.lang.annotation.RetentionPolicy.SOURCE`) public @interface Override
    
        Indicates that a method declaration is intended to override a method declaration in a supertype. If a method is
        annotated with this annotation type compilers are required to generate an error message unless at least one of the
        following conditions hold:
    
          - The method does override or implement a method declared in a supertype.
          - The method has a signature that is override-equivalent to that of any public method declared in
            :class:`~java.lang.Object`.
    
    
        Since:
            1.5
    
        See Javaâ„¢ specification:
            8.4.8 Inheritance, Overriding, and Hiding, 9.4.1 Inheritance and Overriding, 9.6.4.4 @Override
    
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> 'String': ...

class RuntimePermission(java.security.BasicPermission):
    """
    Java class 'java.lang.RuntimePermission'
    
        Extends:
            java.security.BasicPermission
    
      Constructors:
        * RuntimePermission(java.lang.String)
        * RuntimePermission(java.lang.String, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', string2: 'String'): ...

class SafeVarargs(java.lang.annotation.Annotation):
    """
    :class:`~java.lang.annotation.Documented` :class:`~java.lang.annotation.Retention`(:meth:`~java.lang.annotation.RetentionPolicy.RUNTIME`) :class:`~java.lang.annotation.Target`({:meth:`~java.lang.annotation.ElementType.CONSTRUCTOR`,:meth:`~java.lang.annotation.ElementType.METHOD`}) public @interface SafeVarargs
    
        A programmer assertion that the body of the annotated method or constructor does not perform potentially unsafe
        operations on its varargs parameter. Applying this annotation to a method or constructor suppresses unchecked warnings
        about a *non-reifiable* variable arity (vararg) type and suppresses unchecked warnings about parameterized array
        creation at call sites.
    
        In addition to the usage restrictions imposed by its :class:`~java.lang.annotation.Target` meta-annotation, compilers
        are required to implement additional usage restrictions on this annotation type; it is a compile-time error if a method
        or constructor declaration is annotated with a :code:`@SafeVarargs` annotation, and either:
    
          - the declaration is a fixed arity method or constructor
          - the declaration is a variable arity method that is neither :code:`static` nor :code:`final` nor :code:`private`.
    
    
        Compilers are encouraged to issue warnings when this annotation type is applied to a method or constructor declaration
        where:
    
          - The variable arity parameter has a reifiable element type, which includes primitive types, :code:`Object`, and
            :code:`String`. (The unchecked warnings this annotation type suppresses already do not occur for a reifiable element
            type.)
          - The body of the method or constructor declaration performs potentially unsafe operations, such as an assignment to an
            element of the variable arity parameter's array that generates an unchecked warning. Some unsafe operations do not
            trigger an unchecked warning. For example, the aliasing in
    
                .. code-block: java
                
                 @SafeVarargs // Not actually safe!
                 static void m(List<String>... stringLists) {
                   Object[] array = stringLists;
                   List<Integer> tmpList = Arrays.asList(42);
                   array[0] = tmpList; // Semantically invalid, but compiles without warnings
                   String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!
                 }
                 
    leads to a :code:`ClassCastException` at runtime.
    
            Future versions of the platform may mandate compiler errors for such unsafe operations.
    
    
        Since:
            1.7
    
        See Javaâ„¢ specification:
            4.7 Reifiable Types, 8.4.1 Formal Parameters, 9.6.4.7 @SafeVarargs
    
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> 'String': ...

class StackTraceElement(java.io.Serializable):
    """
    Java class 'java.lang.StackTraceElement'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * StackTraceElement(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, int)
        * StackTraceElement(java.lang.String, java.lang.String, java.lang.String, int)
    
    """
    @typing.overload
    def __init__(self, string: 'String', string2: 'String', string3: 'String', int: int): ...
    @typing.overload
    def __init__(self, string: 'String', string2: 'String', string3: 'String', string4: 'String', string5: 'String', string6: 'String', int: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getClassLoaderName(self) -> 'String': ...
    def getClassName(self) -> 'String': ...
    def getFileName(self) -> 'String': ...
    def getLineNumber(self) -> int: ...
    def getMethodName(self) -> 'String': ...
    def getModuleName(self) -> 'String': ...
    def getModuleVersion(self) -> 'String': ...
    def hashCode(self) -> int: ...
    def isNativeMethod(self) -> bool: ...
    def toString(self) -> 'String': ...

class SuppressWarnings(java.lang.annotation.Annotation):
    """
    :class:`~java.lang.annotation.Target`({:meth:`~java.lang.annotation.ElementType.TYPE`,:meth:`~java.lang.annotation.ElementType.FIELD`,:meth:`~java.lang.annotation.ElementType.METHOD`,:meth:`~java.lang.annotation.ElementType.PARAMETER`,:meth:`~java.lang.annotation.ElementType.CONSTRUCTOR`,:meth:`~java.lang.annotation.ElementType.LOCAL_VARIABLE`,:meth:`~java.lang.annotation.ElementType.MODULE`}) :class:`~java.lang.annotation.Retention`(:meth:`~java.lang.annotation.RetentionPolicy.SOURCE`) public @interface SuppressWarnings
    
        Indicates that the named compiler warnings should be suppressed in the annotated element (and in all program elements
        contained in the annotated element). Note that the set of warnings suppressed in a given element is a superset of the
        warnings suppressed in all containing elements. For example, if you annotate a class to suppress one warning and
        annotate a method to suppress another, both warnings will be suppressed in the method. However, note that if a warning
        is suppressed in a :code:`module-info` file, the suppression applies to elements within the file and *not* to types
        contained within the module.
    
        As a matter of style, programmers should always use this annotation on the most deeply nested element where it is
        effective. If you want to suppress a warning in a particular method, you should annotate that method rather than its
        class.
    
        Since:
            1.5
    
        See Javaâ„¢ specification:
            4.8 Raw Types, 4.12.2 Variables of Reference Type, 5.1.9 Unchecked Conversion, 5.5.2 Checked Casts and Unchecked Casts,
            9.6.4.5 @SuppressWarnings
    
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> 'String': ...
    def value(self) -> typing.List['String']: ...

class Throwable(java.io.Serializable):
    """
    Java class 'java.lang.Throwable'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * Throwable(java.lang.Throwable)
        * Throwable(java.lang.String, java.lang.Throwable)
        * Throwable(java.lang.String)
        * Throwable()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: 'Throwable'): ...
    @typing.overload
    def __init__(self, throwable: 'Throwable'): ...
    def addSuppressed(self, throwable: 'Throwable') -> None: ...
    def fillInStackTrace(self) -> 'Throwable': ...
    def getCause(self) -> 'Throwable': ...
    def getLocalizedMessage(self) -> 'String': ...
    def getMessage(self) -> 'String': ...
    def getStackTrace(self) -> typing.List[StackTraceElement]: ...
    def getSuppressed(self) -> typing.List['Throwable']: ...
    def initCause(self, throwable: 'Throwable') -> 'Throwable': ...
    @typing.overload
    def printStackTrace(self) -> None: ...
    @typing.overload
    def printStackTrace(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def printStackTrace(self, printWriter: java.io.PrintWriter) -> None: ...
    def setStackTrace(self, stackTraceElementArray: typing.List[StackTraceElement]) -> None: ...
    def toString(self) -> 'String': ...

class Appendable(Object):
    """
    public interface Appendable
    
        An object to which :code:`char` sequences and values can be appended. The :code:`Appendable` interface must be
        implemented by any class whose instances are intended to receive formatted output from a :class:`~java.util.Formatter`.
    
        The characters to be appended should be valid Unicode characters as described in :meth:`~java.lang.Character.unicode`.
        Note that supplementary characters may be composed of multiple 16-bit :code:`char` values.
    
        Appendables are not necessarily safe for multithreaded access. Thread safety is the responsibility of classes that
        extend and implement this interface.
    
        Since this interface may be implemented by existing classes with different styles of error handling there is no
        guarantee that errors will be propagated to the invoker.
    
        Since:
            1.5
    
    
    """
    @typing.overload
    def append(self, char: str) -> 'Appendable': ...
    @typing.overload
    def append(self, charSequence: 'CharSequence') -> 'Appendable': ...
    @typing.overload
    def append(self, charSequence: 'CharSequence', int: int, int2: int) -> 'Appendable': ...

class AutoCloseable(Object):
    """
    public interface AutoCloseable
    
        An object that may hold resources (such as file or socket handles) until it is closed. The
        :meth:`~java.lang.AutoCloseable.close` method of an :code:`AutoCloseable` object is called automatically when exiting a
        :code:`try`-with-resources block for which the object has been declared in the resource specification header. This
        construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur.
    
        API Note:
    
            It is possible, and in fact common, for a base class to implement AutoCloseable even though not all of its subclasses or
            instances will hold releasable resources. For code that must operate in complete generality, or when it is known that
            the :code:`AutoCloseable` instance requires resource release, it is recommended to use :code:`try`-with-resources
            constructions. However, when using facilities such as :class:`~java.util.stream.Stream` that support both I/O-based and
            non-I/O-based forms, :code:`try`-with-resources blocks are in general unnecessary when using non-I/O-based forms.
    
        Since:
            1.7
    
    
    """
    def close(self) -> None: ...

class CharSequence(Object):
    """
    public interface CharSequence
    
        A :code:`CharSequence` is a readable sequence of :code:`char` values. This interface provides uniform, read-only access
        to many different kinds of :code:`char` sequences. A :code:`char` value represents a character in the *Basic
        Multilingual Plane (BMP)* or a surrogate. Refer to :meth:`~java.lang.Character.unicode` for details.
    
        This interface does not refine the general contracts of the :meth:`~java.lang.Object.equals` and
        :meth:`~java.lang.Object.hashCode` methods. The result of testing two objects that implement :code:`CharSequence` for
        equality is therefore, in general, undefined. Each object may be implemented by a different class, and there is no
        guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore
        inappropriate to use arbitrary :code:`CharSequence` instances as elements in a set or as keys in a map.
    
        Since:
            1.4
    
    
    """
    def charAt(self, int: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    @classmethod
    def compare(cls, charSequence: 'CharSequence', charSequence2: 'CharSequence') -> int: ...
    def length(self) -> int: ...
    def subSequence(self, int: int, int2: int) -> 'CharSequence': ...
    def toString(self) -> 'String': ...

class ClassLoader(Object):
    """
    Java class 'java.lang.ClassLoader'
    
        Extends:
            java.lang.Object
    
    """
    def clearAssertionStatus(self) -> None: ...
    def getDefinedPackage(self, string: 'String') -> 'Package': ...
    def getDefinedPackages(self) -> typing.List['Package']: ...
    def getName(self) -> 'String': ...
    def getParent(self) -> 'ClassLoader': ...
    @classmethod
    def getPlatformClassLoader(cls) -> 'ClassLoader': ...
    def getResource(self, string: 'String') -> java.net.URL: ...
    def getResourceAsStream(self, string: 'String') -> java.io.InputStream: ...
    def getResources(self, string: 'String') -> java.util.Enumeration[java.net.URL]: ...
    @classmethod
    def getSystemClassLoader(cls) -> 'ClassLoader': ...
    @classmethod
    def getSystemResource(cls, string: 'String') -> java.net.URL: ...
    @classmethod
    def getSystemResourceAsStream(cls, string: 'String') -> java.io.InputStream: ...
    @classmethod
    def getSystemResources(cls, string: 'String') -> java.util.Enumeration[java.net.URL]: ...
    def getUnnamedModule(self) -> Module: ...
    def isRegisteredAsParallelCapable(self) -> bool: ...
    def loadClass(self, string: 'String') -> typing.Type[typing.Any]: ...
    def resources(self, string: 'String') -> java.util.stream.Stream[java.net.URL]: ...
    def setClassAssertionStatus(self, string: 'String', boolean: bool) -> None: ...
    def setDefaultAssertionStatus(self, boolean: bool) -> None: ...
    def setPackageAssertionStatus(self, string: 'String', boolean: bool) -> None: ...

_ClassValue__T = typing.TypeVar('_ClassValue__T')  # <T>
class ClassValue(Object, typing.Generic[_ClassValue__T]):
    """
    Java class 'java.lang.ClassValue'
    
        Extends:
            java.lang.Object
    
    """
    def get(self, class_: typing.Type[typing.Any]) -> _ClassValue__T: ...
    def remove(self, class_: typing.Type[typing.Any]) -> None: ...

class Cloneable(Object):
    """
    public interface Cloneable
    
        A class implements the :code:`Cloneable` interface to indicate to the :meth:`~java.lang.Object.clone` method that it is
        legal for that method to make a field-for-field copy of instances of that class.
    
        Invoking Object's clone method on an instance that does not implement the :code:`Cloneable` interface results in the
        exception :code:`CloneNotSupportedException` being thrown.
    
        By convention, classes that implement this interface should override :code:`Object.clone` (which is protected) with a
        public method. See :meth:`~java.lang.Object.clone` for details on overriding this method.
    
        Note that this interface does *not* contain the :code:`clone` method. Therefore, it is not possible to clone an object
        merely by virtue of the fact that it implements this interface. Even if the clone method is invoked reflectively, there
        is no guarantee that it will succeed.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.lang.CloneNotSupportedException`, :meth:`~java.lang.Object.clone`
    
    
    """

_Comparable__T = typing.TypeVar('_Comparable__T')  # <T>
class Comparable(Object, typing.Generic[_Comparable__T]):
    """
    public interface Comparable<T>
    
        This interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as
        the class's *natural ordering*, and the class's :code:`compareTo` method is referred to as its *natural comparison
        method*.
    
        Lists (and arrays) of objects that implement this interface can be sorted automatically by
        :meth:`~java.util.Collections.sort` (and :meth:`~java.util.Arrays.sort`). Objects that implement this interface can be
        used as keys in a :class:`~java.util.SortedMap` or as elements in a :class:`~java.util.SortedSet`, without the need to
        specify a :class:`~java.util.Comparator`.
    
        The natural ordering for a class :code:`C` is said to be *consistent with equals* if and only if :code:`e1.compareTo(e2)
        == 0` has the same boolean value as :code:`e1.equals(e2)` for every :code:`e1` and :code:`e2` of class :code:`C`. Note
        that :code:`null` is not an instance of any class, and :code:`e.compareTo(null)` should throw a
        :code:`NullPointerException` even though :code:`e.equals(null)` returns :code:`false`.
    
        It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because
        sorted sets (and sorted maps) without explicit comparators behave "strangely" when they are used with elements (or keys)
        whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the
        general contract for set (or map), which is defined in terms of the :code:`equals` method.
    
        For example, if one adds two keys :code:`a` and :code:`b` such that :code:`(!a.equals(b) &&amp; a.compareTo(b) == 0)` to
        a sorted set that does not use an explicit comparator, the second :code:`add` operation returns false (and the size of
        the sorted set does not increase) because :code:`a` and :code:`b` are equivalent from the sorted set's perspective.
    
        Virtually all Java core classes that implement :code:`Comparable` have natural orderings that are consistent with
        equals. One exception is :code:`java.math.BigDecimal`, whose natural ordering equates :code:`BigDecimal` objects with
        equal values and different precisions (such as 4.0 and 4.00).
    
        For the mathematically inclined, the *relation* that defines the natural ordering on a given class C is:
    
        .. code-block: java
        
               {(x, y) such that x.compareTo(y) <= 0}.
         
        The *quotient* for this total order is:
    
        .. code-block: java
        
               {(x, y) such that x.compareTo(y) == 0}.
         
        It follows immediately from the contract for :code:`compareTo` that the quotient is an *equivalence relation* on
        :code:`C`, and that the natural ordering is a *total order* on :code:`C`. When we say that a class's natural ordering is
        *consistent with equals*, we mean that the quotient for the natural ordering is the equivalence relation defined by the
        class's :meth:`~java.lang.Object.equals` method:
    
        .. code-block: java
        
             {(x, y) such that x.equals(y)}. 
    
        This interface is a member of the :meth:`~java.util.package`.
    
        Since:
            1.2
    
        Also see:
            :class:`~java.util.Comparator`
    
    
    """
    def compareTo(self, t: _Comparable__T) -> int: ...

class Compiler(Object):
    """
    Java class 'java.lang.Compiler'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def command(cls, object: typing.Any) -> typing.Any: ...
    @classmethod
    def compileClass(cls, class_: typing.Type[typing.Any]) -> bool: ...
    @classmethod
    def compileClasses(cls, string: 'String') -> bool: ...
    @classmethod
    def disable(cls) -> None: ...
    @classmethod
    def enable(cls) -> None: ...

class Error(Throwable):
    """
    Java class 'java.lang.Error'
    
        Extends:
            java.lang.Throwable
    
      Constructors:
        * Error(java.lang.Throwable)
        * Error(java.lang.String, java.lang.Throwable)
        * Error(java.lang.String)
        * Error()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class Exception(Throwable):
    """
    Java class 'java.lang.Exception'
    
        Extends:
            java.lang.Throwable
    
      Constructors:
        * Exception(java.lang.Throwable)
        * Exception(java.lang.String, java.lang.Throwable)
        * Exception(java.lang.String)
        * Exception()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

_Iterable__T = typing.TypeVar('_Iterable__T')  # <T>
class Iterable(Object, typing.Generic[_Iterable__T]):
    """
    public interface Iterable<T>
    
        Implementing this interface allows an object to be the target of the enhanced :code:`for` statement (sometimes called
        the "for-each loop" statement).
    
        Since:
            1.5
    
        See Javaâ„¢ specification:
            14.14.2 The enhanced :code:`for` statement
    
    
    """
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Iterable__T], typing.Callable[[], _Iterable__T]]) -> None: ...
    def iterator(self) -> java.util.Iterator[_Iterable__T]: ...
    def spliterator(self) -> java.util.Spliterator[_Iterable__T]: ...

class Math(Object):
    """
    Java class 'java.lang.Math'
    
        Extends:
            java.lang.Object
    
      Attributes:
        E (double): final static field
        PI (double): final static field
    
    """
    E: typing.ClassVar[float] = ...
    PI: typing.ClassVar[float] = ...
    @classmethod
    def IEEEremainder(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, float: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def abs(cls, long: int) -> int: ...
    @classmethod
    def acos(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def addExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def addExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def asin(cls, double: float) -> float: ...
    @classmethod
    def atan(cls, double: float) -> float: ...
    @classmethod
    def atan2(cls, double: float, double2: float) -> float: ...
    @classmethod
    def cbrt(cls, double: float) -> float: ...
    @classmethod
    def ceil(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def copySign(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def copySign(cls, float: float, float2: float) -> float: ...
    @classmethod
    def cos(cls, double: float) -> float: ...
    @classmethod
    def cosh(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def decrementExact(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def decrementExact(cls, long: int) -> int: ...
    @classmethod
    def exp(cls, double: float) -> float: ...
    @classmethod
    def expm1(cls, double: float) -> float: ...
    @classmethod
    def floor(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def fma(cls, double: float, double2: float, double3: float) -> float: ...
    @classmethod
    @typing.overload
    def fma(cls, float: float, float2: float, float3: float) -> float: ...
    @classmethod
    @typing.overload
    def getExponent(cls, double: float) -> int: ...
    @classmethod
    @typing.overload
    def getExponent(cls, float: float) -> int: ...
    @classmethod
    def hypot(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def incrementExact(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def incrementExact(cls, long: int) -> int: ...
    @classmethod
    def log(cls, double: float) -> float: ...
    @classmethod
    def log10(cls, double: float) -> float: ...
    @classmethod
    def log1p(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, float: float, float2: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def max(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def min(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def min(cls, float: float, float2: float) -> float: ...
    @classmethod
    @typing.overload
    def min(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def min(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def multiplyFull(cls, int: int, int2: int) -> int: ...
    @classmethod
    def multiplyHigh(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def negateExact(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def negateExact(cls, long: int) -> int: ...
    @classmethod
    @typing.overload
    def nextAfter(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def nextAfter(cls, float: float, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextDown(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextDown(cls, float: float) -> float: ...
    @classmethod
    @typing.overload
    def nextUp(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextUp(cls, float: float) -> float: ...
    @classmethod
    def pow(cls, double: float, double2: float) -> float: ...
    @classmethod
    def random(cls) -> float: ...
    @classmethod
    def rint(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def round(cls, float: float) -> int: ...
    @classmethod
    @typing.overload
    def round(cls, double: float) -> int: ...
    @classmethod
    @typing.overload
    def scalb(cls, double: float, int: int) -> float: ...
    @classmethod
    @typing.overload
    def scalb(cls, float: float, int: int) -> float: ...
    @classmethod
    @typing.overload
    def signum(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def signum(cls, float: float) -> float: ...
    @classmethod
    def sin(cls, double: float) -> float: ...
    @classmethod
    def sinh(cls, double: float) -> float: ...
    @classmethod
    def sqrt(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def subtractExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def subtractExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def tan(cls, double: float) -> float: ...
    @classmethod
    def tanh(cls, double: float) -> float: ...
    @classmethod
    def toDegrees(cls, double: float) -> float: ...
    @classmethod
    def toIntExact(cls, long: int) -> int: ...
    @classmethod
    def toRadians(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def ulp(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def ulp(cls, float: float) -> float: ...

class ModuleLayer(Object):
    """
    Java class 'java.lang.ModuleLayer'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def boot(cls) -> 'ModuleLayer': ...
    def configuration(self) -> java.lang.module.Configuration: ...
    @typing.overload
    def defineModules(self, configuration: java.lang.module.Configuration, function: typing.Union[java.util.function.Function['String', ClassLoader], typing.Callable[['String'], ClassLoader]]) -> 'ModuleLayer': ...
    @classmethod
    @typing.overload
    def defineModules(cls, configuration: java.lang.module.Configuration, list: java.util.List['ModuleLayer'], function: typing.Union[java.util.function.Function['String', ClassLoader], typing.Callable[['String'], ClassLoader]]) -> 'ModuleLayer.Controller': ...
    @typing.overload
    def defineModulesWithManyLoaders(self, configuration: java.lang.module.Configuration, classLoader: ClassLoader) -> 'ModuleLayer': ...
    @classmethod
    @typing.overload
    def defineModulesWithManyLoaders(cls, configuration: java.lang.module.Configuration, list: java.util.List['ModuleLayer'], classLoader: ClassLoader) -> 'ModuleLayer.Controller': ...
    @typing.overload
    def defineModulesWithOneLoader(self, configuration: java.lang.module.Configuration, classLoader: ClassLoader) -> 'ModuleLayer': ...
    @classmethod
    @typing.overload
    def defineModulesWithOneLoader(cls, configuration: java.lang.module.Configuration, list: java.util.List['ModuleLayer'], classLoader: ClassLoader) -> 'ModuleLayer.Controller': ...
    @classmethod
    def empty(cls) -> 'ModuleLayer': ...
    def findLoader(self, string: 'String') -> ClassLoader: ...
    def findModule(self, string: 'String') -> java.util.Optional[Module]: ...
    def modules(self) -> java.util.Set[Module]: ...
    def parents(self) -> java.util.List['ModuleLayer']: ...
    def toString(self) -> 'String': ...
    class Controller(Object):
        """
        Java class 'java.lang.ModuleLayer$Controller'
        
            Extends:
                java.lang.Object
        
        """
        def addExports(self, module: Module, string: 'String', module2: Module) -> 'ModuleLayer.Controller': ...
        def addOpens(self, module: Module, string: 'String', module2: Module) -> 'ModuleLayer.Controller': ...
        def addReads(self, module: Module, module2: Module) -> 'ModuleLayer.Controller': ...
        def layer(self) -> 'ModuleLayer': ...

class Process(Object):
    """
    Java class 'java.lang.Process'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Process()
    
    """
    def __init__(self): ...
    def children(self) -> java.util.stream.Stream['ProcessHandle']: ...
    def descendants(self) -> java.util.stream.Stream['ProcessHandle']: ...
    def destroy(self) -> None: ...
    def destroyForcibly(self) -> 'Process': ...
    def exitValue(self) -> int: ...
    def getErrorStream(self) -> java.io.InputStream: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def info(self) -> 'ProcessHandle.Info': ...
    def isAlive(self) -> bool: ...
    def onExit(self) -> java.util.concurrent.CompletableFuture['Process']: ...
    def pid(self) -> int: ...
    def supportsNormalTermination(self) -> bool: ...
    def toHandle(self) -> 'ProcessHandle': ...
    @typing.overload
    def waitFor(self) -> int: ...
    @typing.overload
    def waitFor(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> bool: ...

class Readable(Object):
    """
    public interface Readable
    
        A :code:`Readable` is a source of characters. Characters from a :code:`Readable` are made available to callers of the
        read method via a :class:`~java.nio.CharBuffer`.
    
        Since:
            1.5
    
    
    """
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...

class Runnable(Object):
    """
    :class:`~java.lang.FunctionalInterface` public interface Runnable
    
        The :code:`Runnable` interface should be implemented by any class whose instances are intended to be executed by a
        thread. The class must define a method of no arguments called :code:`run`.
    
        This interface is designed to provide a common protocol for objects that wish to execute code while they are active. For
        example, :code:`Runnable` is implemented by class :code:`Thread`. Being active simply means that a thread has been
        started and has not yet been stopped.
    
        In addition, :code:`Runnable` provides the means for a class to be active while not subclassing :code:`Thread`. A class
        that implements :code:`Runnable` can run without subclassing :code:`Thread` by instantiating a :code:`Thread` instance
        and passing itself in as the target. In most cases, the :code:`Runnable` interface should be used if you are only
        planning to override the :code:`run()` method and no other :code:`Thread` methods. This is important because classes
        should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.lang.Thread`, :class:`~java.util.concurrent.Callable`
    
    
    """
    def run(self) -> None: ...

class SecurityManager(Object):
    """
    Java class 'java.lang.SecurityManager'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * SecurityManager()
    
    """
    def __init__(self): ...
    def checkAccept(self, string: 'String', int: int) -> None: ...
    @typing.overload
    def checkAccess(self, thread: 'Thread') -> None: ...
    @typing.overload
    def checkAccess(self, threadGroup: 'ThreadGroup') -> None: ...
    @typing.overload
    def checkConnect(self, string: 'String', int: int) -> None: ...
    @typing.overload
    def checkConnect(self, string: 'String', int: int, object: typing.Any) -> None: ...
    def checkCreateClassLoader(self) -> None: ...
    def checkDelete(self, string: 'String') -> None: ...
    def checkExec(self, string: 'String') -> None: ...
    def checkExit(self, int: int) -> None: ...
    def checkLink(self, string: 'String') -> None: ...
    def checkListen(self, int: int) -> None: ...
    @typing.overload
    def checkMulticast(self, inetAddress: java.net.InetAddress) -> None: ...
    @typing.overload
    def checkMulticast(self, inetAddress: java.net.InetAddress, byte: int) -> None: ...
    def checkPackageAccess(self, string: 'String') -> None: ...
    def checkPackageDefinition(self, string: 'String') -> None: ...
    @typing.overload
    def checkPermission(self, permission: java.security.Permission) -> None: ...
    @typing.overload
    def checkPermission(self, permission: java.security.Permission, object: typing.Any) -> None: ...
    def checkPrintJobAccess(self) -> None: ...
    def checkPropertiesAccess(self) -> None: ...
    def checkPropertyAccess(self, string: 'String') -> None: ...
    @typing.overload
    def checkRead(self, fileDescriptor: java.io.FileDescriptor) -> None: ...
    @typing.overload
    def checkRead(self, string: 'String') -> None: ...
    @typing.overload
    def checkRead(self, string: 'String', object: typing.Any) -> None: ...
    def checkSecurityAccess(self, string: 'String') -> None: ...
    def checkSetFactory(self) -> None: ...
    @typing.overload
    def checkWrite(self, fileDescriptor: java.io.FileDescriptor) -> None: ...
    @typing.overload
    def checkWrite(self, string: 'String') -> None: ...
    def getSecurityContext(self) -> typing.Any: ...
    def getThreadGroup(self) -> 'ThreadGroup': ...

class StrictMath(Object):
    """
    Java class 'java.lang.StrictMath'
    
        Extends:
            java.lang.Object
    
      Attributes:
        E (double): final static field
        PI (double): final static field
    
    """
    E: typing.ClassVar[float] = ...
    PI: typing.ClassVar[float] = ...
    @classmethod
    def IEEEremainder(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, float: float) -> float: ...
    @classmethod
    @typing.overload
    def abs(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def abs(cls, long: int) -> int: ...
    @classmethod
    def acos(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def addExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def addExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def asin(cls, double: float) -> float: ...
    @classmethod
    def atan(cls, double: float) -> float: ...
    @classmethod
    def atan2(cls, double: float, double2: float) -> float: ...
    @classmethod
    def cbrt(cls, double: float) -> float: ...
    @classmethod
    def ceil(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def copySign(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def copySign(cls, float: float, float2: float) -> float: ...
    @classmethod
    def cos(cls, double: float) -> float: ...
    @classmethod
    def cosh(cls, double: float) -> float: ...
    @classmethod
    def exp(cls, double: float) -> float: ...
    @classmethod
    def expm1(cls, double: float) -> float: ...
    @classmethod
    def floor(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def floorDiv(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def floorMod(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def fma(cls, double: float, double2: float, double3: float) -> float: ...
    @classmethod
    @typing.overload
    def fma(cls, float: float, float2: float, float3: float) -> float: ...
    @classmethod
    @typing.overload
    def getExponent(cls, double: float) -> int: ...
    @classmethod
    @typing.overload
    def getExponent(cls, float: float) -> int: ...
    @classmethod
    def hypot(cls, double: float, double2: float) -> float: ...
    @classmethod
    def log(cls, double: float) -> float: ...
    @classmethod
    def log10(cls, double: float) -> float: ...
    @classmethod
    def log1p(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, float: float, float2: float) -> float: ...
    @classmethod
    @typing.overload
    def max(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def max(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def min(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def min(cls, float: float, float2: float) -> float: ...
    @classmethod
    @typing.overload
    def min(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def min(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, long: int, int: int) -> int: ...
    @classmethod
    @typing.overload
    def multiplyExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def multiplyFull(cls, int: int, int2: int) -> int: ...
    @classmethod
    def multiplyHigh(cls, long: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def nextAfter(cls, double: float, double2: float) -> float: ...
    @classmethod
    @typing.overload
    def nextAfter(cls, float: float, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextDown(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextDown(cls, float: float) -> float: ...
    @classmethod
    @typing.overload
    def nextUp(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def nextUp(cls, float: float) -> float: ...
    @classmethod
    def pow(cls, double: float, double2: float) -> float: ...
    @classmethod
    def random(cls) -> float: ...
    @classmethod
    def rint(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def round(cls, float: float) -> int: ...
    @classmethod
    @typing.overload
    def round(cls, double: float) -> int: ...
    @classmethod
    @typing.overload
    def scalb(cls, double: float, int: int) -> float: ...
    @classmethod
    @typing.overload
    def scalb(cls, float: float, int: int) -> float: ...
    @classmethod
    @typing.overload
    def signum(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def signum(cls, float: float) -> float: ...
    @classmethod
    def sin(cls, double: float) -> float: ...
    @classmethod
    def sinh(cls, double: float) -> float: ...
    @classmethod
    def sqrt(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def subtractExact(cls, int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def subtractExact(cls, long: int, long2: int) -> int: ...
    @classmethod
    def tan(cls, double: float) -> float: ...
    @classmethod
    def tanh(cls, double: float) -> float: ...
    @classmethod
    def toDegrees(cls, double: float) -> float: ...
    @classmethod
    def toIntExact(cls, long: int) -> int: ...
    @classmethod
    def toRadians(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def ulp(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def ulp(cls, float: float) -> float: ...

_ThreadLocal__T = typing.TypeVar('_ThreadLocal__T')  # <T>
class ThreadLocal(Object, typing.Generic[_ThreadLocal__T]):
    """
    Java class 'java.lang.ThreadLocal'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ThreadLocal()
    
    """
    def __init__(self): ...
    def get(self) -> _ThreadLocal__T: ...
    def remove(self) -> None: ...
    def set(self, t: _ThreadLocal__T) -> None: ...
    _withInitial__S = typing.TypeVar('_withInitial__S')  # <S>
    @classmethod
    def withInitial(cls, supplier: typing.Union[java.util.function.Supplier[_withInitial__S], typing.Callable[[], _withInitial__S]]) -> 'ThreadLocal'[_withInitial__S]: ...

class Void(Object):
    """
    Java class 'java.lang.Void'
    
        Extends:
            java.lang.Object
    
      Attributes:
        TYPE (java.lang.Class): final static field
    
    """
    TYPE: typing.ClassVar[typing.Type] = ...

class AssertionError(Error):
    """
    Java class 'java.lang.AssertionError'
    
        Extends:
            java.lang.Error
    
      Constructors:
        * AssertionError(int)
        * AssertionError(long)
        * AssertionError(float)
        * AssertionError(double)
        * AssertionError(java.lang.String, java.lang.Throwable)
        * AssertionError()
        * AssertionError(java.lang.Object)
        * AssertionError(boolean)
        * AssertionError(char)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, char: str): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, float: float): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, object: typing.Any): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...
    @typing.overload
    def __init__(self, long: int): ...

class Boolean(java.io.Serializable, Comparable[bool]):
    """
    Java class 'java.lang.Boolean'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable
    
      Constructors:
        * Boolean(boolean)
        * Boolean(java.lang.String)
    
      Attributes:
        TRUE (java.lang.Boolean): final static field
        FALSE (java.lang.Boolean): final static field
        TYPE (java.lang.Class): final static field
    
    """
    TRUE: typing.ClassVar[bool] = ...
    FALSE: typing.ClassVar[bool] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    def booleanValue(self) -> bool: ...
    @classmethod
    def compare(cls, boolean: bool, boolean2: bool) -> int: ...
    @typing.overload
    def compareTo(self, boolean: bool) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def getBoolean(cls, string: 'String') -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, boolean: bool) -> int: ...
    @classmethod
    def logicalAnd(cls, boolean: bool, boolean2: bool) -> bool: ...
    @classmethod
    def logicalOr(cls, boolean: bool, boolean2: bool) -> bool: ...
    @classmethod
    def logicalXor(cls, boolean: bool, boolean2: bool) -> bool: ...
    @classmethod
    def parseBoolean(cls, string: 'String') -> bool: ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, boolean: bool) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, boolean: bool) -> bool: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> bool: ...

class Byte(Number, Comparable[int]):
    """
    Java class 'java.lang.Byte'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Byte(byte)
        * Byte(java.lang.String)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        MIN_VALUE (byte): final static field
        MAX_VALUE (byte): final static field
        TYPE (java.lang.Class): final static field
        SIZE (int): final static field
        BYTES (int): final static field
    
    """
    MIN_VALUE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, byte: int): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, byte: int, byte2: int) -> int: ...
    @typing.overload
    def compareTo(self, byte: int) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    def compareUnsigned(cls, byte: int, byte2: int) -> int: ...
    @classmethod
    def decode(cls, string: 'String') -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, byte: int) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @classmethod
    @typing.overload
    def parseByte(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseByte(cls, string: 'String', int: int) -> int: ...
    def shortValue(self) -> int: ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, byte: int) -> 'String': ...
    @classmethod
    def toUnsignedInt(cls, byte: int) -> int: ...
    @classmethod
    def toUnsignedLong(cls, byte: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, byte: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String', int: int) -> int: ...

class CloneNotSupportedException(Exception):
    """
    Java class 'java.lang.CloneNotSupportedException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * CloneNotSupportedException()
        * CloneNotSupportedException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...

class Double(Number, Comparable[float]):
    """
    Java class 'java.lang.Double'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Double(double)
        * Double(java.lang.String)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        POSITIVE_INFINITY (double): final static field
        NEGATIVE_INFINITY (double): final static field
        NaN (double): final static field
        MAX_VALUE (double): final static field
        MIN_NORMAL (double): final static field
        MIN_VALUE (double): final static field
        MAX_EXPONENT (int): final static field
        MIN_EXPONENT (int): final static field
        SIZE (int): final static field
        BYTES (int): final static field
        TYPE (java.lang.Class): final static field
    
    """
    POSITIVE_INFINITY: typing.ClassVar[float] = ...
    NEGATIVE_INFINITY: typing.ClassVar[float] = ...
    NaN: typing.ClassVar[float] = ...
    MAX_VALUE: typing.ClassVar[float] = ...
    MIN_NORMAL: typing.ClassVar[float] = ...
    MIN_VALUE: typing.ClassVar[float] = ...
    MAX_EXPONENT: typing.ClassVar[int] = ...
    MIN_EXPONENT: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, double: float, double2: float) -> int: ...
    @typing.overload
    def compareTo(self, double: float) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    def doubleToLongBits(cls, double: float) -> int: ...
    @classmethod
    def doubleToRawLongBits(cls, double: float) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, double: float) -> int: ...
    def intValue(self) -> int: ...
    @classmethod
    def isFinite(cls, double: float) -> bool: ...
    @typing.overload
    def isInfinite(self) -> bool: ...
    @classmethod
    @typing.overload
    def isInfinite(cls, double: float) -> bool: ...
    @typing.overload
    def isNaN(self) -> bool: ...
    @classmethod
    @typing.overload
    def isNaN(cls, double: float) -> bool: ...
    @classmethod
    def longBitsToDouble(cls, long: int) -> float: ...
    def longValue(self) -> int: ...
    @classmethod
    def max(cls, double: float, double2: float) -> float: ...
    @classmethod
    def min(cls, double: float, double2: float) -> float: ...
    @classmethod
    def parseDouble(cls, string: 'String') -> float: ...
    def shortValue(self) -> int: ...
    @classmethod
    def sum(cls, double: float, double2: float) -> float: ...
    @classmethod
    def toHexString(cls, double: float) -> 'String': ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, double: float) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, double: float) -> float: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> float: ...

_Enum__E = typing.TypeVar('_Enum__E', bound='Enum')  # <E>
class Enum(Comparable[_Enum__E], java.io.Serializable, typing.Generic[_Enum__E]):
    """
    Java class 'java.lang.Enum'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Comparable, java.io.Serializable
    
    """
    @typing.overload
    def compareTo(self, e: _Enum__E) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDeclaringClass(self) -> typing.Type[_Enum__E]: ...
    def hashCode(self) -> int: ...
    def name(self) -> 'String': ...
    def ordinal(self) -> int: ...
    def toString(self) -> 'String': ...
    _valueOf__T = typing.TypeVar('_valueOf__T', bound='Enum')  # <T>
    @classmethod
    def valueOf(cls, class_: typing.Type[_valueOf__T], string: 'String') -> _valueOf__T: ...

class Float(Number, Comparable[float]):
    """
    Java class 'java.lang.Float'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Float(java.lang.String)
        * Float(double)
        * Float(float)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        POSITIVE_INFINITY (float): final static field
        NEGATIVE_INFINITY (float): final static field
        NaN (float): final static field
        MAX_VALUE (float): final static field
        MIN_NORMAL (float): final static field
        MIN_VALUE (float): final static field
        MAX_EXPONENT (int): final static field
        MIN_EXPONENT (int): final static field
        SIZE (int): final static field
        BYTES (int): final static field
        TYPE (java.lang.Class): final static field
    
    """
    POSITIVE_INFINITY: typing.ClassVar[float] = ...
    NEGATIVE_INFINITY: typing.ClassVar[float] = ...
    NaN: typing.ClassVar[float] = ...
    MAX_VALUE: typing.ClassVar[float] = ...
    MIN_NORMAL: typing.ClassVar[float] = ...
    MIN_VALUE: typing.ClassVar[float] = ...
    MAX_EXPONENT: typing.ClassVar[int] = ...
    MIN_EXPONENT: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, float: float): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, float: float, float2: float) -> int: ...
    @typing.overload
    def compareTo(self, float: float) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def floatToIntBits(cls, float: float) -> int: ...
    @classmethod
    def floatToRawIntBits(cls, float: float) -> int: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, float: float) -> int: ...
    @classmethod
    def intBitsToFloat(cls, int: int) -> float: ...
    def intValue(self) -> int: ...
    @classmethod
    def isFinite(cls, float: float) -> bool: ...
    @typing.overload
    def isInfinite(self) -> bool: ...
    @classmethod
    @typing.overload
    def isInfinite(cls, float: float) -> bool: ...
    @typing.overload
    def isNaN(self) -> bool: ...
    @classmethod
    @typing.overload
    def isNaN(cls, float: float) -> bool: ...
    def longValue(self) -> int: ...
    @classmethod
    def max(cls, float: float, float2: float) -> float: ...
    @classmethod
    def min(cls, float: float, float2: float) -> float: ...
    @classmethod
    def parseFloat(cls, string: 'String') -> float: ...
    def shortValue(self) -> int: ...
    @classmethod
    def sum(cls, float: float, float2: float) -> float: ...
    @classmethod
    def toHexString(cls, float: float) -> 'String': ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, float: float) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, float: float) -> float: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> float: ...

_InheritableThreadLocal__T = typing.TypeVar('_InheritableThreadLocal__T')  # <T>
class InheritableThreadLocal(ThreadLocal[_InheritableThreadLocal__T], typing.Generic[_InheritableThreadLocal__T]):
    """
    Java class 'java.lang.InheritableThreadLocal'
    
        Extends:
            java.lang.ThreadLocal
    
      Constructors:
        * InheritableThreadLocal()
    
    """
    def __init__(self): ...

class Integer(Number, Comparable[int]):
    """
    Java class 'java.lang.Integer'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Integer(java.lang.String)
        * Integer(int)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        MIN_VALUE (int): final static field
        MAX_VALUE (int): final static field
        TYPE (java.lang.Class): final static field
        SIZE (int): final static field
        BYTES (int): final static field
    
    """
    MIN_VALUE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @classmethod
    def bitCount(cls, int: int) -> int: ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, int: int, int2: int) -> int: ...
    @typing.overload
    def compareTo(self, integer: int) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    def compareUnsigned(cls, int: int, int2: int) -> int: ...
    @classmethod
    def decode(cls, string: 'String') -> int: ...
    @classmethod
    def divideUnsigned(cls, int: int, int2: int) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @classmethod
    @typing.overload
    def getInteger(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def getInteger(cls, string: 'String', int: int) -> int: ...
    @classmethod
    @typing.overload
    def getInteger(cls, string: 'String', integer: int) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, int: int) -> int: ...
    @classmethod
    def highestOneBit(cls, int: int) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @classmethod
    def lowestOneBit(cls, int: int) -> int: ...
    @classmethod
    def max(cls, int: int, int2: int) -> int: ...
    @classmethod
    def min(cls, int: int, int2: int) -> int: ...
    @classmethod
    def numberOfLeadingZeros(cls, int: int) -> int: ...
    @classmethod
    def numberOfTrailingZeros(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def parseInt(cls, charSequence: CharSequence, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    @typing.overload
    def parseInt(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseInt(cls, string: 'String', int: int) -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedInt(cls, charSequence: CharSequence, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedInt(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedInt(cls, string: 'String', int: int) -> int: ...
    @classmethod
    def remainderUnsigned(cls, int: int, int2: int) -> int: ...
    @classmethod
    def reverse(cls, int: int) -> int: ...
    @classmethod
    def reverseBytes(cls, int: int) -> int: ...
    @classmethod
    def rotateLeft(cls, int: int, int2: int) -> int: ...
    @classmethod
    def rotateRight(cls, int: int, int2: int) -> int: ...
    def shortValue(self) -> int: ...
    @classmethod
    def signum(cls, int: int) -> int: ...
    @classmethod
    def sum(cls, int: int, int2: int) -> int: ...
    @classmethod
    def toBinaryString(cls, int: int) -> 'String': ...
    @classmethod
    def toHexString(cls, int: int) -> 'String': ...
    @classmethod
    def toOctalString(cls, int: int) -> 'String': ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, int: int) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, int: int, int2: int) -> 'String': ...
    @classmethod
    def toUnsignedLong(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def toUnsignedString(cls, int: int) -> 'String': ...
    @classmethod
    @typing.overload
    def toUnsignedString(cls, int: int, int2: int) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String', int: int) -> int: ...

class InterruptedException(Exception):
    """
    Java class 'java.lang.InterruptedException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * InterruptedException()
        * InterruptedException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...

class LinkageError(Error):
    """
    Java class 'java.lang.LinkageError'
    
        Extends:
            java.lang.Error
    
      Constructors:
        * LinkageError()
        * LinkageError(java.lang.String)
        * LinkageError(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...

class Long(Number, Comparable[int]):
    """
    Java class 'java.lang.Long'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Long(java.lang.String)
        * Long(long)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        MIN_VALUE (long): final static field
        MAX_VALUE (long): final static field
        TYPE (java.lang.Class): final static field
        SIZE (int): final static field
        BYTES (int): final static field
    
    """
    MIN_VALUE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, long: int): ...
    @classmethod
    def bitCount(cls, long: int) -> int: ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, long: int, long2: int) -> int: ...
    @typing.overload
    def compareTo(self, long: int) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    def compareUnsigned(cls, long: int, long2: int) -> int: ...
    @classmethod
    def decode(cls, string: 'String') -> int: ...
    @classmethod
    def divideUnsigned(cls, long: int, long2: int) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @classmethod
    @typing.overload
    def getLong(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def getLong(cls, string: 'String', long: int) -> int: ...
    @classmethod
    @typing.overload
    def getLong(cls, string: 'String', long: int) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, long: int) -> int: ...
    @classmethod
    def highestOneBit(cls, long: int) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @classmethod
    def lowestOneBit(cls, long: int) -> int: ...
    @classmethod
    def max(cls, long: int, long2: int) -> int: ...
    @classmethod
    def min(cls, long: int, long2: int) -> int: ...
    @classmethod
    def numberOfLeadingZeros(cls, long: int) -> int: ...
    @classmethod
    def numberOfTrailingZeros(cls, long: int) -> int: ...
    @classmethod
    @typing.overload
    def parseLong(cls, charSequence: CharSequence, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    @typing.overload
    def parseLong(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseLong(cls, string: 'String', int: int) -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedLong(cls, charSequence: CharSequence, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedLong(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseUnsignedLong(cls, string: 'String', int: int) -> int: ...
    @classmethod
    def remainderUnsigned(cls, long: int, long2: int) -> int: ...
    @classmethod
    def reverse(cls, long: int) -> int: ...
    @classmethod
    def reverseBytes(cls, long: int) -> int: ...
    @classmethod
    def rotateLeft(cls, long: int, int: int) -> int: ...
    @classmethod
    def rotateRight(cls, long: int, int: int) -> int: ...
    def shortValue(self) -> int: ...
    @classmethod
    def signum(cls, long: int) -> int: ...
    @classmethod
    def sum(cls, long: int, long2: int) -> int: ...
    @classmethod
    def toBinaryString(cls, long: int) -> 'String': ...
    @classmethod
    def toHexString(cls, long: int) -> 'String': ...
    @classmethod
    def toOctalString(cls, long: int) -> 'String': ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, long: int) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, long: int, int: int) -> 'String': ...
    @classmethod
    @typing.overload
    def toUnsignedString(cls, long: int) -> 'String': ...
    @classmethod
    @typing.overload
    def toUnsignedString(cls, long: int, int: int) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String', int: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, long: int) -> int: ...

class ProcessHandle(Comparable[java.lang.ProcessHandle]):
    """
    Java class 'java.lang.ProcessHandle'
    
        Interfaces:
            java.lang.Comparable
    
    """
    @classmethod
    def allProcesses(cls) -> java.util.stream.Stream['ProcessHandle']: ...
    def children(self) -> java.util.stream.Stream['ProcessHandle']: ...
    @typing.overload
    def compareTo(self, processHandle: 'ProcessHandle') -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    def current(cls) -> 'ProcessHandle': ...
    def descendants(self) -> java.util.stream.Stream['ProcessHandle']: ...
    def destroy(self) -> bool: ...
    def destroyForcibly(self) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def info(self) -> 'ProcessHandle.Info': ...
    def isAlive(self) -> bool: ...
    @classmethod
    def of(cls, long: int) -> java.util.Optional['ProcessHandle']: ...
    def onExit(self) -> java.util.concurrent.CompletableFuture['ProcessHandle']: ...
    def parent(self) -> java.util.Optional['ProcessHandle']: ...
    def pid(self) -> int: ...
    def supportsNormalTermination(self) -> bool: ...
    class Info(Object):
        """
        Java class 'java.lang.ProcessHandle$Info'
        
        """
        def arguments(self) -> java.util.Optional[typing.List['String']]: ...
        def command(self) -> java.util.Optional['String']: ...
        def commandLine(self) -> java.util.Optional['String']: ...
        def startInstant(self) -> java.util.Optional[java.time.Instant]: ...
        def totalCpuDuration(self) -> java.util.Optional[java.time.Duration]: ...
        def user(self) -> java.util.Optional['String']: ...

class ReflectiveOperationException(Exception):
    """
    Java class 'java.lang.ReflectiveOperationException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * ReflectiveOperationException(java.lang.Throwable)
        * ReflectiveOperationException(java.lang.String, java.lang.Throwable)
        * ReflectiveOperationException(java.lang.String)
        * ReflectiveOperationException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class Runtime(Object):
    """
    Java class 'java.lang.Runtime'
    
        Extends:
            java.lang.Object
    
    """
    def availableProcessors(self) -> int: ...
    def exit(self, int: int) -> None: ...
    def freeMemory(self) -> int: ...
    def gc(self) -> None: ...
    @classmethod
    def getRuntime(cls) -> 'Runtime': ...
    def halt(self, int: int) -> None: ...
    def load(self, string: 'String') -> None: ...
    def loadLibrary(self, string: 'String') -> None: ...
    def maxMemory(self) -> int: ...
    def runFinalization(self) -> None: ...
    def totalMemory(self) -> int: ...
    def traceInstructions(self, boolean: bool) -> None: ...
    def traceMethodCalls(self, boolean: bool) -> None: ...
    @classmethod
    def version(cls) -> 'Runtime.Version': ...
    class Version(Comparable[java.lang.Runtime.Version]):
        """
        Java class 'java.lang.Runtime$Version'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.lang.Comparable
        
        """
        def build(self) -> java.util.Optional[int]: ...
        @typing.overload
        def compareTo(self, object: typing.Any) -> int: ...
        @typing.overload
        def compareTo(self, version: 'Runtime.Version') -> int: ...
        def compareToIgnoreOptional(self, version: 'Runtime.Version') -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def equalsIgnoreOptional(self, object: typing.Any) -> bool: ...
        def feature(self) -> int: ...
        def hashCode(self) -> int: ...
        def interim(self) -> int: ...
        def major(self) -> int: ...
        def minor(self) -> int: ...
        def optional(self) -> java.util.Optional['String']: ...
        @classmethod
        def parse(cls, string: 'String') -> 'Runtime.Version': ...
        def patch(self) -> int: ...
        def pre(self) -> java.util.Optional['String']: ...
        def security(self) -> int: ...
        def toString(self) -> 'String': ...
        def update(self) -> int: ...
        def version(self) -> java.util.List[int]: ...

class RuntimeException(Exception):
    """
    Java class 'java.lang.RuntimeException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * RuntimeException(java.lang.Throwable)
        * RuntimeException(java.lang.String, java.lang.Throwable)
        * RuntimeException(java.lang.String)
        * RuntimeException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, string: 'String', throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class Short(Number, Comparable[int]):
    """
    Java class 'java.lang.Short'
    
        Extends:
            java.lang.Number
    
        Interfaces:
            java.lang.Comparable
    
      Constructors:
        * Short(short)
        * Short(java.lang.String)
    
      Raises:
        java.lang.NumberFormatException: from java
    
      Attributes:
        MIN_VALUE (short): final static field
        MAX_VALUE (short): final static field
        TYPE (java.lang.Class): final static field
        SIZE (int): final static field
        BYTES (int): final static field
    
    """
    MIN_VALUE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, short: int): ...
    def byteValue(self) -> int: ...
    @classmethod
    def compare(cls, short: int, short2: int) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, short: int) -> int: ...
    @classmethod
    def compareUnsigned(cls, short: int, short2: int) -> int: ...
    @classmethod
    def decode(cls, string: 'String') -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, short: int) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @classmethod
    @typing.overload
    def parseShort(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def parseShort(cls, string: 'String', int: int) -> int: ...
    @classmethod
    def reverseBytes(cls, short: int) -> int: ...
    def shortValue(self) -> int: ...
    @typing.overload
    def toString(self) -> 'String': ...
    @classmethod
    @typing.overload
    def toString(cls, short: int) -> 'String': ...
    @classmethod
    def toUnsignedInt(cls, short: int) -> int: ...
    @classmethod
    def toUnsignedLong(cls, short: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String') -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: 'String', int: int) -> int: ...
    @classmethod
    @typing.overload
    def valueOf(cls, short: int) -> int: ...

class String(java.io.Serializable, Comparable[java.lang.String], CharSequence):
    """
    Java class 'java.lang.String'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable,
            java.lang.CharSequence
    
      Constructors:
        * String(byte[])
        * String(byte[], int, int)
        * String(byte[], java.nio.charset.Charset)
        * String(byte[], java.lang.String)
        * String(byte[], int, int, java.nio.charset.Charset)
        * String(java.lang.StringBuilder)
        * String(java.lang.StringBuffer)
        * String(char[], int, int)
        * String(char[])
        * String(java.lang.String)
        * String()
        * String(byte[], int, int, java.lang.String)
        * String(byte[], int)
        * String(byte[], int, int, int)
        * String(int[], int, int)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
    
      Attributes:
        CASE_INSENSITIVE_ORDER (java.util.Comparator): final static field
    
    """
    CASE_INSENSITIVE_ORDER: typing.ClassVar[java.util.Comparator] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int]): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int, string: 'String'): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], string: 'String'): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str]): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str], int: int, int2: int): ...
    @typing.overload
    def __init__(self, intArray: typing.List[int], int2: int, int3: int): ...
    @typing.overload
    def __init__(self, string: 'String'): ...
    @typing.overload
    def __init__(self, stringBuffer: 'StringBuffer'): ...
    @typing.overload
    def __init__(self, stringBuilder: 'StringBuilder'): ...
    def charAt(self, int: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, int: int) -> int: ...
    def codePointBefore(self, int: int) -> int: ...
    def codePointCount(self, int: int, int2: int) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, string: 'String') -> int: ...
    def compareToIgnoreCase(self, string: 'String') -> int: ...
    def concat(self, string: 'String') -> 'String': ...
    def contains(self, charSequence: CharSequence) -> bool: ...
    @typing.overload
    def contentEquals(self, charSequence: CharSequence) -> bool: ...
    @typing.overload
    def contentEquals(self, stringBuffer: 'StringBuffer') -> bool: ...
    @classmethod
    @typing.overload
    def copyValueOf(cls, charArray: typing.List[str]) -> 'String': ...
    @classmethod
    @typing.overload
    def copyValueOf(cls, charArray: typing.List[str], int: int, int2: int) -> 'String': ...
    def endsWith(self, string: 'String') -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def equalsIgnoreCase(self, string: 'String') -> bool: ...
    @classmethod
    @typing.overload
    def format(cls, string: 'String', objectArray: typing.List[typing.Any]) -> 'String': ...
    @classmethod
    @typing.overload
    def format(cls, locale: java.util.Locale, string: 'String', objectArray: typing.List[typing.Any]) -> 'String': ...
    @typing.overload
    def getBytes(self) -> typing.List[int]: ...
    @typing.overload
    def getBytes(self, string: 'String') -> typing.List[int]: ...
    @typing.overload
    def getBytes(self, charset: java.nio.charset.Charset) -> typing.List[int]: ...
    @typing.overload
    def getBytes(self, int: int, int2: int, byteArray: typing.List[int], int3: int) -> None: ...
    def getChars(self, int: int, int2: int, charArray: typing.List[str], int3: int) -> None: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, int: int) -> int: ...
    @typing.overload
    def indexOf(self, int: int, int2: int) -> int: ...
    @typing.overload
    def indexOf(self, string: 'String') -> int: ...
    @typing.overload
    def indexOf(self, string: 'String', int: int) -> int: ...
    def intern(self) -> 'String': ...
    def isBlank(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    @classmethod
    @typing.overload
    def join(cls, charSequence: CharSequence, charSequenceArray: typing.List[CharSequence]) -> 'String': ...
    @classmethod
    @typing.overload
    def join(cls, charSequence: CharSequence, iterable: Iterable[CharSequence]) -> 'String': ...
    @typing.overload
    def lastIndexOf(self, int: int) -> int: ...
    @typing.overload
    def lastIndexOf(self, int: int, int2: int) -> int: ...
    @typing.overload
    def lastIndexOf(self, string: 'String') -> int: ...
    @typing.overload
    def lastIndexOf(self, string: 'String', int: int) -> int: ...
    def length(self) -> int: ...
    def lines(self) -> java.util.stream.Stream['String']: ...
    def matches(self, string: 'String') -> bool: ...
    def offsetByCodePoints(self, int: int, int2: int) -> int: ...
    @typing.overload
    def regionMatches(self, boolean: bool, int: int, string: 'String', int2: int, int3: int) -> bool: ...
    @typing.overload
    def regionMatches(self, int: int, string: 'String', int2: int, int3: int) -> bool: ...
    def repeat(self, int: int) -> 'String': ...
    @typing.overload
    def replace(self, char: str, char2: str) -> 'String': ...
    @typing.overload
    def replace(self, charSequence: CharSequence, charSequence2: CharSequence) -> 'String': ...
    def replaceAll(self, string: 'String', string2: 'String') -> 'String': ...
    def replaceFirst(self, string: 'String', string2: 'String') -> 'String': ...
    @typing.overload
    def split(self, string: 'String') -> typing.List['String']: ...
    @typing.overload
    def split(self, string: 'String', int: int) -> typing.List['String']: ...
    @typing.overload
    def startsWith(self, string: 'String') -> bool: ...
    @typing.overload
    def startsWith(self, string: 'String', int: int) -> bool: ...
    def strip(self) -> 'String': ...
    def stripLeading(self) -> 'String': ...
    def stripTrailing(self) -> 'String': ...
    def subSequence(self, int: int, int2: int) -> CharSequence: ...
    @typing.overload
    def substring(self, int: int) -> 'String': ...
    @typing.overload
    def substring(self, int: int, int2: int) -> 'String': ...
    def toCharArray(self) -> typing.List[str]: ...
    @typing.overload
    def toLowerCase(self) -> 'String': ...
    @typing.overload
    def toLowerCase(self, locale: java.util.Locale) -> 'String': ...
    def toString(self) -> 'String': ...
    @typing.overload
    def toUpperCase(self) -> 'String': ...
    @typing.overload
    def toUpperCase(self, locale: java.util.Locale) -> 'String': ...
    def trim(self) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, boolean: bool) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, char: str) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, charArray: typing.List[str]) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, charArray: typing.List[str], int: int, int2: int) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, double: float) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, float: float) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, int: int) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, object: typing.Any) -> 'String': ...
    @classmethod
    @typing.overload
    def valueOf(cls, long: int) -> 'String': ...

class ThreadDeath(Error):
    """
    Java class 'java.lang.ThreadDeath'
    
        Extends:
            java.lang.Error
    
      Constructors:
        * ThreadDeath()
    
    """
    def __init__(self): ...

class VirtualMachineError(Error):
    """
    Java class 'java.lang.VirtualMachineError'
    
        Extends:
            java.lang.Error
    
      Constructors:
        * VirtualMachineError(java.lang.Throwable)
        * VirtualMachineError(java.lang.String, java.lang.Throwable)
        * VirtualMachineError(java.lang.String)
        * VirtualMachineError()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class ArithmeticException(RuntimeException):
    """
    Java class 'java.lang.ArithmeticException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ArithmeticException()
        * ArithmeticException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ArrayStoreException(RuntimeException):
    """
    Java class 'java.lang.ArrayStoreException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ArrayStoreException()
        * ArrayStoreException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class BootstrapMethodError(LinkageError):
    """
    Java class 'java.lang.BootstrapMethodError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * BootstrapMethodError(java.lang.Throwable)
        * BootstrapMethodError(java.lang.String, java.lang.Throwable)
        * BootstrapMethodError(java.lang.String)
        * BootstrapMethodError()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class ClassCastException(RuntimeException):
    """
    Java class 'java.lang.ClassCastException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ClassCastException()
        * ClassCastException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ClassCircularityError(LinkageError):
    """
    Java class 'java.lang.ClassCircularityError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * ClassCircularityError()
        * ClassCircularityError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ClassFormatError(LinkageError):
    """
    Java class 'java.lang.ClassFormatError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * ClassFormatError()
        * ClassFormatError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ClassNotFoundException(ReflectiveOperationException):
    """
    Java class 'java.lang.ClassNotFoundException'
    
        Extends:
            java.lang.ReflectiveOperationException
    
      Constructors:
        * ClassNotFoundException(java.lang.String, java.lang.Throwable)
        * ClassNotFoundException(java.lang.String)
        * ClassNotFoundException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    def getCause(self) -> Throwable: ...
    def getException(self) -> Throwable: ...

class EnumConstantNotPresentException(RuntimeException):
    """
    Java class 'java.lang.EnumConstantNotPresentException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * EnumConstantNotPresentException(java.lang.Class, java.lang.String)
    
    """
    def __init__(self, class_: typing.Type[Enum], string: String): ...
    def constantName(self) -> String: ...
    def enumType(self) -> typing.Type[Enum]: ...

class ExceptionInInitializerError(LinkageError):
    """
    Java class 'java.lang.ExceptionInInitializerError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * ExceptionInInitializerError(java.lang.String)
        * ExceptionInInitializerError(java.lang.Throwable)
        * ExceptionInInitializerError()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...
    def getCause(self) -> Throwable: ...
    def getException(self) -> Throwable: ...

class IllegalAccessException(ReflectiveOperationException):
    """
    Java class 'java.lang.IllegalAccessException'
    
        Extends:
            java.lang.ReflectiveOperationException
    
      Constructors:
        * IllegalAccessException()
        * IllegalAccessException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class IllegalArgumentException(RuntimeException):
    """
    Java class 'java.lang.IllegalArgumentException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IllegalArgumentException(java.lang.Throwable)
        * IllegalArgumentException(java.lang.String, java.lang.Throwable)
        * IllegalArgumentException(java.lang.String)
        * IllegalArgumentException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class IllegalCallerException(RuntimeException):
    """
    Java class 'java.lang.IllegalCallerException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IllegalCallerException(java.lang.Throwable)
        * IllegalCallerException(java.lang.String, java.lang.Throwable)
        * IllegalCallerException(java.lang.String)
        * IllegalCallerException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class IllegalMonitorStateException(RuntimeException):
    """
    Java class 'java.lang.IllegalMonitorStateException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IllegalMonitorStateException()
        * IllegalMonitorStateException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class IllegalStateException(RuntimeException):
    """
    Java class 'java.lang.IllegalStateException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IllegalStateException(java.lang.Throwable)
        * IllegalStateException(java.lang.String, java.lang.Throwable)
        * IllegalStateException(java.lang.String)
        * IllegalStateException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class IncompatibleClassChangeError(LinkageError):
    """
    Java class 'java.lang.IncompatibleClassChangeError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * IncompatibleClassChangeError()
        * IncompatibleClassChangeError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class IndexOutOfBoundsException(RuntimeException):
    """
    Java class 'java.lang.IndexOutOfBoundsException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IndexOutOfBoundsException()
        * IndexOutOfBoundsException(java.lang.String)
        * IndexOutOfBoundsException(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: String): ...

class InstantiationException(ReflectiveOperationException):
    """
    Java class 'java.lang.InstantiationException'
    
        Extends:
            java.lang.ReflectiveOperationException
    
      Constructors:
        * InstantiationException()
        * InstantiationException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class InternalError(VirtualMachineError):
    """
    Java class 'java.lang.InternalError'
    
        Extends:
            java.lang.VirtualMachineError
    
      Constructors:
        * InternalError(java.lang.Throwable)
        * InternalError(java.lang.String, java.lang.Throwable)
        * InternalError(java.lang.String)
        * InternalError()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class LayerInstantiationException(RuntimeException):
    """
    Java class 'java.lang.LayerInstantiationException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * LayerInstantiationException(java.lang.String, java.lang.Throwable)
        * LayerInstantiationException(java.lang.Throwable)
        * LayerInstantiationException(java.lang.String)
        * LayerInstantiationException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class NegativeArraySizeException(RuntimeException):
    """
    Java class 'java.lang.NegativeArraySizeException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * NegativeArraySizeException()
        * NegativeArraySizeException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NoClassDefFoundError(LinkageError):
    """
    Java class 'java.lang.NoClassDefFoundError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * NoClassDefFoundError()
        * NoClassDefFoundError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NoSuchFieldException(ReflectiveOperationException):
    """
    Java class 'java.lang.NoSuchFieldException'
    
        Extends:
            java.lang.ReflectiveOperationException
    
      Constructors:
        * NoSuchFieldException()
        * NoSuchFieldException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NoSuchMethodException(ReflectiveOperationException):
    """
    Java class 'java.lang.NoSuchMethodException'
    
        Extends:
            java.lang.ReflectiveOperationException
    
      Constructors:
        * NoSuchMethodException()
        * NoSuchMethodException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NullPointerException(RuntimeException):
    """
    Java class 'java.lang.NullPointerException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * NullPointerException()
        * NullPointerException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class OutOfMemoryError(VirtualMachineError):
    """
    Java class 'java.lang.OutOfMemoryError'
    
        Extends:
            java.lang.VirtualMachineError
    
      Constructors:
        * OutOfMemoryError()
        * OutOfMemoryError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ProcessBuilder(Object):
    """
    Java class 'java.lang.ProcessBuilder'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ProcessBuilder(java.util.List)
        * ProcessBuilder(java.lang.String[])
    
    """
    @typing.overload
    def __init__(self, stringArray: typing.List[String]): ...
    @typing.overload
    def __init__(self, list: java.util.List[String]): ...
    @typing.overload
    def command(self, stringArray: typing.List[String]) -> 'ProcessBuilder': ...
    @typing.overload
    def command(self, list: java.util.List[String]) -> 'ProcessBuilder': ...
    @typing.overload
    def command(self) -> java.util.List[String]: ...
    @typing.overload
    def directory(self) -> java.io.File: ...
    @typing.overload
    def directory(self, file: java.io.File) -> 'ProcessBuilder': ...
    def environment(self) -> java.util.Map[String, String]: ...
    def inheritIO(self) -> 'ProcessBuilder': ...
    @typing.overload
    def redirectError(self, file: java.io.File) -> 'ProcessBuilder': ...
    @typing.overload
    def redirectError(self, redirect: 'ProcessBuilder.Redirect') -> 'ProcessBuilder': ...
    @typing.overload
    def redirectError(self) -> 'ProcessBuilder.Redirect': ...
    @typing.overload
    def redirectErrorStream(self) -> bool: ...
    @typing.overload
    def redirectErrorStream(self, boolean: bool) -> 'ProcessBuilder': ...
    @typing.overload
    def redirectInput(self, file: java.io.File) -> 'ProcessBuilder': ...
    @typing.overload
    def redirectInput(self, redirect: 'ProcessBuilder.Redirect') -> 'ProcessBuilder': ...
    @typing.overload
    def redirectInput(self) -> 'ProcessBuilder.Redirect': ...
    @typing.overload
    def redirectOutput(self, file: java.io.File) -> 'ProcessBuilder': ...
    @typing.overload
    def redirectOutput(self, redirect: 'ProcessBuilder.Redirect') -> 'ProcessBuilder': ...
    @typing.overload
    def redirectOutput(self) -> 'ProcessBuilder.Redirect': ...
    def start(self) -> Process: ...
    @classmethod
    def startPipeline(cls, list: java.util.List['ProcessBuilder']) -> java.util.List[Process]: ...
    class Redirect(Object):
        """
        Java class 'java.lang.ProcessBuilder$Redirect'
        
            Extends:
                java.lang.Object
        
          Attributes:
            PIPE (java.lang.ProcessBuilder$Redirect): final static field
            INHERIT (java.lang.ProcessBuilder$Redirect): final static field
            DISCARD (java.lang.ProcessBuilder$Redirect): final static field
        
        """
        PIPE: typing.ClassVar['ProcessBuilder.Redirect'] = ...
        INHERIT: typing.ClassVar['ProcessBuilder.Redirect'] = ...
        DISCARD: typing.ClassVar['ProcessBuilder.Redirect'] = ...
        @classmethod
        def appendTo(cls, file: java.io.File) -> 'ProcessBuilder.Redirect': ...
        def equals(self, object: typing.Any) -> bool: ...
        def file(self) -> java.io.File: ...
        def hashCode(self) -> int: ...
        @classmethod
        def to(cls, file: java.io.File) -> 'ProcessBuilder.Redirect': ...
        def type(self) -> 'ProcessBuilder.Redirect.Type': ...
        class Type(Enum[java.lang.ProcessBuilder.Redirect.Type]):
            """
            Java class 'java.lang.ProcessBuilder$Redirect$Type'
            
                Extends:
                    java.lang.Enum
            
              Attributes:
                PIPE (java.lang.ProcessBuilder$Redirect$Type): final static enum constant
                INHERIT (java.lang.ProcessBuilder$Redirect$Type): final static enum constant
                READ (java.lang.ProcessBuilder$Redirect$Type): final static enum constant
                WRITE (java.lang.ProcessBuilder$Redirect$Type): final static enum constant
                APPEND (java.lang.ProcessBuilder$Redirect$Type): final static enum constant
            
            """
            PIPE: typing.ClassVar['ProcessBuilder.Redirect.Type'] = ...
            INHERIT: typing.ClassVar['ProcessBuilder.Redirect.Type'] = ...
            READ: typing.ClassVar['ProcessBuilder.Redirect.Type'] = ...
            WRITE: typing.ClassVar['ProcessBuilder.Redirect.Type'] = ...
            APPEND: typing.ClassVar['ProcessBuilder.Redirect.Type'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=Enum)  # <T>
            @classmethod
            @typing.overload
            def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: String) -> _valueOf_0__T: ...
            @classmethod
            @typing.overload
            def valueOf(cls, string: String) -> 'ProcessBuilder.Redirect.Type': ...
            @classmethod
            def values(cls) -> typing.List['ProcessBuilder.Redirect.Type']: ...

class SecurityException(RuntimeException):
    """
    Java class 'java.lang.SecurityException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * SecurityException(java.lang.Throwable)
        * SecurityException(java.lang.String, java.lang.Throwable)
        * SecurityException(java.lang.String)
        * SecurityException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class StackOverflowError(VirtualMachineError):
    """
    Java class 'java.lang.StackOverflowError'
    
        Extends:
            java.lang.VirtualMachineError
    
      Constructors:
        * StackOverflowError()
        * StackOverflowError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class StackWalker(Object):
    """
    Java class 'java.lang.StackWalker'
    
        Extends:
            java.lang.Object
    
    """
    def forEach(self, consumer: typing.Union[java.util.function.Consumer['StackWalker.StackFrame'], typing.Callable[[], 'StackWalker.StackFrame']]) -> None: ...
    def getCallerClass(self) -> typing.Type[typing.Any]: ...
    @classmethod
    @typing.overload
    def getInstance(cls) -> 'StackWalker': ...
    @classmethod
    @typing.overload
    def getInstance(cls, option: 'StackWalker.Option') -> 'StackWalker': ...
    @classmethod
    @typing.overload
    def getInstance(cls, set: java.util.Set['StackWalker.Option']) -> 'StackWalker': ...
    @classmethod
    @typing.overload
    def getInstance(cls, set: java.util.Set['StackWalker.Option'], int: int) -> 'StackWalker': ...
    _walk__T = typing.TypeVar('_walk__T')  # <T>
    def walk(self, function: typing.Union[java.util.function.Function[java.util.stream.Stream['StackWalker.StackFrame'], _walk__T], typing.Callable[[java.util.stream.Stream['StackWalker.StackFrame']], _walk__T]]) -> _walk__T: ...
    class Option(Enum[java.lang.StackWalker.Option]):
        """
        Java class 'java.lang.StackWalker$Option'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            RETAIN_CLASS_REFERENCE (java.lang.StackWalker$Option): final static enum constant
            SHOW_REFLECT_FRAMES (java.lang.StackWalker$Option): final static enum constant
            SHOW_HIDDEN_FRAMES (java.lang.StackWalker$Option): final static enum constant
        
        """
        RETAIN_CLASS_REFERENCE: typing.ClassVar['StackWalker.Option'] = ...
        SHOW_REFLECT_FRAMES: typing.ClassVar['StackWalker.Option'] = ...
        SHOW_HIDDEN_FRAMES: typing.ClassVar['StackWalker.Option'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: String) -> 'StackWalker.Option': ...
        @classmethod
        def values(cls) -> typing.List['StackWalker.Option']: ...
    class StackFrame(Object):
        """
        Java class 'java.lang.StackWalker$StackFrame'
        
        """
        def getByteCodeIndex(self) -> int: ...
        def getClassName(self) -> String: ...
        def getDeclaringClass(self) -> typing.Type[typing.Any]: ...
        def getDescriptor(self) -> String: ...
        def getFileName(self) -> String: ...
        def getLineNumber(self) -> int: ...
        def getMethodName(self) -> String: ...
        def getMethodType(self) -> java.lang.invoke.MethodType: ...
        def isNativeMethod(self) -> bool: ...
        def toStackTraceElement(self) -> StackTraceElement: ...

class System(Object):
    """
    Java class 'java.lang.System'
    
        Extends:
            java.lang.Object
    
      Attributes:
        in (java.io.InputStream): final static field
        out (java.io.PrintStream): final static field
        err (java.io.PrintStream): final static field
    
    """
    in_: typing.ClassVar[java.io.InputStream] = ...
    out: typing.ClassVar[java.io.PrintStream] = ...
    err: typing.ClassVar[java.io.PrintStream] = ...
    @classmethod
    def arraycopy(cls, object: typing.Any, int: int, object2: typing.Any, int2: int, int3: int) -> None: ...
    @classmethod
    def clearProperty(cls, string: String) -> String: ...
    @classmethod
    def console(cls) -> java.io.Console: ...
    @classmethod
    def currentTimeMillis(cls) -> int: ...
    @classmethod
    def exit(cls, int: int) -> None: ...
    @classmethod
    def gc(cls) -> None: ...
    @classmethod
    @typing.overload
    def getLogger(cls, string: String) -> 'System.Logger': ...
    @classmethod
    @typing.overload
    def getLogger(cls, string: String, resourceBundle: java.util.ResourceBundle) -> 'System.Logger': ...
    @classmethod
    def getProperties(cls) -> java.util.Properties: ...
    @classmethod
    @typing.overload
    def getProperty(cls, string: String) -> String: ...
    @classmethod
    @typing.overload
    def getProperty(cls, string: String, string2: String) -> String: ...
    @classmethod
    def getSecurityManager(cls) -> SecurityManager: ...
    @classmethod
    @typing.overload
    def getenv(cls, string: String) -> String: ...
    @classmethod
    @typing.overload
    def getenv(cls) -> java.util.Map[String, String]: ...
    @classmethod
    def identityHashCode(cls, object: typing.Any) -> int: ...
    @classmethod
    def inheritedChannel(cls) -> java.nio.channels.Channel: ...
    @classmethod
    def lineSeparator(cls) -> String: ...
    @classmethod
    def load(cls, string: String) -> None: ...
    @classmethod
    def loadLibrary(cls, string: String) -> None: ...
    @classmethod
    def mapLibraryName(cls, string: String) -> String: ...
    @classmethod
    def nanoTime(cls) -> int: ...
    @classmethod
    def runFinalization(cls) -> None: ...
    @classmethod
    def setErr(cls, printStream: java.io.PrintStream) -> None: ...
    @classmethod
    def setIn(cls, inputStream: java.io.InputStream) -> None: ...
    @classmethod
    def setOut(cls, printStream: java.io.PrintStream) -> None: ...
    @classmethod
    def setProperties(cls, properties: java.util.Properties) -> None: ...
    @classmethod
    def setProperty(cls, string: String, string2: String) -> String: ...
    @classmethod
    def setSecurityManager(cls, securityManager: SecurityManager) -> None: ...
    class Logger(Object):
        """
        Java class 'java.lang.System$Logger'
        
        """
        def getName(self) -> String: ...
        def isLoggable(self, level: 'System.Logger.Level') -> bool: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', resourceBundle: java.util.ResourceBundle, string: String, objectArray: typing.List[typing.Any]) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', resourceBundle: java.util.ResourceBundle, string: String, throwable: Throwable) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', object: typing.Any) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', string: String) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', string: String, objectArray: typing.List[typing.Any]) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', string: String, throwable: Throwable) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', supplier: typing.Union[java.util.function.Supplier[String], typing.Callable[[], String]]) -> None: ...
        @typing.overload
        def log(self, level: 'System.Logger.Level', supplier: typing.Union[java.util.function.Supplier[String], typing.Callable[[], String]], throwable: Throwable) -> None: ...
        class Level(Enum[java.lang.System.Logger.Level]):
            """
            Java class 'java.lang.System$Logger$Level'
            
                Extends:
                    java.lang.Enum
            
              Attributes:
                ALL (java.lang.System$Logger$Level): final static enum constant
                TRACE (java.lang.System$Logger$Level): final static enum constant
                DEBUG (java.lang.System$Logger$Level): final static enum constant
                INFO (java.lang.System$Logger$Level): final static enum constant
                WARNING (java.lang.System$Logger$Level): final static enum constant
                ERROR (java.lang.System$Logger$Level): final static enum constant
                OFF (java.lang.System$Logger$Level): final static enum constant
            
            """
            ALL: typing.ClassVar['System.Logger.Level'] = ...
            TRACE: typing.ClassVar['System.Logger.Level'] = ...
            DEBUG: typing.ClassVar['System.Logger.Level'] = ...
            INFO: typing.ClassVar['System.Logger.Level'] = ...
            WARNING: typing.ClassVar['System.Logger.Level'] = ...
            ERROR: typing.ClassVar['System.Logger.Level'] = ...
            OFF: typing.ClassVar['System.Logger.Level'] = ...
            def getName(self) -> String: ...
            def getSeverity(self) -> int: ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=Enum)  # <T>
            @classmethod
            @typing.overload
            def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: String) -> _valueOf_0__T: ...
            @classmethod
            @typing.overload
            def valueOf(cls, string: String) -> 'System.Logger.Level': ...
            @classmethod
            def values(cls) -> typing.List['System.Logger.Level']: ...
    class LoggerFinder(Object):
        """
        Java class 'java.lang.System$LoggerFinder'
        
            Extends:
                java.lang.Object
        
        """
        def getLocalizedLogger(self, string: String, resourceBundle: java.util.ResourceBundle, module: Module) -> 'System.Logger': ...
        def getLogger(self, string: String, module: Module) -> 'System.Logger': ...
        @classmethod
        def getLoggerFinder(cls) -> 'System.LoggerFinder': ...

class Thread(Runnable):
    """
    Java class 'java.lang.Thread'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Runnable
    
      Constructors:
        * Thread(java.lang.ThreadGroup, java.lang.String)
        * Thread(java.lang.String)
        * Thread(java.lang.ThreadGroup, java.lang.Runnable)
        * Thread(java.lang.Runnable)
        * Thread()
        * Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long, boolean)
        * Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)
        * Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)
        * Thread(java.lang.Runnable, java.lang.String)
    
      Attributes:
        MIN_PRIORITY (int): final static field
        NORM_PRIORITY (int): final static field
        MAX_PRIORITY (int): final static field
    
    """
    MIN_PRIORITY: typing.ClassVar[int] = ...
    NORM_PRIORITY: typing.ClassVar[int] = ...
    MAX_PRIORITY: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, runnable: Runnable): ...
    @typing.overload
    def __init__(self, runnable: Runnable, string: String): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', runnable: Runnable): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', runnable: Runnable, string: String): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', runnable: Runnable, string: String, long: int): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', runnable: Runnable, string: String, long: int, boolean: bool): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', string: String): ...
    @classmethod
    def activeCount(cls) -> int: ...
    def checkAccess(self) -> None: ...
    def countStackFrames(self) -> int: ...
    @classmethod
    def currentThread(cls) -> 'Thread': ...
    @classmethod
    def dumpStack(cls) -> None: ...
    @classmethod
    def enumerate(cls, threadArray: typing.List['Thread']) -> int: ...
    @classmethod
    def getAllStackTraces(cls) -> java.util.Map['Thread', typing.List[StackTraceElement]]: ...
    def getContextClassLoader(self) -> ClassLoader: ...
    @classmethod
    def getDefaultUncaughtExceptionHandler(cls) -> 'Thread.UncaughtExceptionHandler': ...
    def getId(self) -> int: ...
    def getName(self) -> String: ...
    def getPriority(self) -> int: ...
    def getStackTrace(self) -> typing.List[StackTraceElement]: ...
    def getState(self) -> 'Thread.State': ...
    def getThreadGroup(self) -> 'ThreadGroup': ...
    def getUncaughtExceptionHandler(self) -> 'Thread.UncaughtExceptionHandler': ...
    @classmethod
    def holdsLock(cls, object: typing.Any) -> bool: ...
    def interrupt(self) -> None: ...
    @classmethod
    def interrupted(cls) -> bool: ...
    def isAlive(self) -> bool: ...
    def isDaemon(self) -> bool: ...
    def isInterrupted(self) -> bool: ...
    @typing.overload
    def join(self, long: int) -> None: ...
    @typing.overload
    def join(self, long: int, int: int) -> None: ...
    @typing.overload
    def join(self) -> None: ...
    @classmethod
    def onSpinWait(cls) -> None: ...
    def resume(self) -> None: ...
    def run(self) -> None: ...
    def setContextClassLoader(self, classLoader: ClassLoader) -> None: ...
    def setDaemon(self, boolean: bool) -> None: ...
    @classmethod
    def setDefaultUncaughtExceptionHandler(cls, uncaughtExceptionHandler: 'Thread.UncaughtExceptionHandler') -> None: ...
    def setName(self, string: String) -> None: ...
    def setPriority(self, int: int) -> None: ...
    def setUncaughtExceptionHandler(self, uncaughtExceptionHandler: 'Thread.UncaughtExceptionHandler') -> None: ...
    @classmethod
    @typing.overload
    def sleep(cls, long: int) -> None: ...
    @classmethod
    @typing.overload
    def sleep(cls, long: int, int: int) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def suspend(self) -> None: ...
    def toString(self) -> String: ...
    class State(Enum[java.lang.Thread.State]):
        """
        Java class 'java.lang.Thread$State'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            NEW (java.lang.Thread$State): final static enum constant
            RUNNABLE (java.lang.Thread$State): final static enum constant
            BLOCKED (java.lang.Thread$State): final static enum constant
            WAITING (java.lang.Thread$State): final static enum constant
            TIMED_WAITING (java.lang.Thread$State): final static enum constant
            TERMINATED (java.lang.Thread$State): final static enum constant
        
        """
        NEW: typing.ClassVar['Thread.State'] = ...
        RUNNABLE: typing.ClassVar['Thread.State'] = ...
        BLOCKED: typing.ClassVar['Thread.State'] = ...
        WAITING: typing.ClassVar['Thread.State'] = ...
        TIMED_WAITING: typing.ClassVar['Thread.State'] = ...
        TERMINATED: typing.ClassVar['Thread.State'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: String) -> 'Thread.State': ...
        @classmethod
        def values(cls) -> typing.List['Thread.State']: ...
    class UncaughtExceptionHandler(Object):
        """
        Java class 'java.lang.Thread$UncaughtExceptionHandler'
        
        """
        def uncaughtException(self, thread: 'Thread', throwable: Throwable) -> None: ...

class TypeNotPresentException(RuntimeException):
    """
    Java class 'java.lang.TypeNotPresentException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * TypeNotPresentException(java.lang.String, java.lang.Throwable)
    
    """
    def __init__(self, string: String, throwable: Throwable): ...
    def typeName(self) -> String: ...

class UnknownError(VirtualMachineError):
    """
    Java class 'java.lang.UnknownError'
    
        Extends:
            java.lang.VirtualMachineError
    
      Constructors:
        * UnknownError()
        * UnknownError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class UnsatisfiedLinkError(LinkageError):
    """
    Java class 'java.lang.UnsatisfiedLinkError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * UnsatisfiedLinkError()
        * UnsatisfiedLinkError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class UnsupportedOperationException(RuntimeException):
    """
    Java class 'java.lang.UnsupportedOperationException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * UnsupportedOperationException(java.lang.Throwable)
        * UnsupportedOperationException(java.lang.String, java.lang.Throwable)
        * UnsupportedOperationException(java.lang.String)
        * UnsupportedOperationException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, string: String, throwable: Throwable): ...
    @typing.overload
    def __init__(self, throwable: Throwable): ...

class VerifyError(LinkageError):
    """
    Java class 'java.lang.VerifyError'
    
        Extends:
            java.lang.LinkageError
    
      Constructors:
        * VerifyError()
        * VerifyError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class AbstractMethodError(IncompatibleClassChangeError):
    """
    Java class 'java.lang.AbstractMethodError'
    
        Extends:
            java.lang.IncompatibleClassChangeError
    
      Constructors:
        * AbstractMethodError()
        * AbstractMethodError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class ArrayIndexOutOfBoundsException(IndexOutOfBoundsException):
    """
    Java class 'java.lang.ArrayIndexOutOfBoundsException'
    
        Extends:
            java.lang.IndexOutOfBoundsException
    
      Constructors:
        * ArrayIndexOutOfBoundsException()
        * ArrayIndexOutOfBoundsException(java.lang.String)
        * ArrayIndexOutOfBoundsException(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: String): ...

class IllegalAccessError(IncompatibleClassChangeError):
    """
    Java class 'java.lang.IllegalAccessError'
    
        Extends:
            java.lang.IncompatibleClassChangeError
    
      Constructors:
        * IllegalAccessError()
        * IllegalAccessError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class IllegalThreadStateException(IllegalArgumentException):
    """
    Java class 'java.lang.IllegalThreadStateException'
    
        Extends:
            java.lang.IllegalArgumentException
    
      Constructors:
        * IllegalThreadStateException()
        * IllegalThreadStateException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class InstantiationError(IncompatibleClassChangeError):
    """
    Java class 'java.lang.InstantiationError'
    
        Extends:
            java.lang.IncompatibleClassChangeError
    
      Constructors:
        * InstantiationError()
        * InstantiationError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NoSuchFieldError(IncompatibleClassChangeError):
    """
    Java class 'java.lang.NoSuchFieldError'
    
        Extends:
            java.lang.IncompatibleClassChangeError
    
      Constructors:
        * NoSuchFieldError()
        * NoSuchFieldError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NoSuchMethodError(IncompatibleClassChangeError):
    """
    Java class 'java.lang.NoSuchMethodError'
    
        Extends:
            java.lang.IncompatibleClassChangeError
    
      Constructors:
        * NoSuchMethodError()
        * NoSuchMethodError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class NumberFormatException(IllegalArgumentException):
    """
    Java class 'java.lang.NumberFormatException'
    
        Extends:
            java.lang.IllegalArgumentException
    
      Constructors:
        * NumberFormatException()
        * NumberFormatException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class StringIndexOutOfBoundsException(IndexOutOfBoundsException):
    """
    Java class 'java.lang.StringIndexOutOfBoundsException'
    
        Extends:
            java.lang.IndexOutOfBoundsException
    
      Constructors:
        * StringIndexOutOfBoundsException()
        * StringIndexOutOfBoundsException(java.lang.String)
        * StringIndexOutOfBoundsException(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: String): ...

class ThreadGroup(Thread.UncaughtExceptionHandler):
    """
    Java class 'java.lang.ThreadGroup'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Thread.UncaughtExceptionHandler
    
      Constructors:
        * ThreadGroup(java.lang.ThreadGroup, java.lang.String)
        * ThreadGroup(java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def __init__(self, threadGroup: 'ThreadGroup', string: String): ...
    def activeCount(self) -> int: ...
    def activeGroupCount(self) -> int: ...
    def allowThreadSuspension(self, boolean: bool) -> bool: ...
    def checkAccess(self) -> None: ...
    def destroy(self) -> None: ...
    @typing.overload
    def enumerate(self, threadGroupArray: typing.List['ThreadGroup']) -> int: ...
    @typing.overload
    def enumerate(self, threadGroupArray: typing.List['ThreadGroup'], boolean: bool) -> int: ...
    @typing.overload
    def enumerate(self, threadArray: typing.List[Thread]) -> int: ...
    @typing.overload
    def enumerate(self, threadArray: typing.List[Thread], boolean: bool) -> int: ...
    def getMaxPriority(self) -> int: ...
    def getName(self) -> String: ...
    def getParent(self) -> 'ThreadGroup': ...
    def interrupt(self) -> None: ...
    def isDaemon(self) -> bool: ...
    def isDestroyed(self) -> bool: ...
    def list(self) -> None: ...
    def parentOf(self, threadGroup: 'ThreadGroup') -> bool: ...
    def resume(self) -> None: ...
    def setDaemon(self, boolean: bool) -> None: ...
    def setMaxPriority(self, int: int) -> None: ...
    def stop(self) -> None: ...
    def suspend(self) -> None: ...
    def toString(self) -> String: ...
    def uncaughtException(self, thread: Thread, throwable: Throwable) -> None: ...

class UnsupportedClassVersionError(ClassFormatError):
    """
    Java class 'java.lang.UnsupportedClassVersionError'
    
        Extends:
            java.lang.ClassFormatError
    
      Constructors:
        * UnsupportedClassVersionError()
        * UnsupportedClassVersionError(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: String): ...

class Character(java.io.Serializable, Comparable[str]):
    """
    Java class 'java.lang.Character'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable
    
      Constructors:
        * Character(char)
    
      Attributes:
        MIN_RADIX (int): final static field
        MAX_RADIX (int): final static field
        MIN_VALUE (char): final static field
        MAX_VALUE (char): final static field
        TYPE (java.lang.Class): final static field
        UNASSIGNED (byte): final static field
        UPPERCASE_LETTER (byte): final static field
        LOWERCASE_LETTER (byte): final static field
        TITLECASE_LETTER (byte): final static field
        MODIFIER_LETTER (byte): final static field
        OTHER_LETTER (byte): final static field
        NON_SPACING_MARK (byte): final static field
        ENCLOSING_MARK (byte): final static field
        COMBINING_SPACING_MARK (byte): final static field
        DECIMAL_DIGIT_NUMBER (byte): final static field
        LETTER_NUMBER (byte): final static field
        OTHER_NUMBER (byte): final static field
        SPACE_SEPARATOR (byte): final static field
        LINE_SEPARATOR (byte): final static field
        PARAGRAPH_SEPARATOR (byte): final static field
        CONTROL (byte): final static field
        FORMAT (byte): final static field
        PRIVATE_USE (byte): final static field
        SURROGATE (byte): final static field
        DASH_PUNCTUATION (byte): final static field
        START_PUNCTUATION (byte): final static field
        END_PUNCTUATION (byte): final static field
        CONNECTOR_PUNCTUATION (byte): final static field
        OTHER_PUNCTUATION (byte): final static field
        MATH_SYMBOL (byte): final static field
        CURRENCY_SYMBOL (byte): final static field
        MODIFIER_SYMBOL (byte): final static field
        OTHER_SYMBOL (byte): final static field
        INITIAL_QUOTE_PUNCTUATION (byte): final static field
        FINAL_QUOTE_PUNCTUATION (byte): final static field
        DIRECTIONALITY_UNDEFINED (byte): final static field
        DIRECTIONALITY_LEFT_TO_RIGHT (byte): final static field
        DIRECTIONALITY_RIGHT_TO_LEFT (byte): final static field
        DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC (byte): final static field
        DIRECTIONALITY_EUROPEAN_NUMBER (byte): final static field
        DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR (byte): final static field
        DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR (byte): final static field
        DIRECTIONALITY_ARABIC_NUMBER (byte): final static field
        DIRECTIONALITY_COMMON_NUMBER_SEPARATOR (byte): final static field
        DIRECTIONALITY_NONSPACING_MARK (byte): final static field
        DIRECTIONALITY_BOUNDARY_NEUTRAL (byte): final static field
        DIRECTIONALITY_PARAGRAPH_SEPARATOR (byte): final static field
        DIRECTIONALITY_SEGMENT_SEPARATOR (byte): final static field
        DIRECTIONALITY_WHITESPACE (byte): final static field
        DIRECTIONALITY_OTHER_NEUTRALS (byte): final static field
        DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING (byte): final static field
        DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE (byte): final static field
        DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING (byte): final static field
        DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE (byte): final static field
        DIRECTIONALITY_POP_DIRECTIONAL_FORMAT (byte): final static field
        DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE (byte): final static field
        DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE (byte): final static field
        DIRECTIONALITY_FIRST_STRONG_ISOLATE (byte): final static field
        DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE (byte): final static field
        MIN_HIGH_SURROGATE (char): final static field
        MAX_HIGH_SURROGATE (char): final static field
        MIN_LOW_SURROGATE (char): final static field
        MAX_LOW_SURROGATE (char): final static field
        MIN_SURROGATE (char): final static field
        MAX_SURROGATE (char): final static field
        MIN_SUPPLEMENTARY_CODE_POINT (int): final static field
        MIN_CODE_POINT (int): final static field
        MAX_CODE_POINT (int): final static field
        SIZE (int): final static field
        BYTES (int): final static field
    
    """
    MIN_RADIX: typing.ClassVar[int] = ...
    MAX_RADIX: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[str] = ...
    MAX_VALUE: typing.ClassVar[str] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    UNASSIGNED: typing.ClassVar[int] = ...
    UPPERCASE_LETTER: typing.ClassVar[int] = ...
    LOWERCASE_LETTER: typing.ClassVar[int] = ...
    TITLECASE_LETTER: typing.ClassVar[int] = ...
    MODIFIER_LETTER: typing.ClassVar[int] = ...
    OTHER_LETTER: typing.ClassVar[int] = ...
    NON_SPACING_MARK: typing.ClassVar[int] = ...
    ENCLOSING_MARK: typing.ClassVar[int] = ...
    COMBINING_SPACING_MARK: typing.ClassVar[int] = ...
    DECIMAL_DIGIT_NUMBER: typing.ClassVar[int] = ...
    LETTER_NUMBER: typing.ClassVar[int] = ...
    OTHER_NUMBER: typing.ClassVar[int] = ...
    SPACE_SEPARATOR: typing.ClassVar[int] = ...
    LINE_SEPARATOR: typing.ClassVar[int] = ...
    PARAGRAPH_SEPARATOR: typing.ClassVar[int] = ...
    CONTROL: typing.ClassVar[int] = ...
    FORMAT: typing.ClassVar[int] = ...
    PRIVATE_USE: typing.ClassVar[int] = ...
    SURROGATE: typing.ClassVar[int] = ...
    DASH_PUNCTUATION: typing.ClassVar[int] = ...
    START_PUNCTUATION: typing.ClassVar[int] = ...
    END_PUNCTUATION: typing.ClassVar[int] = ...
    CONNECTOR_PUNCTUATION: typing.ClassVar[int] = ...
    OTHER_PUNCTUATION: typing.ClassVar[int] = ...
    MATH_SYMBOL: typing.ClassVar[int] = ...
    CURRENCY_SYMBOL: typing.ClassVar[int] = ...
    MODIFIER_SYMBOL: typing.ClassVar[int] = ...
    OTHER_SYMBOL: typing.ClassVar[int] = ...
    INITIAL_QUOTE_PUNCTUATION: typing.ClassVar[int] = ...
    FINAL_QUOTE_PUNCTUATION: typing.ClassVar[int] = ...
    DIRECTIONALITY_UNDEFINED: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_ARABIC_NUMBER: typing.ClassVar[int] = ...
    DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_NONSPACING_MARK: typing.ClassVar[int] = ...
    DIRECTIONALITY_BOUNDARY_NEUTRAL: typing.ClassVar[int] = ...
    DIRECTIONALITY_PARAGRAPH_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_SEGMENT_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_WHITESPACE: typing.ClassVar[int] = ...
    DIRECTIONALITY_OTHER_NEUTRALS: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: typing.ClassVar[int] = ...
    DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_FIRST_STRONG_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE: typing.ClassVar[int] = ...
    MIN_HIGH_SURROGATE: typing.ClassVar[str] = ...
    MAX_HIGH_SURROGATE: typing.ClassVar[str] = ...
    MIN_LOW_SURROGATE: typing.ClassVar[str] = ...
    MAX_LOW_SURROGATE: typing.ClassVar[str] = ...
    MIN_SURROGATE: typing.ClassVar[str] = ...
    MAX_SURROGATE: typing.ClassVar[str] = ...
    MIN_SUPPLEMENTARY_CODE_POINT: typing.ClassVar[int] = ...
    MIN_CODE_POINT: typing.ClassVar[int] = ...
    MAX_CODE_POINT: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    BYTES: typing.ClassVar[int] = ...
    def __init__(self, char: str): ...
    @classmethod
    def charCount(cls, int: int) -> int: ...
    def charValue(self) -> str: ...
    @classmethod
    @typing.overload
    def codePointAt(cls, charArray: typing.List[str], int: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointAt(cls, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointAt(cls, charSequence: CharSequence, int: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointBefore(cls, charArray: typing.List[str], int: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointBefore(cls, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointBefore(cls, charSequence: CharSequence, int: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointCount(cls, charArray: typing.List[str], int: int, int2: int) -> int: ...
    @classmethod
    @typing.overload
    def codePointCount(cls, charSequence: CharSequence, int: int, int2: int) -> int: ...
    @classmethod
    def codePointOf(cls, string: String) -> int: ...
    @classmethod
    def compare(cls, char: str, char2: str) -> int: ...
    @typing.overload
    def compareTo(self, character: str) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @classmethod
    @typing.overload
    def digit(cls, char: str, int: int) -> int: ...
    @classmethod
    @typing.overload
    def digit(cls, int: int, int2: int) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def forDigit(cls, int: int, int2: int) -> str: ...
    @classmethod
    @typing.overload
    def getDirectionality(cls, char: str) -> int: ...
    @classmethod
    @typing.overload
    def getDirectionality(cls, int: int) -> int: ...
    @classmethod
    def getName(cls, int: int) -> String: ...
    @classmethod
    @typing.overload
    def getNumericValue(cls, char: str) -> int: ...
    @classmethod
    @typing.overload
    def getNumericValue(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def getType(cls, char: str) -> int: ...
    @classmethod
    @typing.overload
    def getType(cls, int: int) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, char: str) -> int: ...
    @classmethod
    def highSurrogate(cls, int: int) -> str: ...
    @classmethod
    def isAlphabetic(cls, int: int) -> bool: ...
    @classmethod
    def isBmpCodePoint(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isDefined(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isDefined(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isDigit(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isDigit(cls, int: int) -> bool: ...
    @classmethod
    def isHighSurrogate(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isISOControl(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isISOControl(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isIdentifierIgnorable(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isIdentifierIgnorable(cls, int: int) -> bool: ...
    @classmethod
    def isIdeographic(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isJavaIdentifierPart(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isJavaIdentifierPart(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isJavaIdentifierStart(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isJavaIdentifierStart(cls, int: int) -> bool: ...
    @classmethod
    def isJavaLetter(cls, char: str) -> bool: ...
    @classmethod
    def isJavaLetterOrDigit(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isLetter(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isLetter(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isLetterOrDigit(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isLetterOrDigit(cls, int: int) -> bool: ...
    @classmethod
    def isLowSurrogate(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isLowerCase(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isLowerCase(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isMirrored(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isMirrored(cls, int: int) -> bool: ...
    @classmethod
    def isSpace(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isSpaceChar(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isSpaceChar(cls, int: int) -> bool: ...
    @classmethod
    def isSupplementaryCodePoint(cls, int: int) -> bool: ...
    @classmethod
    def isSurrogate(cls, char: str) -> bool: ...
    @classmethod
    def isSurrogatePair(cls, char: str, char2: str) -> bool: ...
    @classmethod
    @typing.overload
    def isTitleCase(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isTitleCase(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isUnicodeIdentifierPart(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isUnicodeIdentifierPart(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isUnicodeIdentifierStart(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isUnicodeIdentifierStart(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isUpperCase(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isUpperCase(cls, int: int) -> bool: ...
    @classmethod
    def isValidCodePoint(cls, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def isWhitespace(cls, char: str) -> bool: ...
    @classmethod
    @typing.overload
    def isWhitespace(cls, int: int) -> bool: ...
    @classmethod
    def lowSurrogate(cls, int: int) -> str: ...
    @classmethod
    @typing.overload
    def offsetByCodePoints(cls, charArray: typing.List[str], int: int, int2: int, int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def offsetByCodePoints(cls, charSequence: CharSequence, int: int, int2: int) -> int: ...
    @classmethod
    def reverseBytes(cls, char: str) -> str: ...
    @classmethod
    @typing.overload
    def toChars(cls, int: int) -> typing.List[str]: ...
    @classmethod
    @typing.overload
    def toChars(cls, int: int, charArray: typing.List[str], int2: int) -> int: ...
    @classmethod
    def toCodePoint(cls, char: str, char2: str) -> int: ...
    @classmethod
    @typing.overload
    def toLowerCase(cls, char: str) -> str: ...
    @classmethod
    @typing.overload
    def toLowerCase(cls, int: int) -> int: ...
    @typing.overload
    def toString(self) -> String: ...
    @classmethod
    @typing.overload
    def toString(cls, char: str) -> String: ...
    @classmethod
    @typing.overload
    def toString(cls, int: int) -> String: ...
    @classmethod
    @typing.overload
    def toTitleCase(cls, char: str) -> str: ...
    @classmethod
    @typing.overload
    def toTitleCase(cls, int: int) -> int: ...
    @classmethod
    @typing.overload
    def toUpperCase(cls, char: str) -> str: ...
    @classmethod
    @typing.overload
    def toUpperCase(cls, int: int) -> int: ...
    @classmethod
    def valueOf(cls, char: str) -> str: ...
    class Subset(Object):
        """
        Java class 'java.lang.Character$Subset'
        
            Extends:
                java.lang.Object
        
        """
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> String: ...
    class UnicodeBlock(java.lang.Character.Subset):
        """
        Java class 'java.lang.Character$UnicodeBlock'
        
            Extends:
                java.lang.Character$Subset
        
          Attributes:
            BASIC_LATIN (java.lang.Character$UnicodeBlock): final static field
            LATIN_1_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_B (java.lang.Character$UnicodeBlock): final static field
            IPA_EXTENSIONS (java.lang.Character$UnicodeBlock): final static field
            SPACING_MODIFIER_LETTERS (java.lang.Character$UnicodeBlock): final static field
            COMBINING_DIACRITICAL_MARKS (java.lang.Character$UnicodeBlock): final static field
            GREEK (java.lang.Character$UnicodeBlock): final static field
            CYRILLIC (java.lang.Character$UnicodeBlock): final static field
            ARMENIAN (java.lang.Character$UnicodeBlock): final static field
            HEBREW (java.lang.Character$UnicodeBlock): final static field
            ARABIC (java.lang.Character$UnicodeBlock): final static field
            DEVANAGARI (java.lang.Character$UnicodeBlock): final static field
            BENGALI (java.lang.Character$UnicodeBlock): final static field
            GURMUKHI (java.lang.Character$UnicodeBlock): final static field
            GUJARATI (java.lang.Character$UnicodeBlock): final static field
            ORIYA (java.lang.Character$UnicodeBlock): final static field
            TAMIL (java.lang.Character$UnicodeBlock): final static field
            TELUGU (java.lang.Character$UnicodeBlock): final static field
            KANNADA (java.lang.Character$UnicodeBlock): final static field
            MALAYALAM (java.lang.Character$UnicodeBlock): final static field
            THAI (java.lang.Character$UnicodeBlock): final static field
            LAO (java.lang.Character$UnicodeBlock): final static field
            TIBETAN (java.lang.Character$UnicodeBlock): final static field
            GEORGIAN (java.lang.Character$UnicodeBlock): final static field
            HANGUL_JAMO (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_ADDITIONAL (java.lang.Character$UnicodeBlock): final static field
            GREEK_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            GENERAL_PUNCTUATION (java.lang.Character$UnicodeBlock): final static field
            SUPERSCRIPTS_AND_SUBSCRIPTS (java.lang.Character$UnicodeBlock): final static field
            CURRENCY_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            COMBINING_MARKS_FOR_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            LETTERLIKE_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            NUMBER_FORMS (java.lang.Character$UnicodeBlock): final static field
            ARROWS (java.lang.Character$UnicodeBlock): final static field
            MATHEMATICAL_OPERATORS (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_TECHNICAL (java.lang.Character$UnicodeBlock): final static field
            CONTROL_PICTURES (java.lang.Character$UnicodeBlock): final static field
            OPTICAL_CHARACTER_RECOGNITION (java.lang.Character$UnicodeBlock): final static field
            ENCLOSED_ALPHANUMERICS (java.lang.Character$UnicodeBlock): final static field
            BOX_DRAWING (java.lang.Character$UnicodeBlock): final static field
            BLOCK_ELEMENTS (java.lang.Character$UnicodeBlock): final static field
            GEOMETRIC_SHAPES (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            DINGBATS (java.lang.Character$UnicodeBlock): final static field
            CJK_SYMBOLS_AND_PUNCTUATION (java.lang.Character$UnicodeBlock): final static field
            HIRAGANA (java.lang.Character$UnicodeBlock): final static field
            KATAKANA (java.lang.Character$UnicodeBlock): final static field
            BOPOMOFO (java.lang.Character$UnicodeBlock): final static field
            HANGUL_COMPATIBILITY_JAMO (java.lang.Character$UnicodeBlock): final static field
            KANBUN (java.lang.Character$UnicodeBlock): final static field
            ENCLOSED_CJK_LETTERS_AND_MONTHS (java.lang.Character$UnicodeBlock): final static field
            CJK_COMPATIBILITY (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS (java.lang.Character$UnicodeBlock): final static field
            HANGUL_SYLLABLES (java.lang.Character$UnicodeBlock): final static field
            PRIVATE_USE_AREA (java.lang.Character$UnicodeBlock): final static field
            CJK_COMPATIBILITY_IDEOGRAPHS (java.lang.Character$UnicodeBlock): final static field
            ALPHABETIC_PRESENTATION_FORMS (java.lang.Character$UnicodeBlock): final static field
            ARABIC_PRESENTATION_FORMS_A (java.lang.Character$UnicodeBlock): final static field
            COMBINING_HALF_MARKS (java.lang.Character$UnicodeBlock): final static field
            CJK_COMPATIBILITY_FORMS (java.lang.Character$UnicodeBlock): final static field
            SMALL_FORM_VARIANTS (java.lang.Character$UnicodeBlock): final static field
            ARABIC_PRESENTATION_FORMS_B (java.lang.Character$UnicodeBlock): final static field
            HALFWIDTH_AND_FULLWIDTH_FORMS (java.lang.Character$UnicodeBlock): final static field
            SPECIALS (java.lang.Character$UnicodeBlock): final static field
            SURROGATES_AREA (java.lang.Character$UnicodeBlock): final static field
            SYRIAC (java.lang.Character$UnicodeBlock): final static field
            THAANA (java.lang.Character$UnicodeBlock): final static field
            SINHALA (java.lang.Character$UnicodeBlock): final static field
            MYANMAR (java.lang.Character$UnicodeBlock): final static field
            ETHIOPIC (java.lang.Character$UnicodeBlock): final static field
            CHEROKEE (java.lang.Character$UnicodeBlock): final static field
            UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS (java.lang.Character$UnicodeBlock): final static field
            OGHAM (java.lang.Character$UnicodeBlock): final static field
            RUNIC (java.lang.Character$UnicodeBlock): final static field
            KHMER (java.lang.Character$UnicodeBlock): final static field
            MONGOLIAN (java.lang.Character$UnicodeBlock): final static field
            BRAILLE_PATTERNS (java.lang.Character$UnicodeBlock): final static field
            CJK_RADICALS_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            KANGXI_RADICALS (java.lang.Character$UnicodeBlock): final static field
            IDEOGRAPHIC_DESCRIPTION_CHARACTERS (java.lang.Character$UnicodeBlock): final static field
            BOPOMOFO_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A (java.lang.Character$UnicodeBlock): final static field
            YI_SYLLABLES (java.lang.Character$UnicodeBlock): final static field
            YI_RADICALS (java.lang.Character$UnicodeBlock): final static field
            CYRILLIC_SUPPLEMENTARY (java.lang.Character$UnicodeBlock): final static field
            TAGALOG (java.lang.Character$UnicodeBlock): final static field
            HANUNOO (java.lang.Character$UnicodeBlock): final static field
            BUHID (java.lang.Character$UnicodeBlock): final static field
            TAGBANWA (java.lang.Character$UnicodeBlock): final static field
            LIMBU (java.lang.Character$UnicodeBlock): final static field
            TAI_LE (java.lang.Character$UnicodeBlock): final static field
            KHMER_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            PHONETIC_EXTENSIONS (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_ARROWS_A (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_ARROWS_B (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_MATHEMATICAL_OPERATORS (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_SYMBOLS_AND_ARROWS (java.lang.Character$UnicodeBlock): final static field
            KATAKANA_PHONETIC_EXTENSIONS (java.lang.Character$UnicodeBlock): final static field
            YIJING_HEXAGRAM_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            VARIATION_SELECTORS (java.lang.Character$UnicodeBlock): final static field
            LINEAR_B_SYLLABARY (java.lang.Character$UnicodeBlock): final static field
            LINEAR_B_IDEOGRAMS (java.lang.Character$UnicodeBlock): final static field
            AEGEAN_NUMBERS (java.lang.Character$UnicodeBlock): final static field
            OLD_ITALIC (java.lang.Character$UnicodeBlock): final static field
            GOTHIC (java.lang.Character$UnicodeBlock): final static field
            UGARITIC (java.lang.Character$UnicodeBlock): final static field
            DESERET (java.lang.Character$UnicodeBlock): final static field
            SHAVIAN (java.lang.Character$UnicodeBlock): final static field
            OSMANYA (java.lang.Character$UnicodeBlock): final static field
            CYPRIOT_SYLLABARY (java.lang.Character$UnicodeBlock): final static field
            BYZANTINE_MUSICAL_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            MUSICAL_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            TAI_XUAN_JING_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            MATHEMATICAL_ALPHANUMERIC_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B (java.lang.Character$UnicodeBlock): final static field
            CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            TAGS (java.lang.Character$UnicodeBlock): final static field
            VARIATION_SELECTORS_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTARY_PRIVATE_USE_AREA_A (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTARY_PRIVATE_USE_AREA_B (java.lang.Character$UnicodeBlock): final static field
            HIGH_SURROGATES (java.lang.Character$UnicodeBlock): final static field
            HIGH_PRIVATE_USE_SURROGATES (java.lang.Character$UnicodeBlock): final static field
            LOW_SURROGATES (java.lang.Character$UnicodeBlock): final static field
            ARABIC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            NKO (java.lang.Character$UnicodeBlock): final static field
            SAMARITAN (java.lang.Character$UnicodeBlock): final static field
            MANDAIC (java.lang.Character$UnicodeBlock): final static field
            ETHIOPIC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            NEW_TAI_LUE (java.lang.Character$UnicodeBlock): final static field
            BUGINESE (java.lang.Character$UnicodeBlock): final static field
            TAI_THAM (java.lang.Character$UnicodeBlock): final static field
            BALINESE (java.lang.Character$UnicodeBlock): final static field
            SUNDANESE (java.lang.Character$UnicodeBlock): final static field
            BATAK (java.lang.Character$UnicodeBlock): final static field
            LEPCHA (java.lang.Character$UnicodeBlock): final static field
            OL_CHIKI (java.lang.Character$UnicodeBlock): final static field
            VEDIC_EXTENSIONS (java.lang.Character$UnicodeBlock): final static field
            PHONETIC_EXTENSIONS_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            COMBINING_DIACRITICAL_MARKS_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            GLAGOLITIC (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_C (java.lang.Character$UnicodeBlock): final static field
            COPTIC (java.lang.Character$UnicodeBlock): final static field
            GEORGIAN_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            TIFINAGH (java.lang.Character$UnicodeBlock): final static field
            ETHIOPIC_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            CYRILLIC_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_PUNCTUATION (java.lang.Character$UnicodeBlock): final static field
            CJK_STROKES (java.lang.Character$UnicodeBlock): final static field
            LISU (java.lang.Character$UnicodeBlock): final static field
            VAI (java.lang.Character$UnicodeBlock): final static field
            CYRILLIC_EXTENDED_B (java.lang.Character$UnicodeBlock): final static field
            BAMUM (java.lang.Character$UnicodeBlock): final static field
            MODIFIER_TONE_LETTERS (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_D (java.lang.Character$UnicodeBlock): final static field
            SYLOTI_NAGRI (java.lang.Character$UnicodeBlock): final static field
            COMMON_INDIC_NUMBER_FORMS (java.lang.Character$UnicodeBlock): final static field
            PHAGS_PA (java.lang.Character$UnicodeBlock): final static field
            SAURASHTRA (java.lang.Character$UnicodeBlock): final static field
            DEVANAGARI_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            KAYAH_LI (java.lang.Character$UnicodeBlock): final static field
            REJANG (java.lang.Character$UnicodeBlock): final static field
            HANGUL_JAMO_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            JAVANESE (java.lang.Character$UnicodeBlock): final static field
            CHAM (java.lang.Character$UnicodeBlock): final static field
            MYANMAR_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            TAI_VIET (java.lang.Character$UnicodeBlock): final static field
            ETHIOPIC_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            MEETEI_MAYEK (java.lang.Character$UnicodeBlock): final static field
            HANGUL_JAMO_EXTENDED_B (java.lang.Character$UnicodeBlock): final static field
            VERTICAL_FORMS (java.lang.Character$UnicodeBlock): final static field
            ANCIENT_GREEK_NUMBERS (java.lang.Character$UnicodeBlock): final static field
            ANCIENT_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            PHAISTOS_DISC (java.lang.Character$UnicodeBlock): final static field
            LYCIAN (java.lang.Character$UnicodeBlock): final static field
            CARIAN (java.lang.Character$UnicodeBlock): final static field
            OLD_PERSIAN (java.lang.Character$UnicodeBlock): final static field
            IMPERIAL_ARAMAIC (java.lang.Character$UnicodeBlock): final static field
            PHOENICIAN (java.lang.Character$UnicodeBlock): final static field
            LYDIAN (java.lang.Character$UnicodeBlock): final static field
            KHAROSHTHI (java.lang.Character$UnicodeBlock): final static field
            OLD_SOUTH_ARABIAN (java.lang.Character$UnicodeBlock): final static field
            AVESTAN (java.lang.Character$UnicodeBlock): final static field
            INSCRIPTIONAL_PARTHIAN (java.lang.Character$UnicodeBlock): final static field
            INSCRIPTIONAL_PAHLAVI (java.lang.Character$UnicodeBlock): final static field
            OLD_TURKIC (java.lang.Character$UnicodeBlock): final static field
            RUMI_NUMERAL_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            BRAHMI (java.lang.Character$UnicodeBlock): final static field
            KAITHI (java.lang.Character$UnicodeBlock): final static field
            CUNEIFORM (java.lang.Character$UnicodeBlock): final static field
            CUNEIFORM_NUMBERS_AND_PUNCTUATION (java.lang.Character$UnicodeBlock): final static field
            EGYPTIAN_HIEROGLYPHS (java.lang.Character$UnicodeBlock): final static field
            BAMUM_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            KANA_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            ANCIENT_GREEK_MUSICAL_NOTATION (java.lang.Character$UnicodeBlock): final static field
            COUNTING_ROD_NUMERALS (java.lang.Character$UnicodeBlock): final static field
            MAHJONG_TILES (java.lang.Character$UnicodeBlock): final static field
            DOMINO_TILES (java.lang.Character$UnicodeBlock): final static field
            PLAYING_CARDS (java.lang.Character$UnicodeBlock): final static field
            ENCLOSED_ALPHANUMERIC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            ENCLOSED_IDEOGRAPHIC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS (java.lang.Character$UnicodeBlock): final static field
            EMOTICONS (java.lang.Character$UnicodeBlock): final static field
            TRANSPORT_AND_MAP_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            ALCHEMICAL_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D (java.lang.Character$UnicodeBlock): final static field
            ARABIC_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            SUNDANESE_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            MEETEI_MAYEK_EXTENSIONS (java.lang.Character$UnicodeBlock): final static field
            MEROITIC_HIEROGLYPHS (java.lang.Character$UnicodeBlock): final static field
            MEROITIC_CURSIVE (java.lang.Character$UnicodeBlock): final static field
            SORA_SOMPENG (java.lang.Character$UnicodeBlock): final static field
            CHAKMA (java.lang.Character$UnicodeBlock): final static field
            SHARADA (java.lang.Character$UnicodeBlock): final static field
            TAKRI (java.lang.Character$UnicodeBlock): final static field
            MIAO (java.lang.Character$UnicodeBlock): final static field
            ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS (java.lang.Character$UnicodeBlock): final static field
            COMBINING_DIACRITICAL_MARKS_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            MYANMAR_EXTENDED_B (java.lang.Character$UnicodeBlock): final static field
            LATIN_EXTENDED_E (java.lang.Character$UnicodeBlock): final static field
            COPTIC_EPACT_NUMBERS (java.lang.Character$UnicodeBlock): final static field
            OLD_PERMIC (java.lang.Character$UnicodeBlock): final static field
            ELBASAN (java.lang.Character$UnicodeBlock): final static field
            CAUCASIAN_ALBANIAN (java.lang.Character$UnicodeBlock): final static field
            LINEAR_A (java.lang.Character$UnicodeBlock): final static field
            PALMYRENE (java.lang.Character$UnicodeBlock): final static field
            NABATAEAN (java.lang.Character$UnicodeBlock): final static field
            OLD_NORTH_ARABIAN (java.lang.Character$UnicodeBlock): final static field
            MANICHAEAN (java.lang.Character$UnicodeBlock): final static field
            PSALTER_PAHLAVI (java.lang.Character$UnicodeBlock): final static field
            MAHAJANI (java.lang.Character$UnicodeBlock): final static field
            SINHALA_ARCHAIC_NUMBERS (java.lang.Character$UnicodeBlock): final static field
            KHOJKI (java.lang.Character$UnicodeBlock): final static field
            KHUDAWADI (java.lang.Character$UnicodeBlock): final static field
            GRANTHA (java.lang.Character$UnicodeBlock): final static field
            TIRHUTA (java.lang.Character$UnicodeBlock): final static field
            SIDDHAM (java.lang.Character$UnicodeBlock): final static field
            MODI (java.lang.Character$UnicodeBlock): final static field
            WARANG_CITI (java.lang.Character$UnicodeBlock): final static field
            PAU_CIN_HAU (java.lang.Character$UnicodeBlock): final static field
            MRO (java.lang.Character$UnicodeBlock): final static field
            BASSA_VAH (java.lang.Character$UnicodeBlock): final static field
            PAHAWH_HMONG (java.lang.Character$UnicodeBlock): final static field
            DUPLOYAN (java.lang.Character$UnicodeBlock): final static field
            SHORTHAND_FORMAT_CONTROLS (java.lang.Character$UnicodeBlock): final static field
            MENDE_KIKAKUI (java.lang.Character$UnicodeBlock): final static field
            ORNAMENTAL_DINGBATS (java.lang.Character$UnicodeBlock): final static field
            GEOMETRIC_SHAPES_EXTENDED (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_ARROWS_C (java.lang.Character$UnicodeBlock): final static field
            CHEROKEE_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            HATRAN (java.lang.Character$UnicodeBlock): final static field
            OLD_HUNGARIAN (java.lang.Character$UnicodeBlock): final static field
            MULTANI (java.lang.Character$UnicodeBlock): final static field
            AHOM (java.lang.Character$UnicodeBlock): final static field
            EARLY_DYNASTIC_CUNEIFORM (java.lang.Character$UnicodeBlock): final static field
            ANATOLIAN_HIEROGLYPHS (java.lang.Character$UnicodeBlock): final static field
            SUTTON_SIGNWRITING (java.lang.Character$UnicodeBlock): final static field
            SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E (java.lang.Character$UnicodeBlock): final static field
            SYRIAC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            CYRILLIC_EXTENDED_C (java.lang.Character$UnicodeBlock): final static field
            OSAGE (java.lang.Character$UnicodeBlock): final static field
            NEWA (java.lang.Character$UnicodeBlock): final static field
            MONGOLIAN_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            MARCHEN (java.lang.Character$UnicodeBlock): final static field
            IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION (java.lang.Character$UnicodeBlock): final static field
            TANGUT (java.lang.Character$UnicodeBlock): final static field
            TANGUT_COMPONENTS (java.lang.Character$UnicodeBlock): final static field
            KANA_EXTENDED_A (java.lang.Character$UnicodeBlock): final static field
            GLAGOLITIC_SUPPLEMENT (java.lang.Character$UnicodeBlock): final static field
            ADLAM (java.lang.Character$UnicodeBlock): final static field
            MASARAM_GONDI (java.lang.Character$UnicodeBlock): final static field
            ZANABAZAR_SQUARE (java.lang.Character$UnicodeBlock): final static field
            NUSHU (java.lang.Character$UnicodeBlock): final static field
            SOYOMBO (java.lang.Character$UnicodeBlock): final static field
            BHAIKSUKI (java.lang.Character$UnicodeBlock): final static field
            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F (java.lang.Character$UnicodeBlock): final static field
        
        """
        BASIC_LATIN: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_1_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        IPA_EXTENSIONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        SPACING_MODIFIER_LETTERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMBINING_DIACRITICAL_MARKS: typing.ClassVar['Character.UnicodeBlock'] = ...
        GREEK: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYRILLIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARMENIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        HEBREW: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        DEVANAGARI: typing.ClassVar['Character.UnicodeBlock'] = ...
        BENGALI: typing.ClassVar['Character.UnicodeBlock'] = ...
        GURMUKHI: typing.ClassVar['Character.UnicodeBlock'] = ...
        GUJARATI: typing.ClassVar['Character.UnicodeBlock'] = ...
        ORIYA: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAMIL: typing.ClassVar['Character.UnicodeBlock'] = ...
        TELUGU: typing.ClassVar['Character.UnicodeBlock'] = ...
        KANNADA: typing.ClassVar['Character.UnicodeBlock'] = ...
        MALAYALAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        THAI: typing.ClassVar['Character.UnicodeBlock'] = ...
        LAO: typing.ClassVar['Character.UnicodeBlock'] = ...
        TIBETAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        GEORGIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANGUL_JAMO: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_ADDITIONAL: typing.ClassVar['Character.UnicodeBlock'] = ...
        GREEK_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        GENERAL_PUNCTUATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPERSCRIPTS_AND_SUBSCRIPTS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CURRENCY_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMBINING_MARKS_FOR_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        LETTERLIKE_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        NUMBER_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARROWS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MATHEMATICAL_OPERATORS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_TECHNICAL: typing.ClassVar['Character.UnicodeBlock'] = ...
        CONTROL_PICTURES: typing.ClassVar['Character.UnicodeBlock'] = ...
        OPTICAL_CHARACTER_RECOGNITION: typing.ClassVar['Character.UnicodeBlock'] = ...
        ENCLOSED_ALPHANUMERICS: typing.ClassVar['Character.UnicodeBlock'] = ...
        BOX_DRAWING: typing.ClassVar['Character.UnicodeBlock'] = ...
        BLOCK_ELEMENTS: typing.ClassVar['Character.UnicodeBlock'] = ...
        GEOMETRIC_SHAPES: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        DINGBATS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_SYMBOLS_AND_PUNCTUATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        HIRAGANA: typing.ClassVar['Character.UnicodeBlock'] = ...
        KATAKANA: typing.ClassVar['Character.UnicodeBlock'] = ...
        BOPOMOFO: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANGUL_COMPATIBILITY_JAMO: typing.ClassVar['Character.UnicodeBlock'] = ...
        KANBUN: typing.ClassVar['Character.UnicodeBlock'] = ...
        ENCLOSED_CJK_LETTERS_AND_MONTHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_COMPATIBILITY: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANGUL_SYLLABLES: typing.ClassVar['Character.UnicodeBlock'] = ...
        PRIVATE_USE_AREA: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_COMPATIBILITY_IDEOGRAPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ALPHABETIC_PRESENTATION_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC_PRESENTATION_FORMS_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMBINING_HALF_MARKS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_COMPATIBILITY_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        SMALL_FORM_VARIANTS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC_PRESENTATION_FORMS_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        HALFWIDTH_AND_FULLWIDTH_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        SPECIALS: typing.ClassVar['Character.UnicodeBlock'] = ...
        SURROGATES_AREA: typing.ClassVar['Character.UnicodeBlock'] = ...
        SYRIAC: typing.ClassVar['Character.UnicodeBlock'] = ...
        THAANA: typing.ClassVar['Character.UnicodeBlock'] = ...
        SINHALA: typing.ClassVar['Character.UnicodeBlock'] = ...
        MYANMAR: typing.ClassVar['Character.UnicodeBlock'] = ...
        ETHIOPIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        CHEROKEE: typing.ClassVar['Character.UnicodeBlock'] = ...
        UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS: typing.ClassVar['Character.UnicodeBlock'] = ...
        OGHAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        RUNIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        KHMER: typing.ClassVar['Character.UnicodeBlock'] = ...
        MONGOLIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        BRAILLE_PATTERNS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_RADICALS_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        KANGXI_RADICALS: typing.ClassVar['Character.UnicodeBlock'] = ...
        IDEOGRAPHIC_DESCRIPTION_CHARACTERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        BOPOMOFO_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        YI_SYLLABLES: typing.ClassVar['Character.UnicodeBlock'] = ...
        YI_RADICALS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYRILLIC_SUPPLEMENTARY: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAGALOG: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANUNOO: typing.ClassVar['Character.UnicodeBlock'] = ...
        BUHID: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAGBANWA: typing.ClassVar['Character.UnicodeBlock'] = ...
        LIMBU: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAI_LE: typing.ClassVar['Character.UnicodeBlock'] = ...
        KHMER_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        PHONETIC_EXTENSIONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_ARROWS_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_ARROWS_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_MATHEMATICAL_OPERATORS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_SYMBOLS_AND_ARROWS: typing.ClassVar['Character.UnicodeBlock'] = ...
        KATAKANA_PHONETIC_EXTENSIONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        YIJING_HEXAGRAM_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        VARIATION_SELECTORS: typing.ClassVar['Character.UnicodeBlock'] = ...
        LINEAR_B_SYLLABARY: typing.ClassVar['Character.UnicodeBlock'] = ...
        LINEAR_B_IDEOGRAMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        AEGEAN_NUMBERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_ITALIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        GOTHIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        UGARITIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        DESERET: typing.ClassVar['Character.UnicodeBlock'] = ...
        SHAVIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        OSMANYA: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYPRIOT_SYLLABARY: typing.ClassVar['Character.UnicodeBlock'] = ...
        BYZANTINE_MUSICAL_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MUSICAL_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAI_XUAN_JING_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MATHEMATICAL_ALPHANUMERIC_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAGS: typing.ClassVar['Character.UnicodeBlock'] = ...
        VARIATION_SELECTORS_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTARY_PRIVATE_USE_AREA_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTARY_PRIVATE_USE_AREA_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        HIGH_SURROGATES: typing.ClassVar['Character.UnicodeBlock'] = ...
        HIGH_PRIVATE_USE_SURROGATES: typing.ClassVar['Character.UnicodeBlock'] = ...
        LOW_SURROGATES: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        NKO: typing.ClassVar['Character.UnicodeBlock'] = ...
        SAMARITAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        MANDAIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        ETHIOPIC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        NEW_TAI_LUE: typing.ClassVar['Character.UnicodeBlock'] = ...
        BUGINESE: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAI_THAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        BALINESE: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUNDANESE: typing.ClassVar['Character.UnicodeBlock'] = ...
        BATAK: typing.ClassVar['Character.UnicodeBlock'] = ...
        LEPCHA: typing.ClassVar['Character.UnicodeBlock'] = ...
        OL_CHIKI: typing.ClassVar['Character.UnicodeBlock'] = ...
        VEDIC_EXTENSIONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        PHONETIC_EXTENSIONS_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMBINING_DIACRITICAL_MARKS_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        GLAGOLITIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_C: typing.ClassVar['Character.UnicodeBlock'] = ...
        COPTIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        GEORGIAN_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        TIFINAGH: typing.ClassVar['Character.UnicodeBlock'] = ...
        ETHIOPIC_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYRILLIC_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_PUNCTUATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_STROKES: typing.ClassVar['Character.UnicodeBlock'] = ...
        LISU: typing.ClassVar['Character.UnicodeBlock'] = ...
        VAI: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYRILLIC_EXTENDED_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        BAMUM: typing.ClassVar['Character.UnicodeBlock'] = ...
        MODIFIER_TONE_LETTERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_D: typing.ClassVar['Character.UnicodeBlock'] = ...
        SYLOTI_NAGRI: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMMON_INDIC_NUMBER_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        PHAGS_PA: typing.ClassVar['Character.UnicodeBlock'] = ...
        SAURASHTRA: typing.ClassVar['Character.UnicodeBlock'] = ...
        DEVANAGARI_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        KAYAH_LI: typing.ClassVar['Character.UnicodeBlock'] = ...
        REJANG: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANGUL_JAMO_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        JAVANESE: typing.ClassVar['Character.UnicodeBlock'] = ...
        CHAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        MYANMAR_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAI_VIET: typing.ClassVar['Character.UnicodeBlock'] = ...
        ETHIOPIC_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        MEETEI_MAYEK: typing.ClassVar['Character.UnicodeBlock'] = ...
        HANGUL_JAMO_EXTENDED_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        VERTICAL_FORMS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ANCIENT_GREEK_NUMBERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ANCIENT_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        PHAISTOS_DISC: typing.ClassVar['Character.UnicodeBlock'] = ...
        LYCIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        CARIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_PERSIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        IMPERIAL_ARAMAIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        PHOENICIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        LYDIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        KHAROSHTHI: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_SOUTH_ARABIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        AVESTAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        INSCRIPTIONAL_PARTHIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        INSCRIPTIONAL_PAHLAVI: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_TURKIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        RUMI_NUMERAL_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        BRAHMI: typing.ClassVar['Character.UnicodeBlock'] = ...
        KAITHI: typing.ClassVar['Character.UnicodeBlock'] = ...
        CUNEIFORM: typing.ClassVar['Character.UnicodeBlock'] = ...
        CUNEIFORM_NUMBERS_AND_PUNCTUATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        EGYPTIAN_HIEROGLYPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        BAMUM_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        KANA_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        ANCIENT_GREEK_MUSICAL_NOTATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        COUNTING_ROD_NUMERALS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MAHJONG_TILES: typing.ClassVar['Character.UnicodeBlock'] = ...
        DOMINO_TILES: typing.ClassVar['Character.UnicodeBlock'] = ...
        PLAYING_CARDS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ENCLOSED_ALPHANUMERIC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        ENCLOSED_IDEOGRAPHIC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        EMOTICONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        TRANSPORT_AND_MAP_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        ALCHEMICAL_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUNDANESE_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        MEETEI_MAYEK_EXTENSIONS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MEROITIC_HIEROGLYPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MEROITIC_CURSIVE: typing.ClassVar['Character.UnicodeBlock'] = ...
        SORA_SOMPENG: typing.ClassVar['Character.UnicodeBlock'] = ...
        CHAKMA: typing.ClassVar['Character.UnicodeBlock'] = ...
        SHARADA: typing.ClassVar['Character.UnicodeBlock'] = ...
        TAKRI: typing.ClassVar['Character.UnicodeBlock'] = ...
        MIAO: typing.ClassVar['Character.UnicodeBlock'] = ...
        ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        COMBINING_DIACRITICAL_MARKS_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        MYANMAR_EXTENDED_B: typing.ClassVar['Character.UnicodeBlock'] = ...
        LATIN_EXTENDED_E: typing.ClassVar['Character.UnicodeBlock'] = ...
        COPTIC_EPACT_NUMBERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_PERMIC: typing.ClassVar['Character.UnicodeBlock'] = ...
        ELBASAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        CAUCASIAN_ALBANIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        LINEAR_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        PALMYRENE: typing.ClassVar['Character.UnicodeBlock'] = ...
        NABATAEAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_NORTH_ARABIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        MANICHAEAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        PSALTER_PAHLAVI: typing.ClassVar['Character.UnicodeBlock'] = ...
        MAHAJANI: typing.ClassVar['Character.UnicodeBlock'] = ...
        SINHALA_ARCHAIC_NUMBERS: typing.ClassVar['Character.UnicodeBlock'] = ...
        KHOJKI: typing.ClassVar['Character.UnicodeBlock'] = ...
        KHUDAWADI: typing.ClassVar['Character.UnicodeBlock'] = ...
        GRANTHA: typing.ClassVar['Character.UnicodeBlock'] = ...
        TIRHUTA: typing.ClassVar['Character.UnicodeBlock'] = ...
        SIDDHAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        MODI: typing.ClassVar['Character.UnicodeBlock'] = ...
        WARANG_CITI: typing.ClassVar['Character.UnicodeBlock'] = ...
        PAU_CIN_HAU: typing.ClassVar['Character.UnicodeBlock'] = ...
        MRO: typing.ClassVar['Character.UnicodeBlock'] = ...
        BASSA_VAH: typing.ClassVar['Character.UnicodeBlock'] = ...
        PAHAWH_HMONG: typing.ClassVar['Character.UnicodeBlock'] = ...
        DUPLOYAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        SHORTHAND_FORMAT_CONTROLS: typing.ClassVar['Character.UnicodeBlock'] = ...
        MENDE_KIKAKUI: typing.ClassVar['Character.UnicodeBlock'] = ...
        ORNAMENTAL_DINGBATS: typing.ClassVar['Character.UnicodeBlock'] = ...
        GEOMETRIC_SHAPES_EXTENDED: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_ARROWS_C: typing.ClassVar['Character.UnicodeBlock'] = ...
        CHEROKEE_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        HATRAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        OLD_HUNGARIAN: typing.ClassVar['Character.UnicodeBlock'] = ...
        MULTANI: typing.ClassVar['Character.UnicodeBlock'] = ...
        AHOM: typing.ClassVar['Character.UnicodeBlock'] = ...
        EARLY_DYNASTIC_CUNEIFORM: typing.ClassVar['Character.UnicodeBlock'] = ...
        ANATOLIAN_HIEROGLYPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUTTON_SIGNWRITING: typing.ClassVar['Character.UnicodeBlock'] = ...
        SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E: typing.ClassVar['Character.UnicodeBlock'] = ...
        SYRIAC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        CYRILLIC_EXTENDED_C: typing.ClassVar['Character.UnicodeBlock'] = ...
        OSAGE: typing.ClassVar['Character.UnicodeBlock'] = ...
        NEWA: typing.ClassVar['Character.UnicodeBlock'] = ...
        MONGOLIAN_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        MARCHEN: typing.ClassVar['Character.UnicodeBlock'] = ...
        IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION: typing.ClassVar['Character.UnicodeBlock'] = ...
        TANGUT: typing.ClassVar['Character.UnicodeBlock'] = ...
        TANGUT_COMPONENTS: typing.ClassVar['Character.UnicodeBlock'] = ...
        KANA_EXTENDED_A: typing.ClassVar['Character.UnicodeBlock'] = ...
        GLAGOLITIC_SUPPLEMENT: typing.ClassVar['Character.UnicodeBlock'] = ...
        ADLAM: typing.ClassVar['Character.UnicodeBlock'] = ...
        MASARAM_GONDI: typing.ClassVar['Character.UnicodeBlock'] = ...
        ZANABAZAR_SQUARE: typing.ClassVar['Character.UnicodeBlock'] = ...
        NUSHU: typing.ClassVar['Character.UnicodeBlock'] = ...
        SOYOMBO: typing.ClassVar['Character.UnicodeBlock'] = ...
        BHAIKSUKI: typing.ClassVar['Character.UnicodeBlock'] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F: typing.ClassVar['Character.UnicodeBlock'] = ...
        @classmethod
        def forName(cls, string: String) -> 'Character.UnicodeBlock': ...
        @classmethod
        @typing.overload
        def of(cls, char: str) -> 'Character.UnicodeBlock': ...
        @classmethod
        @typing.overload
        def of(cls, int: int) -> 'Character.UnicodeBlock': ...
    class UnicodeScript(Enum[java.lang.Character.UnicodeScript]):
        """
        Java class 'java.lang.Character$UnicodeScript'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            COMMON (java.lang.Character$UnicodeScript): final static enum constant
            LATIN (java.lang.Character$UnicodeScript): final static enum constant
            GREEK (java.lang.Character$UnicodeScript): final static enum constant
            CYRILLIC (java.lang.Character$UnicodeScript): final static enum constant
            ARMENIAN (java.lang.Character$UnicodeScript): final static enum constant
            HEBREW (java.lang.Character$UnicodeScript): final static enum constant
            ARABIC (java.lang.Character$UnicodeScript): final static enum constant
            SYRIAC (java.lang.Character$UnicodeScript): final static enum constant
            THAANA (java.lang.Character$UnicodeScript): final static enum constant
            DEVANAGARI (java.lang.Character$UnicodeScript): final static enum constant
            BENGALI (java.lang.Character$UnicodeScript): final static enum constant
            GURMUKHI (java.lang.Character$UnicodeScript): final static enum constant
            GUJARATI (java.lang.Character$UnicodeScript): final static enum constant
            ORIYA (java.lang.Character$UnicodeScript): final static enum constant
            TAMIL (java.lang.Character$UnicodeScript): final static enum constant
            TELUGU (java.lang.Character$UnicodeScript): final static enum constant
            KANNADA (java.lang.Character$UnicodeScript): final static enum constant
            MALAYALAM (java.lang.Character$UnicodeScript): final static enum constant
            SINHALA (java.lang.Character$UnicodeScript): final static enum constant
            THAI (java.lang.Character$UnicodeScript): final static enum constant
            LAO (java.lang.Character$UnicodeScript): final static enum constant
            TIBETAN (java.lang.Character$UnicodeScript): final static enum constant
            MYANMAR (java.lang.Character$UnicodeScript): final static enum constant
            GEORGIAN (java.lang.Character$UnicodeScript): final static enum constant
            HANGUL (java.lang.Character$UnicodeScript): final static enum constant
            ETHIOPIC (java.lang.Character$UnicodeScript): final static enum constant
            CHEROKEE (java.lang.Character$UnicodeScript): final static enum constant
            CANADIAN_ABORIGINAL (java.lang.Character$UnicodeScript): final static enum constant
            OGHAM (java.lang.Character$UnicodeScript): final static enum constant
            RUNIC (java.lang.Character$UnicodeScript): final static enum constant
            KHMER (java.lang.Character$UnicodeScript): final static enum constant
            MONGOLIAN (java.lang.Character$UnicodeScript): final static enum constant
            HIRAGANA (java.lang.Character$UnicodeScript): final static enum constant
            KATAKANA (java.lang.Character$UnicodeScript): final static enum constant
            BOPOMOFO (java.lang.Character$UnicodeScript): final static enum constant
            HAN (java.lang.Character$UnicodeScript): final static enum constant
            YI (java.lang.Character$UnicodeScript): final static enum constant
            OLD_ITALIC (java.lang.Character$UnicodeScript): final static enum constant
            GOTHIC (java.lang.Character$UnicodeScript): final static enum constant
            DESERET (java.lang.Character$UnicodeScript): final static enum constant
            INHERITED (java.lang.Character$UnicodeScript): final static enum constant
            TAGALOG (java.lang.Character$UnicodeScript): final static enum constant
            HANUNOO (java.lang.Character$UnicodeScript): final static enum constant
            BUHID (java.lang.Character$UnicodeScript): final static enum constant
            TAGBANWA (java.lang.Character$UnicodeScript): final static enum constant
            LIMBU (java.lang.Character$UnicodeScript): final static enum constant
            TAI_LE (java.lang.Character$UnicodeScript): final static enum constant
            LINEAR_B (java.lang.Character$UnicodeScript): final static enum constant
            UGARITIC (java.lang.Character$UnicodeScript): final static enum constant
            SHAVIAN (java.lang.Character$UnicodeScript): final static enum constant
            OSMANYA (java.lang.Character$UnicodeScript): final static enum constant
            CYPRIOT (java.lang.Character$UnicodeScript): final static enum constant
            BRAILLE (java.lang.Character$UnicodeScript): final static enum constant
            BUGINESE (java.lang.Character$UnicodeScript): final static enum constant
            COPTIC (java.lang.Character$UnicodeScript): final static enum constant
            NEW_TAI_LUE (java.lang.Character$UnicodeScript): final static enum constant
            GLAGOLITIC (java.lang.Character$UnicodeScript): final static enum constant
            TIFINAGH (java.lang.Character$UnicodeScript): final static enum constant
            SYLOTI_NAGRI (java.lang.Character$UnicodeScript): final static enum constant
            OLD_PERSIAN (java.lang.Character$UnicodeScript): final static enum constant
            KHAROSHTHI (java.lang.Character$UnicodeScript): final static enum constant
            BALINESE (java.lang.Character$UnicodeScript): final static enum constant
            CUNEIFORM (java.lang.Character$UnicodeScript): final static enum constant
            PHOENICIAN (java.lang.Character$UnicodeScript): final static enum constant
            PHAGS_PA (java.lang.Character$UnicodeScript): final static enum constant
            NKO (java.lang.Character$UnicodeScript): final static enum constant
            SUNDANESE (java.lang.Character$UnicodeScript): final static enum constant
            BATAK (java.lang.Character$UnicodeScript): final static enum constant
            LEPCHA (java.lang.Character$UnicodeScript): final static enum constant
            OL_CHIKI (java.lang.Character$UnicodeScript): final static enum constant
            VAI (java.lang.Character$UnicodeScript): final static enum constant
            SAURASHTRA (java.lang.Character$UnicodeScript): final static enum constant
            KAYAH_LI (java.lang.Character$UnicodeScript): final static enum constant
            REJANG (java.lang.Character$UnicodeScript): final static enum constant
            LYCIAN (java.lang.Character$UnicodeScript): final static enum constant
            CARIAN (java.lang.Character$UnicodeScript): final static enum constant
            LYDIAN (java.lang.Character$UnicodeScript): final static enum constant
            CHAM (java.lang.Character$UnicodeScript): final static enum constant
            TAI_THAM (java.lang.Character$UnicodeScript): final static enum constant
            TAI_VIET (java.lang.Character$UnicodeScript): final static enum constant
            AVESTAN (java.lang.Character$UnicodeScript): final static enum constant
            EGYPTIAN_HIEROGLYPHS (java.lang.Character$UnicodeScript): final static enum constant
            SAMARITAN (java.lang.Character$UnicodeScript): final static enum constant
            MANDAIC (java.lang.Character$UnicodeScript): final static enum constant
            LISU (java.lang.Character$UnicodeScript): final static enum constant
            BAMUM (java.lang.Character$UnicodeScript): final static enum constant
            JAVANESE (java.lang.Character$UnicodeScript): final static enum constant
            MEETEI_MAYEK (java.lang.Character$UnicodeScript): final static enum constant
            IMPERIAL_ARAMAIC (java.lang.Character$UnicodeScript): final static enum constant
            OLD_SOUTH_ARABIAN (java.lang.Character$UnicodeScript): final static enum constant
            INSCRIPTIONAL_PARTHIAN (java.lang.Character$UnicodeScript): final static enum constant
            INSCRIPTIONAL_PAHLAVI (java.lang.Character$UnicodeScript): final static enum constant
            OLD_TURKIC (java.lang.Character$UnicodeScript): final static enum constant
            BRAHMI (java.lang.Character$UnicodeScript): final static enum constant
            KAITHI (java.lang.Character$UnicodeScript): final static enum constant
            MEROITIC_HIEROGLYPHS (java.lang.Character$UnicodeScript): final static enum constant
            MEROITIC_CURSIVE (java.lang.Character$UnicodeScript): final static enum constant
            SORA_SOMPENG (java.lang.Character$UnicodeScript): final static enum constant
            CHAKMA (java.lang.Character$UnicodeScript): final static enum constant
            SHARADA (java.lang.Character$UnicodeScript): final static enum constant
            TAKRI (java.lang.Character$UnicodeScript): final static enum constant
            MIAO (java.lang.Character$UnicodeScript): final static enum constant
            CAUCASIAN_ALBANIAN (java.lang.Character$UnicodeScript): final static enum constant
            BASSA_VAH (java.lang.Character$UnicodeScript): final static enum constant
            DUPLOYAN (java.lang.Character$UnicodeScript): final static enum constant
            ELBASAN (java.lang.Character$UnicodeScript): final static enum constant
            GRANTHA (java.lang.Character$UnicodeScript): final static enum constant
            PAHAWH_HMONG (java.lang.Character$UnicodeScript): final static enum constant
            KHOJKI (java.lang.Character$UnicodeScript): final static enum constant
            LINEAR_A (java.lang.Character$UnicodeScript): final static enum constant
            MAHAJANI (java.lang.Character$UnicodeScript): final static enum constant
            MANICHAEAN (java.lang.Character$UnicodeScript): final static enum constant
            MENDE_KIKAKUI (java.lang.Character$UnicodeScript): final static enum constant
            MODI (java.lang.Character$UnicodeScript): final static enum constant
            MRO (java.lang.Character$UnicodeScript): final static enum constant
            OLD_NORTH_ARABIAN (java.lang.Character$UnicodeScript): final static enum constant
            NABATAEAN (java.lang.Character$UnicodeScript): final static enum constant
            PALMYRENE (java.lang.Character$UnicodeScript): final static enum constant
            PAU_CIN_HAU (java.lang.Character$UnicodeScript): final static enum constant
            OLD_PERMIC (java.lang.Character$UnicodeScript): final static enum constant
            PSALTER_PAHLAVI (java.lang.Character$UnicodeScript): final static enum constant
            SIDDHAM (java.lang.Character$UnicodeScript): final static enum constant
            KHUDAWADI (java.lang.Character$UnicodeScript): final static enum constant
            TIRHUTA (java.lang.Character$UnicodeScript): final static enum constant
            WARANG_CITI (java.lang.Character$UnicodeScript): final static enum constant
            AHOM (java.lang.Character$UnicodeScript): final static enum constant
            ANATOLIAN_HIEROGLYPHS (java.lang.Character$UnicodeScript): final static enum constant
            HATRAN (java.lang.Character$UnicodeScript): final static enum constant
            MULTANI (java.lang.Character$UnicodeScript): final static enum constant
            OLD_HUNGARIAN (java.lang.Character$UnicodeScript): final static enum constant
            SIGNWRITING (java.lang.Character$UnicodeScript): final static enum constant
            ADLAM (java.lang.Character$UnicodeScript): final static enum constant
            BHAIKSUKI (java.lang.Character$UnicodeScript): final static enum constant
            MARCHEN (java.lang.Character$UnicodeScript): final static enum constant
            NEWA (java.lang.Character$UnicodeScript): final static enum constant
            OSAGE (java.lang.Character$UnicodeScript): final static enum constant
            TANGUT (java.lang.Character$UnicodeScript): final static enum constant
            MASARAM_GONDI (java.lang.Character$UnicodeScript): final static enum constant
            NUSHU (java.lang.Character$UnicodeScript): final static enum constant
            SOYOMBO (java.lang.Character$UnicodeScript): final static enum constant
            ZANABAZAR_SQUARE (java.lang.Character$UnicodeScript): final static enum constant
            UNKNOWN (java.lang.Character$UnicodeScript): final static enum constant
        
        """
        COMMON: typing.ClassVar['Character.UnicodeScript'] = ...
        LATIN: typing.ClassVar['Character.UnicodeScript'] = ...
        GREEK: typing.ClassVar['Character.UnicodeScript'] = ...
        CYRILLIC: typing.ClassVar['Character.UnicodeScript'] = ...
        ARMENIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        HEBREW: typing.ClassVar['Character.UnicodeScript'] = ...
        ARABIC: typing.ClassVar['Character.UnicodeScript'] = ...
        SYRIAC: typing.ClassVar['Character.UnicodeScript'] = ...
        THAANA: typing.ClassVar['Character.UnicodeScript'] = ...
        DEVANAGARI: typing.ClassVar['Character.UnicodeScript'] = ...
        BENGALI: typing.ClassVar['Character.UnicodeScript'] = ...
        GURMUKHI: typing.ClassVar['Character.UnicodeScript'] = ...
        GUJARATI: typing.ClassVar['Character.UnicodeScript'] = ...
        ORIYA: typing.ClassVar['Character.UnicodeScript'] = ...
        TAMIL: typing.ClassVar['Character.UnicodeScript'] = ...
        TELUGU: typing.ClassVar['Character.UnicodeScript'] = ...
        KANNADA: typing.ClassVar['Character.UnicodeScript'] = ...
        MALAYALAM: typing.ClassVar['Character.UnicodeScript'] = ...
        SINHALA: typing.ClassVar['Character.UnicodeScript'] = ...
        THAI: typing.ClassVar['Character.UnicodeScript'] = ...
        LAO: typing.ClassVar['Character.UnicodeScript'] = ...
        TIBETAN: typing.ClassVar['Character.UnicodeScript'] = ...
        MYANMAR: typing.ClassVar['Character.UnicodeScript'] = ...
        GEORGIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        HANGUL: typing.ClassVar['Character.UnicodeScript'] = ...
        ETHIOPIC: typing.ClassVar['Character.UnicodeScript'] = ...
        CHEROKEE: typing.ClassVar['Character.UnicodeScript'] = ...
        CANADIAN_ABORIGINAL: typing.ClassVar['Character.UnicodeScript'] = ...
        OGHAM: typing.ClassVar['Character.UnicodeScript'] = ...
        RUNIC: typing.ClassVar['Character.UnicodeScript'] = ...
        KHMER: typing.ClassVar['Character.UnicodeScript'] = ...
        MONGOLIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        HIRAGANA: typing.ClassVar['Character.UnicodeScript'] = ...
        KATAKANA: typing.ClassVar['Character.UnicodeScript'] = ...
        BOPOMOFO: typing.ClassVar['Character.UnicodeScript'] = ...
        HAN: typing.ClassVar['Character.UnicodeScript'] = ...
        YI: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_ITALIC: typing.ClassVar['Character.UnicodeScript'] = ...
        GOTHIC: typing.ClassVar['Character.UnicodeScript'] = ...
        DESERET: typing.ClassVar['Character.UnicodeScript'] = ...
        INHERITED: typing.ClassVar['Character.UnicodeScript'] = ...
        TAGALOG: typing.ClassVar['Character.UnicodeScript'] = ...
        HANUNOO: typing.ClassVar['Character.UnicodeScript'] = ...
        BUHID: typing.ClassVar['Character.UnicodeScript'] = ...
        TAGBANWA: typing.ClassVar['Character.UnicodeScript'] = ...
        LIMBU: typing.ClassVar['Character.UnicodeScript'] = ...
        TAI_LE: typing.ClassVar['Character.UnicodeScript'] = ...
        LINEAR_B: typing.ClassVar['Character.UnicodeScript'] = ...
        UGARITIC: typing.ClassVar['Character.UnicodeScript'] = ...
        SHAVIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        OSMANYA: typing.ClassVar['Character.UnicodeScript'] = ...
        CYPRIOT: typing.ClassVar['Character.UnicodeScript'] = ...
        BRAILLE: typing.ClassVar['Character.UnicodeScript'] = ...
        BUGINESE: typing.ClassVar['Character.UnicodeScript'] = ...
        COPTIC: typing.ClassVar['Character.UnicodeScript'] = ...
        NEW_TAI_LUE: typing.ClassVar['Character.UnicodeScript'] = ...
        GLAGOLITIC: typing.ClassVar['Character.UnicodeScript'] = ...
        TIFINAGH: typing.ClassVar['Character.UnicodeScript'] = ...
        SYLOTI_NAGRI: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_PERSIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        KHAROSHTHI: typing.ClassVar['Character.UnicodeScript'] = ...
        BALINESE: typing.ClassVar['Character.UnicodeScript'] = ...
        CUNEIFORM: typing.ClassVar['Character.UnicodeScript'] = ...
        PHOENICIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        PHAGS_PA: typing.ClassVar['Character.UnicodeScript'] = ...
        NKO: typing.ClassVar['Character.UnicodeScript'] = ...
        SUNDANESE: typing.ClassVar['Character.UnicodeScript'] = ...
        BATAK: typing.ClassVar['Character.UnicodeScript'] = ...
        LEPCHA: typing.ClassVar['Character.UnicodeScript'] = ...
        OL_CHIKI: typing.ClassVar['Character.UnicodeScript'] = ...
        VAI: typing.ClassVar['Character.UnicodeScript'] = ...
        SAURASHTRA: typing.ClassVar['Character.UnicodeScript'] = ...
        KAYAH_LI: typing.ClassVar['Character.UnicodeScript'] = ...
        REJANG: typing.ClassVar['Character.UnicodeScript'] = ...
        LYCIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        CARIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        LYDIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        CHAM: typing.ClassVar['Character.UnicodeScript'] = ...
        TAI_THAM: typing.ClassVar['Character.UnicodeScript'] = ...
        TAI_VIET: typing.ClassVar['Character.UnicodeScript'] = ...
        AVESTAN: typing.ClassVar['Character.UnicodeScript'] = ...
        EGYPTIAN_HIEROGLYPHS: typing.ClassVar['Character.UnicodeScript'] = ...
        SAMARITAN: typing.ClassVar['Character.UnicodeScript'] = ...
        MANDAIC: typing.ClassVar['Character.UnicodeScript'] = ...
        LISU: typing.ClassVar['Character.UnicodeScript'] = ...
        BAMUM: typing.ClassVar['Character.UnicodeScript'] = ...
        JAVANESE: typing.ClassVar['Character.UnicodeScript'] = ...
        MEETEI_MAYEK: typing.ClassVar['Character.UnicodeScript'] = ...
        IMPERIAL_ARAMAIC: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_SOUTH_ARABIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        INSCRIPTIONAL_PARTHIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        INSCRIPTIONAL_PAHLAVI: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_TURKIC: typing.ClassVar['Character.UnicodeScript'] = ...
        BRAHMI: typing.ClassVar['Character.UnicodeScript'] = ...
        KAITHI: typing.ClassVar['Character.UnicodeScript'] = ...
        MEROITIC_HIEROGLYPHS: typing.ClassVar['Character.UnicodeScript'] = ...
        MEROITIC_CURSIVE: typing.ClassVar['Character.UnicodeScript'] = ...
        SORA_SOMPENG: typing.ClassVar['Character.UnicodeScript'] = ...
        CHAKMA: typing.ClassVar['Character.UnicodeScript'] = ...
        SHARADA: typing.ClassVar['Character.UnicodeScript'] = ...
        TAKRI: typing.ClassVar['Character.UnicodeScript'] = ...
        MIAO: typing.ClassVar['Character.UnicodeScript'] = ...
        CAUCASIAN_ALBANIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        BASSA_VAH: typing.ClassVar['Character.UnicodeScript'] = ...
        DUPLOYAN: typing.ClassVar['Character.UnicodeScript'] = ...
        ELBASAN: typing.ClassVar['Character.UnicodeScript'] = ...
        GRANTHA: typing.ClassVar['Character.UnicodeScript'] = ...
        PAHAWH_HMONG: typing.ClassVar['Character.UnicodeScript'] = ...
        KHOJKI: typing.ClassVar['Character.UnicodeScript'] = ...
        LINEAR_A: typing.ClassVar['Character.UnicodeScript'] = ...
        MAHAJANI: typing.ClassVar['Character.UnicodeScript'] = ...
        MANICHAEAN: typing.ClassVar['Character.UnicodeScript'] = ...
        MENDE_KIKAKUI: typing.ClassVar['Character.UnicodeScript'] = ...
        MODI: typing.ClassVar['Character.UnicodeScript'] = ...
        MRO: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_NORTH_ARABIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        NABATAEAN: typing.ClassVar['Character.UnicodeScript'] = ...
        PALMYRENE: typing.ClassVar['Character.UnicodeScript'] = ...
        PAU_CIN_HAU: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_PERMIC: typing.ClassVar['Character.UnicodeScript'] = ...
        PSALTER_PAHLAVI: typing.ClassVar['Character.UnicodeScript'] = ...
        SIDDHAM: typing.ClassVar['Character.UnicodeScript'] = ...
        KHUDAWADI: typing.ClassVar['Character.UnicodeScript'] = ...
        TIRHUTA: typing.ClassVar['Character.UnicodeScript'] = ...
        WARANG_CITI: typing.ClassVar['Character.UnicodeScript'] = ...
        AHOM: typing.ClassVar['Character.UnicodeScript'] = ...
        ANATOLIAN_HIEROGLYPHS: typing.ClassVar['Character.UnicodeScript'] = ...
        HATRAN: typing.ClassVar['Character.UnicodeScript'] = ...
        MULTANI: typing.ClassVar['Character.UnicodeScript'] = ...
        OLD_HUNGARIAN: typing.ClassVar['Character.UnicodeScript'] = ...
        SIGNWRITING: typing.ClassVar['Character.UnicodeScript'] = ...
        ADLAM: typing.ClassVar['Character.UnicodeScript'] = ...
        BHAIKSUKI: typing.ClassVar['Character.UnicodeScript'] = ...
        MARCHEN: typing.ClassVar['Character.UnicodeScript'] = ...
        NEWA: typing.ClassVar['Character.UnicodeScript'] = ...
        OSAGE: typing.ClassVar['Character.UnicodeScript'] = ...
        TANGUT: typing.ClassVar['Character.UnicodeScript'] = ...
        MASARAM_GONDI: typing.ClassVar['Character.UnicodeScript'] = ...
        NUSHU: typing.ClassVar['Character.UnicodeScript'] = ...
        SOYOMBO: typing.ClassVar['Character.UnicodeScript'] = ...
        ZANABAZAR_SQUARE: typing.ClassVar['Character.UnicodeScript'] = ...
        UNKNOWN: typing.ClassVar['Character.UnicodeScript'] = ...
        @classmethod
        def forName(cls, string: String) -> 'Character.UnicodeScript': ...
        @classmethod
        def of(cls, int: int) -> 'Character.UnicodeScript': ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: String) -> 'Character.UnicodeScript': ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_1__T], string: String) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> typing.List['Character.UnicodeScript']: ...

class Package(java.lang.NamedPackage, java.lang.reflect.AnnotatedElement):
    """
    Java class 'java.lang.Package'
    
        Extends:
            java.lang.NamedPackage
    
        Interfaces:
            java.lang.reflect.AnnotatedElement
    
    """
    _getAnnotation__A = typing.TypeVar('_getAnnotation__A', bound=java.lang.annotation.Annotation)  # <A>
    def getAnnotation(self, class_: typing.Type[_getAnnotation__A]) -> _getAnnotation__A: ...
    def getAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__A = typing.TypeVar('_getAnnotationsByType__A', bound=java.lang.annotation.Annotation)  # <A>
    def getAnnotationsByType(self, class_: typing.Type[_getAnnotationsByType__A]) -> typing.List[_getAnnotationsByType__A]: ...
    _getDeclaredAnnotation__A = typing.TypeVar('_getDeclaredAnnotation__A', bound=java.lang.annotation.Annotation)  # <A>
    def getDeclaredAnnotation(self, class_: typing.Type[_getDeclaredAnnotation__A]) -> _getDeclaredAnnotation__A: ...
    def getDeclaredAnnotations(self) -> typing.List[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__A = typing.TypeVar('_getDeclaredAnnotationsByType__A', bound=java.lang.annotation.Annotation)  # <A>
    def getDeclaredAnnotationsByType(self, class_: typing.Type[_getDeclaredAnnotationsByType__A]) -> typing.List[_getDeclaredAnnotationsByType__A]: ...
    def getImplementationTitle(self) -> String: ...
    def getImplementationVendor(self) -> String: ...
    def getImplementationVersion(self) -> String: ...
    def getName(self) -> String: ...
    @classmethod
    def getPackage(cls, string: String) -> 'Package': ...
    @classmethod
    def getPackages(cls) -> typing.List['Package']: ...
    def getSpecificationTitle(self) -> String: ...
    def getSpecificationVendor(self) -> String: ...
    def getSpecificationVersion(self) -> String: ...
    def hashCode(self) -> int: ...
    def isAnnotationPresent(self, class_: typing.Type[java.lang.annotation.Annotation]) -> bool: ...
    def isCompatibleWith(self, string: String) -> bool: ...
    @typing.overload
    def isSealed(self) -> bool: ...
    @typing.overload
    def isSealed(self, uRL: java.net.URL) -> bool: ...
    def toString(self) -> String: ...

class StringBuffer(java.lang.AbstractStringBuilder, java.io.Serializable, Comparable[java.lang.StringBuffer]):
    """
    Java class 'java.lang.StringBuffer'
    
        Extends:
            java.lang.AbstractStringBuilder
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable,
            java.lang.CharSequence
    
      Constructors:
        * StringBuffer(java.lang.CharSequence)
        * StringBuffer(java.lang.String)
        * StringBuffer(int)
        * StringBuffer()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, charSequence: CharSequence): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def append(self, boolean: bool) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, char: str) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str]) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str], int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, double: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, float: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, object: typing.Any) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, stringBuffer: 'StringBuffer') -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, long: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, char: str) -> Appendable: ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> Appendable: ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> Appendable: ...
    @typing.overload
    def append(self, boolean: bool) -> 'StringBuffer': ...
    @typing.overload
    def append(self, char: str) -> 'StringBuffer': ...
    @typing.overload
    def append(self, charArray: typing.List[str]) -> 'StringBuffer': ...
    @typing.overload
    def append(self, charArray: typing.List[str], int: int, int2: int) -> 'StringBuffer': ...
    @typing.overload
    def append(self, double: float) -> 'StringBuffer': ...
    @typing.overload
    def append(self, float: float) -> 'StringBuffer': ...
    @typing.overload
    def append(self, int: int) -> 'StringBuffer': ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> 'StringBuffer': ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> 'StringBuffer': ...
    @typing.overload
    def append(self, object: typing.Any) -> 'StringBuffer': ...
    @typing.overload
    def append(self, string: String) -> 'StringBuffer': ...
    @typing.overload
    def append(self, stringBuffer: 'StringBuffer') -> 'StringBuffer': ...
    @typing.overload
    def append(self, long: int) -> 'StringBuffer': ...
    @typing.overload
    def appendCodePoint(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def appendCodePoint(self, int: int) -> 'StringBuffer': ...
    def capacity(self) -> int: ...
    def charAt(self, int: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, int: int) -> int: ...
    def codePointBefore(self, int: int) -> int: ...
    def codePointCount(self, int: int, int2: int) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, stringBuffer: 'StringBuffer') -> int: ...
    @typing.overload
    def delete(self, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def delete(self, int: int, int2: int) -> 'StringBuffer': ...
    @typing.overload
    def deleteCharAt(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def deleteCharAt(self, int: int) -> 'StringBuffer': ...
    def ensureCapacity(self, int: int) -> None: ...
    def getChars(self, int: int, int2: int, charArray: typing.List[str], int3: int) -> None: ...
    @typing.overload
    def indexOf(self, string: String) -> int: ...
    @typing.overload
    def indexOf(self, string: String, int: int) -> int: ...
    @typing.overload
    def insert(self, int: int, boolean: bool) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, char: str) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str]) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str], int2: int, int3: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, double: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, float: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence, int2: int, int3: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, object: typing.Any) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, long: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, boolean: bool) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, double: float) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, float: float) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, int2: int) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, long: int) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, char: str) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str]) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str], int2: int, int3: int) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence, int2: int, int3: int) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, object: typing.Any) -> 'StringBuffer': ...
    @typing.overload
    def insert(self, int: int, string: String) -> 'StringBuffer': ...
    @typing.overload
    def lastIndexOf(self, string: String) -> int: ...
    @typing.overload
    def lastIndexOf(self, string: String, int: int) -> int: ...
    def length(self) -> int: ...
    def offsetByCodePoints(self, int: int, int2: int) -> int: ...
    @typing.overload
    def replace(self, int: int, int2: int, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def replace(self, int: int, int2: int, string: String) -> 'StringBuffer': ...
    @typing.overload
    def reverse(self) -> 'AbstractStringBuilder': ...
    @typing.overload
    def reverse(self) -> 'StringBuffer': ...
    def setCharAt(self, int: int, char: str) -> None: ...
    def setLength(self, int: int) -> None: ...
    def subSequence(self, int: int, int2: int) -> CharSequence: ...
    @typing.overload
    def substring(self, int: int) -> String: ...
    @typing.overload
    def substring(self, int: int, int2: int) -> String: ...
    def toString(self) -> String: ...
    def trimToSize(self) -> None: ...

class StringBuilder(java.lang.AbstractStringBuilder, java.io.Serializable, Comparable[java.lang.StringBuilder]):
    """
    Java class 'java.lang.StringBuilder'
    
        Extends:
            java.lang.AbstractStringBuilder
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable,
            java.lang.CharSequence
    
      Constructors:
        * StringBuilder(java.lang.CharSequence)
        * StringBuilder(java.lang.String)
        * StringBuilder(int)
        * StringBuilder()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, charSequence: CharSequence): ...
    @typing.overload
    def __init__(self, string: String): ...
    @typing.overload
    def append(self, boolean: bool) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, char: str) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str]) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str], int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, double: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, float: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, object: typing.Any) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, stringBuffer: StringBuffer) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, long: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def append(self, char: str) -> Appendable: ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> Appendable: ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> Appendable: ...
    @typing.overload
    def append(self, boolean: bool) -> 'StringBuilder': ...
    @typing.overload
    def append(self, char: str) -> 'StringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str]) -> 'StringBuilder': ...
    @typing.overload
    def append(self, charArray: typing.List[str], int: int, int2: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, double: float) -> 'StringBuilder': ...
    @typing.overload
    def append(self, float: float) -> 'StringBuilder': ...
    @typing.overload
    def append(self, int: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence) -> 'StringBuilder': ...
    @typing.overload
    def append(self, charSequence: CharSequence, int: int, int2: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, object: typing.Any) -> 'StringBuilder': ...
    @typing.overload
    def append(self, string: String) -> 'StringBuilder': ...
    @typing.overload
    def append(self, stringBuffer: StringBuffer) -> 'StringBuilder': ...
    @typing.overload
    def append(self, long: int) -> 'StringBuilder': ...
    @typing.overload
    def appendCodePoint(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def appendCodePoint(self, int: int) -> 'StringBuilder': ...
    def capacity(self) -> int: ...
    def charAt(self, int: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, int: int) -> int: ...
    def codePointBefore(self, int: int) -> int: ...
    def codePointCount(self, int: int, int2: int) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, stringBuilder: 'StringBuilder') -> int: ...
    @typing.overload
    def delete(self, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def delete(self, int: int, int2: int) -> 'StringBuilder': ...
    @typing.overload
    def deleteCharAt(self, int: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def deleteCharAt(self, int: int) -> 'StringBuilder': ...
    def ensureCapacity(self, int: int) -> None: ...
    def getChars(self, int: int, int2: int, charArray: typing.List[str], int3: int) -> None: ...
    @typing.overload
    def indexOf(self, string: String) -> int: ...
    @typing.overload
    def indexOf(self, string: String, int: int) -> int: ...
    @typing.overload
    def insert(self, int: int, boolean: bool) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, char: str) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str]) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str], int2: int, int3: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, double: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, float: float) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, int2: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence, int2: int, int3: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, object: typing.Any) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, long: int) -> 'AbstractStringBuilder': ...
    @typing.overload
    def insert(self, int: int, boolean: bool) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, char: str) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str]) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, charArray: typing.List[str], int2: int, int3: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, double: float) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, float: float) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, int2: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, charSequence: CharSequence, int2: int, int3: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, object: typing.Any) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, string: String) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, int: int, long: int) -> 'StringBuilder': ...
    @typing.overload
    def lastIndexOf(self, string: String) -> int: ...
    @typing.overload
    def lastIndexOf(self, string: String, int: int) -> int: ...
    def length(self) -> int: ...
    def offsetByCodePoints(self, int: int, int2: int) -> int: ...
    @typing.overload
    def replace(self, int: int, int2: int, string: String) -> 'AbstractStringBuilder': ...
    @typing.overload
    def replace(self, int: int, int2: int, string: String) -> 'StringBuilder': ...
    @typing.overload
    def reverse(self) -> 'AbstractStringBuilder': ...
    @typing.overload
    def reverse(self) -> 'StringBuilder': ...
    def setCharAt(self, int: int, char: str) -> None: ...
    def setLength(self, int: int) -> None: ...
    def subSequence(self, int: int, int2: int) -> CharSequence: ...
    @typing.overload
    def substring(self, int: int) -> String: ...
    @typing.overload
    def substring(self, int: int, int2: int) -> String: ...
    def toString(self) -> String: ...
    def trimToSize(self) -> None: ...

class AbstractStringBuilder: ...

class NamedPackage: ...

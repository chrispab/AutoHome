import java
import java.io
import java.lang
import java.lang.reflect
import java.nio
import java.util
import typing


class CallSite(java.lang.Object):
    """
    Java class 'java.lang.invoke.CallSite'
    
        Extends:
            java.lang.Object
    
    """
    def dynamicInvoker(self) -> 'MethodHandle': ...
    def getTarget(self) -> 'MethodHandle': ...
    def setTarget(self, methodHandle: 'MethodHandle') -> None: ...
    def type(self) -> 'MethodType': ...

class ConstantBootstraps(java.lang.Object):
    """
    Java class 'java.lang.invoke.ConstantBootstraps'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ConstantBootstraps()
    
    """
    def __init__(self): ...
    @classmethod
    def arrayVarHandle(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type['VarHandle'], class2: typing.Type[typing.Any]) -> 'VarHandle': ...
    _enumConstant__E = typing.TypeVar('_enumConstant__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def enumConstant(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[_enumConstant__E]) -> _enumConstant__E: ...
    @classmethod
    def fieldVarHandle(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type['VarHandle'], class2: typing.Type[typing.Any], class3: typing.Type[typing.Any]) -> 'VarHandle': ...
    @classmethod
    @typing.overload
    def getStaticFinal(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[typing.Any]) -> typing.Any: ...
    @classmethod
    @typing.overload
    def getStaticFinal(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[typing.Any], class2: typing.Type[typing.Any]) -> typing.Any: ...
    @classmethod
    def invoke(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[typing.Any], methodHandle: 'MethodHandle', objectArray: typing.List[typing.Any]) -> typing.Any: ...
    @classmethod
    def nullConstant(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[typing.Any]) -> typing.Any: ...
    @classmethod
    def primitiveClass(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @classmethod
    def staticFieldVarHandle(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, class_: typing.Type['VarHandle'], class2: typing.Type[typing.Any], class3: typing.Type[typing.Any]) -> 'VarHandle': ...

class LambdaConversionException(java.lang.Exception):
    """
    Java class 'java.lang.invoke.LambdaConversionException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * LambdaConversionException(java.lang.String, java.lang.Throwable, boolean, boolean)
        * LambdaConversionException(java.lang.Throwable)
        * LambdaConversionException(java.lang.String, java.lang.Throwable)
        * LambdaConversionException(java.lang.String)
        * LambdaConversionException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable, boolean: bool, boolean2: bool): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class LambdaMetafactory(java.lang.Object):
    """
    Java class 'java.lang.invoke.LambdaMetafactory'
    
        Extends:
            java.lang.Object
    
      Attributes:
        FLAG_SERIALIZABLE (int): final static field
        FLAG_MARKERS (int): final static field
        FLAG_BRIDGES (int): final static field
    
    """
    FLAG_SERIALIZABLE: typing.ClassVar[int] = ...
    FLAG_MARKERS: typing.ClassVar[int] = ...
    FLAG_BRIDGES: typing.ClassVar[int] = ...
    @classmethod
    def altMetafactory(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, methodType: 'MethodType', objectArray: typing.List[typing.Any]) -> CallSite: ...
    @classmethod
    def metafactory(cls, lookup: 'MethodHandles.Lookup', string: java.lang.String, methodType: 'MethodType', methodType2: 'MethodType', methodHandle: 'MethodHandle', methodType3: 'MethodType') -> CallSite: ...

class MethodHandle(java.lang.Object):
    """
    Java class 'java.lang.invoke.MethodHandle'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    def asCollector(self, int: int, class_: typing.Type[typing.Any], int2: int) -> 'MethodHandle': ...
    @typing.overload
    def asCollector(self, class_: typing.Type[typing.Any], int: int) -> 'MethodHandle': ...
    def asFixedArity(self) -> 'MethodHandle': ...
    @typing.overload
    def asSpreader(self, int: int, class_: typing.Type[typing.Any], int2: int) -> 'MethodHandle': ...
    @typing.overload
    def asSpreader(self, class_: typing.Type[typing.Any], int: int) -> 'MethodHandle': ...
    def asType(self, methodType: 'MethodType') -> 'MethodHandle': ...
    def asVarargsCollector(self, class_: typing.Type[typing.Any]) -> 'MethodHandle': ...
    def bindTo(self, object: typing.Any) -> 'MethodHandle': ...
    def invoke(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def invokeExact(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    @typing.overload
    def invokeWithArguments(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    @typing.overload
    def invokeWithArguments(self, list: java.util.List[typing.Any]) -> typing.Any: ...
    def isVarargsCollector(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def type(self) -> 'MethodType': ...
    def withVarargs(self, boolean: bool) -> 'MethodHandle': ...

class MethodHandleInfo(java.lang.Object):
    """
    public interface MethodHandleInfo
    
        A symbolic reference obtained by cracking a direct method handle into its consitutent symbolic parts. To crack a direct
        method handle, call :meth:`~java.lang.invoke.MethodHandles.Lookup.revealDirect`.
    
        :class:`~java.lang.invoke`Direct Method Handles
    -----------------------------------------------
    
        A *direct method handle* represents a method, constructor, or field without any intervening argument bindings or other
        transformations. The method, constructor, or field referred to by a direct method handle is called its *underlying
        member*. Direct method handles may be obtained in any of these ways:
    
          - By executing an :code:`ldc` instruction on a :code:`CONSTANT_MethodHandle` constant. (See the Java Virtual Machine
            Specification, sections 4.4.8 and 5.4.3.)
          - By calling one of the :meth:`~java.lang.invoke.MethodHandles.Lookup.lookups`, such as
            :meth:`~java.lang.invoke.MethodHandles.Lookup.findVirtual`, to resolve a symbolic reference into a method handle. A
            symbolic reference consists of a class, name string, and type.
          - By calling the factory method :meth:`~java.lang.invoke.MethodHandles.Lookup.unreflect` or
            :meth:`~java.lang.invoke.MethodHandles.Lookup.unreflectSpecial` to convert a :class:`~java.lang.reflect.Method` into a
            method handle.
          - By calling the factory method :meth:`~java.lang.invoke.MethodHandles.Lookup.unreflectConstructor` to convert a
            :class:`~java.lang.reflect.Constructor` into a method handle.
          - By calling the factory method :meth:`~java.lang.invoke.MethodHandles.Lookup.unreflectGetter` or
            :meth:`~java.lang.invoke.MethodHandles.Lookup.unreflectSetter` to convert a :class:`~java.lang.reflect.Field` into a
            method handle.
    
    
        Restrictions on Cracking
    ------------------------
    
        Given a suitable :code:`Lookup` object, it is possible to crack any direct method handle to recover a symbolic reference
        for the underlying method, constructor, or field. Cracking must be done via a :code:`Lookup` object equivalent to that
        which created the target method handle, or which has enough access permissions to recreate an equivalent method handle.
    
        If the underlying method is :meth:`~java.lang.invoke.MethodHandles.Lookup.callsens`, the direct method handle will have
        been "bound" to a particular caller class, the :meth:`~java.lang.invoke.MethodHandles.Lookup.lookupClass` of the lookup
        object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying
        method is public (like :code:`Class.forName`).
    
        The requirement of lookup object matching provides a "fast fail" behavior for programs which may otherwise trust
        erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use
        :meth:`~java.lang.invoke.MethodHandles.reflectAs` to override this limitation.
    
        :class:`~java.lang.invoke`Reference kinds
    -----------------------------------------
    
        The :meth:`~java.lang.invoke.MethodHandles.Lookup.lookups` correspond to all major use cases for methods, constructors,
        and fields. These use cases may be distinguished using small integers as follows:
    
        Since:
            1.8
    
    
    """
    REF_getField: typing.ClassVar[int] = ...
    REF_getStatic: typing.ClassVar[int] = ...
    REF_putField: typing.ClassVar[int] = ...
    REF_putStatic: typing.ClassVar[int] = ...
    REF_invokeVirtual: typing.ClassVar[int] = ...
    REF_invokeStatic: typing.ClassVar[int] = ...
    REF_invokeSpecial: typing.ClassVar[int] = ...
    REF_newInvokeSpecial: typing.ClassVar[int] = ...
    REF_invokeInterface: typing.ClassVar[int] = ...
    def getDeclaringClass(self) -> typing.Type[typing.Any]: ...
    def getMethodType(self) -> 'MethodType': ...
    def getModifiers(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getReferenceKind(self) -> int: ...
    def isVarArgs(self) -> bool: ...
    @classmethod
    def referenceKindToString(cls, int: int) -> java.lang.String: ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    def reflectAs(self, class_: typing.Type[_reflectAs__T], lookup: 'MethodHandles.Lookup') -> _reflectAs__T: ...
    @classmethod
    def toString(cls, int: int, class_: typing.Type[typing.Any], string: java.lang.String, methodType: 'MethodType') -> java.lang.String: ...

class MethodHandleProxies(java.lang.Object):
    """
    Java class 'java.lang.invoke.MethodHandleProxies'
    
        Extends:
            java.lang.Object
    
    """
    _asInterfaceInstance__T = typing.TypeVar('_asInterfaceInstance__T')  # <T>
    @classmethod
    def asInterfaceInstance(cls, class_: typing.Type[_asInterfaceInstance__T], methodHandle: MethodHandle) -> _asInterfaceInstance__T: ...
    @classmethod
    def isWrapperInstance(cls, object: typing.Any) -> bool: ...
    @classmethod
    def wrapperInstanceTarget(cls, object: typing.Any) -> MethodHandle: ...
    @classmethod
    def wrapperInstanceType(cls, object: typing.Any) -> typing.Type[typing.Any]: ...

class MethodHandles(java.lang.Object):
    """
    Java class 'java.lang.invoke.MethodHandles'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def arrayConstructor(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @classmethod
    def arrayElementGetter(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @classmethod
    def arrayElementSetter(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @classmethod
    def arrayElementVarHandle(cls, class_: typing.Type[typing.Any]) -> 'VarHandle': ...
    @classmethod
    def arrayLength(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @classmethod
    def byteArrayViewVarHandle(cls, class_: typing.Type[typing.Any], byteOrder: java.nio.ByteOrder) -> 'VarHandle': ...
    @classmethod
    def byteBufferViewVarHandle(cls, class_: typing.Type[typing.Any], byteOrder: java.nio.ByteOrder) -> 'VarHandle': ...
    @classmethod
    def catchException(cls, methodHandle: MethodHandle, class_: typing.Type[java.lang.Throwable], methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def collectArguments(cls, methodHandle: MethodHandle, int: int, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def constant(cls, class_: typing.Type[typing.Any], object: typing.Any) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def countedLoop(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def countedLoop(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle, methodHandle4: MethodHandle) -> MethodHandle: ...
    @classmethod
    def doWhileLoop(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def dropArguments(cls, methodHandle: MethodHandle, int: int, classArray: typing.List[typing.Type[typing.Any]]) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def dropArguments(cls, methodHandle: MethodHandle, int: int, list: java.util.List[typing.Type[typing.Any]]) -> MethodHandle: ...
    @classmethod
    def dropArgumentsToMatch(cls, methodHandle: MethodHandle, int: int, list: java.util.List[typing.Type[typing.Any]], int2: int) -> MethodHandle: ...
    @classmethod
    def empty(cls, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def exactInvoker(cls, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def explicitCastArguments(cls, methodHandle: MethodHandle, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def filterArguments(cls, methodHandle: MethodHandle, int: int, methodHandleArray: typing.List[MethodHandle]) -> MethodHandle: ...
    @classmethod
    def filterReturnValue(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def foldArguments(cls, methodHandle: MethodHandle, int: int, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    @typing.overload
    def foldArguments(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def guardWithTest(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    def identity(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @classmethod
    def insertArguments(cls, methodHandle: MethodHandle, int: int, objectArray: typing.List[typing.Any]) -> MethodHandle: ...
    @classmethod
    def invoker(cls, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def iteratedLoop(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    def lookup(cls) -> 'MethodHandles.Lookup': ...
    @classmethod
    def loop(cls, methodHandleArray: typing.List[typing.List[MethodHandle]]) -> MethodHandle: ...
    @classmethod
    def permuteArguments(cls, methodHandle: MethodHandle, methodType: 'MethodType', intArray: typing.List[int]) -> MethodHandle: ...
    @classmethod
    def privateLookupIn(cls, class_: typing.Type[typing.Any], lookup: 'MethodHandles.Lookup') -> 'MethodHandles.Lookup': ...
    @classmethod
    def publicLookup(cls) -> 'MethodHandles.Lookup': ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    @classmethod
    def reflectAs(cls, class_: typing.Type[_reflectAs__T], methodHandle: MethodHandle) -> _reflectAs__T: ...
    @classmethod
    def spreadInvoker(cls, methodType: 'MethodType', int: int) -> MethodHandle: ...
    @classmethod
    def throwException(cls, class_: typing.Type[typing.Any], class2: typing.Type[java.lang.Throwable]) -> MethodHandle: ...
    @classmethod
    def tryFinally(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def varHandleExactInvoker(cls, accessMode: 'VarHandle.AccessMode', methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def varHandleInvoker(cls, accessMode: 'VarHandle.AccessMode', methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def whileLoop(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    def zero(cls, class_: typing.Type[typing.Any]) -> MethodHandle: ...
    class Lookup(java.lang.Object):
        """
        Java class 'java.lang.invoke.MethodHandles$Lookup'
        
            Extends:
                java.lang.Object
        
          Attributes:
            PUBLIC (int): final static field
            PRIVATE (int): final static field
            PROTECTED (int): final static field
            PACKAGE (int): final static field
            MODULE (int): final static field
            UNCONDITIONAL (int): final static field
        
        """
        PUBLIC: typing.ClassVar[int] = ...
        PRIVATE: typing.ClassVar[int] = ...
        PROTECTED: typing.ClassVar[int] = ...
        PACKAGE: typing.ClassVar[int] = ...
        MODULE: typing.ClassVar[int] = ...
        UNCONDITIONAL: typing.ClassVar[int] = ...
        def accessClass(self, class_: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
        def bind(self, object: typing.Any, string: java.lang.String, methodType: 'MethodType') -> MethodHandle: ...
        def defineClass(self, byteArray: typing.List[int]) -> typing.Type[typing.Any]: ...
        def dropLookupMode(self, int: int) -> 'MethodHandles.Lookup': ...
        def findClass(self, string: java.lang.String) -> typing.Type[typing.Any]: ...
        def findConstructor(self, class_: typing.Type[typing.Any], methodType: 'MethodType') -> MethodHandle: ...
        def findGetter(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findSetter(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findSpecial(self, class_: typing.Type[typing.Any], string: java.lang.String, methodType: 'MethodType', class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findStatic(self, class_: typing.Type[typing.Any], string: java.lang.String, methodType: 'MethodType') -> MethodHandle: ...
        def findStaticGetter(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findStaticSetter(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findStaticVarHandle(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> 'VarHandle': ...
        def findVarHandle(self, class_: typing.Type[typing.Any], string: java.lang.String, class2: typing.Type[typing.Any]) -> 'VarHandle': ...
        def findVirtual(self, class_: typing.Type[typing.Any], string: java.lang.String, methodType: 'MethodType') -> MethodHandle: ...
        def hasPrivateAccess(self) -> bool: ...
        def lookupClass(self) -> typing.Type[typing.Any]: ...
        def lookupModes(self) -> int: ...
        def revealDirect(self, methodHandle: MethodHandle) -> MethodHandleInfo: ...
        def toString(self) -> java.lang.String: ...
        def unreflect(self, method: java.lang.reflect.Method) -> MethodHandle: ...
        def unreflectConstructor(self, constructor: java.lang.reflect.Constructor[typing.Any]) -> MethodHandle: ...
        def unreflectGetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSpecial(self, method: java.lang.reflect.Method, class_: typing.Type[typing.Any]) -> MethodHandle: ...
        def unreflectVarHandle(self, field: java.lang.reflect.Field) -> 'VarHandle': ...

class MethodType(java.io.Serializable):
    """
    Java class 'java.lang.invoke.MethodType'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    @typing.overload
    def appendParameterTypes(self, classArray: typing.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @typing.overload
    def appendParameterTypes(self, list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    def changeParameterType(self, int: int, class_: typing.Type[typing.Any]) -> 'MethodType': ...
    def changeReturnType(self, class_: typing.Type[typing.Any]) -> 'MethodType': ...
    def dropParameterTypes(self, int: int, int2: int) -> 'MethodType': ...
    def equals(self, object: typing.Any) -> bool: ...
    def erase(self) -> 'MethodType': ...
    @classmethod
    def fromMethodDescriptorString(cls, string: java.lang.String, classLoader: java.lang.ClassLoader) -> 'MethodType': ...
    def generic(self) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def genericMethodType(cls, int: int) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def genericMethodType(cls, int: int, boolean: bool) -> 'MethodType': ...
    def hasPrimitives(self) -> bool: ...
    def hasWrappers(self) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def insertParameterTypes(self, int: int, classArray: typing.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @typing.overload
    def insertParameterTypes(self, int: int, list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    def lastParameterType(self) -> typing.Type[typing.Any]: ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any]) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any], class2: typing.Type[typing.Any]) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any], class2: typing.Type[typing.Any], classArray: typing.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any], classArray: typing.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any], methodType: 'MethodType') -> 'MethodType': ...
    @classmethod
    @typing.overload
    def methodType(cls, class_: typing.Type[typing.Any], list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    def parameterArray(self) -> typing.List[typing.Type[typing.Any]]: ...
    def parameterCount(self) -> int: ...
    def parameterList(self) -> java.util.List[typing.Type[typing.Any]]: ...
    def parameterType(self, int: int) -> typing.Type[typing.Any]: ...
    def returnType(self) -> typing.Type[typing.Any]: ...
    def toMethodDescriptorString(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def unwrap(self) -> 'MethodType': ...
    def wrap(self) -> 'MethodType': ...

class SerializedLambda(java.io.Serializable):
    """
    Java class 'java.lang.invoke.SerializedLambda'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * SerializedLambda(java.lang.Class, java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
    
    """
    def __init__(self, class_: typing.Type[typing.Any], string: java.lang.String, string2: java.lang.String, string3: java.lang.String, int: int, string4: java.lang.String, string5: java.lang.String, string6: java.lang.String, string7: java.lang.String, objectArray: typing.List[typing.Any]): ...
    def getCapturedArg(self, int: int) -> typing.Any: ...
    def getCapturedArgCount(self) -> int: ...
    def getCapturingClass(self) -> java.lang.String: ...
    def getFunctionalInterfaceClass(self) -> java.lang.String: ...
    def getFunctionalInterfaceMethodName(self) -> java.lang.String: ...
    def getFunctionalInterfaceMethodSignature(self) -> java.lang.String: ...
    def getImplClass(self) -> java.lang.String: ...
    def getImplMethodKind(self) -> int: ...
    def getImplMethodName(self) -> java.lang.String: ...
    def getImplMethodSignature(self) -> java.lang.String: ...
    def getInstantiatedMethodType(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class StringConcatException(java.lang.Exception):
    """
    Java class 'java.lang.invoke.StringConcatException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * StringConcatException(java.lang.String)
        * StringConcatException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...

class StringConcatFactory(java.lang.Object):
    """
    Java class 'java.lang.invoke.StringConcatFactory'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def makeConcat(cls, lookup: MethodHandles.Lookup, string: java.lang.String, methodType: MethodType) -> CallSite: ...
    @classmethod
    def makeConcatWithConstants(cls, lookup: MethodHandles.Lookup, string: java.lang.String, methodType: MethodType, string2: java.lang.String, objectArray: typing.List[typing.Any]) -> CallSite: ...

class SwitchPoint(java.lang.Object):
    """
    Java class 'java.lang.invoke.SwitchPoint'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * SwitchPoint()
    
    """
    def __init__(self): ...
    def guardWithTest(self, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    def hasBeenInvalidated(self) -> bool: ...
    @classmethod
    def invalidateAll(cls, switchPointArray: typing.List['SwitchPoint']) -> None: ...

class VarHandle(java.lang.Object):
    """
    Java class 'java.lang.invoke.VarHandle'
    
        Extends:
            java.lang.Object
    
    """
    def accessModeType(self, accessMode: 'VarHandle.AccessMode') -> MethodType: ...
    @classmethod
    def acquireFence(cls) -> None: ...
    def compareAndExchange(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def compareAndExchangeAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def compareAndExchangeRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def compareAndSet(self, objectArray: typing.List[typing.Any]) -> bool: ...
    def coordinateTypes(self) -> java.util.List[typing.Type[typing.Any]]: ...
    @classmethod
    def fullFence(cls) -> None: ...
    def get(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndAdd(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndAddAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndAddRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseAnd(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseAndAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseAndRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseOr(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseOrAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseOrRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseXor(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseXorAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndBitwiseXorRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndSet(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndSetAcquire(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getAndSetRelease(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getOpaque(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def getVolatile(self, objectArray: typing.List[typing.Any]) -> typing.Any: ...
    def isAccessModeSupported(self, accessMode: 'VarHandle.AccessMode') -> bool: ...
    @classmethod
    def loadLoadFence(cls) -> None: ...
    @classmethod
    def releaseFence(cls) -> None: ...
    def set(self, objectArray: typing.List[typing.Any]) -> None: ...
    def setOpaque(self, objectArray: typing.List[typing.Any]) -> None: ...
    def setRelease(self, objectArray: typing.List[typing.Any]) -> None: ...
    def setVolatile(self, objectArray: typing.List[typing.Any]) -> None: ...
    @classmethod
    def storeStoreFence(cls) -> None: ...
    def toMethodHandle(self, accessMode: 'VarHandle.AccessMode') -> MethodHandle: ...
    def varType(self) -> typing.Type[typing.Any]: ...
    def weakCompareAndSet(self, objectArray: typing.List[typing.Any]) -> bool: ...
    def weakCompareAndSetAcquire(self, objectArray: typing.List[typing.Any]) -> bool: ...
    def weakCompareAndSetPlain(self, objectArray: typing.List[typing.Any]) -> bool: ...
    def weakCompareAndSetRelease(self, objectArray: typing.List[typing.Any]) -> bool: ...
    class AccessMode(java.lang.Enum[java.lang.invoke.VarHandle.AccessMode]):
        """
        Java class 'java.lang.invoke.VarHandle$AccessMode'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            GET (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            SET (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_VOLATILE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            SET_VOLATILE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            SET_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_OPAQUE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            SET_OPAQUE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            COMPARE_AND_SET (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            COMPARE_AND_EXCHANGE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            COMPARE_AND_EXCHANGE_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            COMPARE_AND_EXCHANGE_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            WEAK_COMPARE_AND_SET_PLAIN (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            WEAK_COMPARE_AND_SET (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            WEAK_COMPARE_AND_SET_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            WEAK_COMPARE_AND_SET_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_SET (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_SET_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_SET_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_ADD (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_ADD_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_ADD_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_OR (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_OR_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_OR_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_AND (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_AND_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_AND_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_XOR (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_XOR_RELEASE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
            GET_AND_BITWISE_XOR_ACQUIRE (java.lang.invoke.VarHandle$AccessMode): final static enum constant
        
        """
        GET: typing.ClassVar['VarHandle.AccessMode'] = ...
        SET: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_VOLATILE: typing.ClassVar['VarHandle.AccessMode'] = ...
        SET_VOLATILE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        SET_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_OPAQUE: typing.ClassVar['VarHandle.AccessMode'] = ...
        SET_OPAQUE: typing.ClassVar['VarHandle.AccessMode'] = ...
        COMPARE_AND_SET: typing.ClassVar['VarHandle.AccessMode'] = ...
        COMPARE_AND_EXCHANGE: typing.ClassVar['VarHandle.AccessMode'] = ...
        COMPARE_AND_EXCHANGE_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        COMPARE_AND_EXCHANGE_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        WEAK_COMPARE_AND_SET_PLAIN: typing.ClassVar['VarHandle.AccessMode'] = ...
        WEAK_COMPARE_AND_SET: typing.ClassVar['VarHandle.AccessMode'] = ...
        WEAK_COMPARE_AND_SET_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        WEAK_COMPARE_AND_SET_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_SET: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_SET_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_SET_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_ADD: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_ADD_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_ADD_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_OR: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_OR_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_OR_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_AND: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_AND_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_AND_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_XOR: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_XOR_RELEASE: typing.ClassVar['VarHandle.AccessMode'] = ...
        GET_AND_BITWISE_XOR_ACQUIRE: typing.ClassVar['VarHandle.AccessMode'] = ...
        def methodName(self) -> java.lang.String: ...
        @classmethod
        def valueFromMethodName(cls, string: java.lang.String) -> 'VarHandle.AccessMode': ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'VarHandle.AccessMode': ...
        @classmethod
        def values(cls) -> typing.List['VarHandle.AccessMode']: ...

class WrongMethodTypeException(java.lang.RuntimeException):
    """
    Java class 'java.lang.invoke.WrongMethodTypeException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * WrongMethodTypeException(java.lang.String)
        * WrongMethodTypeException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ConstantCallSite(CallSite):
    """
    Java class 'java.lang.invoke.ConstantCallSite'
    
        Extends:
            java.lang.invoke.CallSite
    
      Constructors:
        * ConstantCallSite(java.lang.invoke.MethodHandle)
    
    """
    def __init__(self, methodHandle: MethodHandle): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...

class MutableCallSite(CallSite):
    """
    Java class 'java.lang.invoke.MutableCallSite'
    
        Extends:
            java.lang.invoke.CallSite
    
      Constructors:
        * MutableCallSite(java.lang.invoke.MethodType)
        * MutableCallSite(java.lang.invoke.MethodHandle)
    
    """
    @typing.overload
    def __init__(self, methodHandle: MethodHandle): ...
    @typing.overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...
    @classmethod
    def syncAll(cls, mutableCallSiteArray: typing.List['MutableCallSite']) -> None: ...

class VolatileCallSite(CallSite):
    """
    Java class 'java.lang.invoke.VolatileCallSite'
    
        Extends:
            java.lang.invoke.CallSite
    
      Constructors:
        * VolatileCallSite(java.lang.invoke.MethodType)
        * VolatileCallSite(java.lang.invoke.MethodHandle)
    
    """
    @typing.overload
    def __init__(self, methodHandle: MethodHandle): ...
    @typing.overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...

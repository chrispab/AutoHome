import java
import java.io
import java.lang
import java.security
import java.time
import java.time.temporal
import java.util
import java.util.function
import java.util.stream
import typing


_BlockingQueue__E = typing.TypeVar('_BlockingQueue__E')  # <E>
class BlockingQueue(java.util.Queue[_BlockingQueue__E], typing.Generic[_BlockingQueue__E]):
    """
    Java class 'java.util.concurrent.BlockingQueue'
    
        Interfaces:
            java.util.Queue
    
    """
    def add(self, e: _BlockingQueue__E) -> bool: ...
    def contains(self, object: typing.Any) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_BlockingQueue__E], typing.Sequence[_BlockingQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_BlockingQueue__E], typing.Sequence[_BlockingQueue__E]], int: int) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def offer(self, e: _BlockingQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _BlockingQueue__E, long: int, timeUnit: 'TimeUnit') -> bool: ...
    @typing.overload
    def poll(self) -> _BlockingQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: 'TimeUnit') -> _BlockingQueue__E: ...
    def put(self, e: _BlockingQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _BlockingQueue__E: ...
    def take(self) -> _BlockingQueue__E: ...

class BrokenBarrierException(java.lang.Exception):
    """
    Java class 'java.util.concurrent.BrokenBarrierException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * BrokenBarrierException()
        * BrokenBarrierException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

_Callable__V = typing.TypeVar('_Callable__V')  # <V>
class Callable(java.lang.Object, typing.Generic[_Callable__V]):
    """
    :class:`~java.lang.FunctionalInterface` public interface Callable<V>
    
        A task that returns a result and may throw an exception. Implementors define a single method with no arguments called
        :code:`call`.
    
        The :code:`Callable` interface is similar to :class:`~java.lang.Runnable`, in that both are designed for classes whose
        instances are potentially executed by another thread. A :code:`Runnable`, however, does not return a result and cannot
        throw a checked exception.
    
        The :class:`~java.util.concurrent.Executors` class contains utility methods to convert from other common forms to
        :code:`Callable` classes.
    
        Since:
            1.5
    
        Also see:
            :class:`~java.util.concurrent.Executor`
    
    
    """
    def call(self) -> _Callable__V: ...

class CancellationException(java.lang.IllegalStateException):
    """
    Java class 'java.util.concurrent.CancellationException'
    
        Extends:
            java.lang.IllegalStateException
    
      Constructors:
        * CancellationException()
        * CancellationException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class CompletionException(java.lang.RuntimeException):
    """
    Java class 'java.util.concurrent.CompletionException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * CompletionException(java.lang.Throwable)
        * CompletionException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

_CompletionService__V = typing.TypeVar('_CompletionService__V')  # <V>
class CompletionService(java.lang.Object, typing.Generic[_CompletionService__V]):
    """
    public interface CompletionService<V>
    
        A service that decouples the production of new asynchronous tasks from the consumption of the results of completed
        tasks. Producers :code:`submit` tasks for execution. Consumers :code:`take` completed tasks and process their results in
        the order they complete. A :code:`CompletionService` can for example be used to manage asynchronous I/O, in which tasks
        that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the
        program when the reads complete, possibly in a different order than they were requested.
    
        Typically, a :code:`CompletionService` relies on a separate :class:`~java.util.concurrent.Executor` to actually execute
        the tasks, in which case the :code:`CompletionService` only manages an internal completion queue. The
        :class:`~java.util.concurrent.ExecutorCompletionService` class provides an implementation of this approach.
    
        Memory consistency effects: Actions in a thread prior to submitting a task to a :code:`CompletionService`
        :meth:`~java.util.concurrent.package` actions taken by that task, which in turn *happen-before* actions following a
        successful return from the corresponding :code:`take()`.
    
        Since:
            1.5
    
    
    """
    @typing.overload
    def poll(self) -> 'Future'[_CompletionService__V]: ...
    @typing.overload
    def poll(self, long: int, timeUnit: 'TimeUnit') -> 'Future'[_CompletionService__V]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, v: _CompletionService__V) -> 'Future'[_CompletionService__V]: ...
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_CompletionService__V], typing.Callable[[], _CompletionService__V]]) -> 'Future'[_CompletionService__V]: ...
    def take(self) -> 'Future'[_CompletionService__V]: ...

_CompletionStage__T = typing.TypeVar('_CompletionStage__T')  # <T>
class CompletionStage(java.lang.Object, typing.Generic[_CompletionStage__T]):
    """
    public interface CompletionStage<T>
    
        A stage of a possibly asynchronous computation, that performs an action or computes a value when another CompletionStage
        completes. A stage completes upon termination of its computation, but this may in turn trigger other dependent stages.
        The functionality defined in this interface takes only a few basic forms, which expand out to a larger set of methods to
        capture a range of usage styles:
    
          - The computation performed by a stage may be expressed as a Function, Consumer, or Runnable (using methods with names
            including *apply*, *accept*, or *run*, respectively) depending on whether it requires arguments and/or produces results.
            For example:
    
            .. code-block: java
            
             
             stage.thenApply(x -> square(x))
                  .thenAccept(x -> System.out.print(x))
                  .thenRun(() -> System.out.println());
    An additional form (*compose*) allows the construction of computation pipelines from functions returning completion
            stages.
    
            Any argument to a stage's computation is the outcome of a triggering stage's computation.
          - One stage's execution may be triggered by completion of a single stage, or both of two stages, or either of two stages.
            Dependencies on a single stage are arranged using methods with prefix *then*. Those triggered by completion of *both* of
            two stages may *combine* their results or effects, using correspondingly named methods. Those triggered by *either* of
            two stages make no guarantees about which of the results or effects are used for the dependent stage's computation.
          - Dependencies among stages control the triggering of computations, but do not otherwise guarantee any particular
            ordering. Additionally, execution of a new stage's computations may be arranged in any of three ways: default execution,
            default asynchronous execution (using methods with suffix *async* that employ the stage's default asynchronous execution
            facility), or custom (via a supplied :class:`~java.util.concurrent.Executor`). The execution properties of default and
            async modes are specified by CompletionStage implementations, not this interface. Methods with explicit Executor
            arguments may have arbitrary execution properties, and might not even support concurrent execution, but are arranged for
            processing in a way that accommodates asynchrony.
          - Two method forms (:meth:`~java.util.concurrent.CompletionStage.handle` and
            :meth:`~java.util.concurrent.CompletionStage.whenComplete`) support unconditional computation whether the triggering
            stage completed normally or exceptionally. Method :meth:`~java.util.concurrent.CompletionStage.exceptionally` supports
            computation only when the triggering stage completes exceptionally, computing a replacement result, similarly to the
            java :code:`catch` keyword. In all other cases, if a stage's computation terminates abruptly with an (unchecked)
            exception or error, then all dependent stages requiring its completion complete exceptionally as well, with a
            :class:`~java.util.concurrent.CompletionException` holding the exception as its cause. If a stage is dependent on *both*
            of two stages, and both complete exceptionally, then the CompletionException may correspond to either one of these
            exceptions. If a stage is dependent on *either* of two others, and only one of them completes exceptionally, no
            guarantees are made about whether the dependent stage completes normally or exceptionally. In the case of method
            :code:`whenComplete`, when the supplied action itself encounters an exception, then the stage completes exceptionally
            with this exception unless the source stage also completed exceptionally, in which case the exceptional completion from
            the source stage is given preference and propagated to the dependent stage.
    
    
        All methods adhere to the above triggering, execution, and exceptional completion specifications (which are not repeated
        in individual method specifications). Additionally, while arguments used to pass a completion result (that is, for
        parameters of type :code:`T`) for methods accepting them may be null, passing a null value for any other parameter will
        result in a :class:`~java.lang.NullPointerException` being thrown.
    
        Method form :meth:`~java.util.concurrent.CompletionStage.handle` is the most general way of creating a continuation
        stage, unconditionally performing a computation that is given both the result and exception (if any) of the triggering
        CompletionStage, and computing an arbitrary result. Method :meth:`~java.util.concurrent.CompletionStage.whenComplete` is
        similar, but preserves the result of the triggering stage instead of computing a new one. Because a stage's normal
        result may be :code:`null`, both methods should have a computation structured thus:
    
        .. code-block: java
        
        (result, exception) -> {
           if (exception == null) {
             // triggering stage completed normally
           } else {
             // triggering stage completed exceptionally
           }
         }
    
        This interface does not define methods for initially creating, forcibly completing normally or exceptionally, probing
        completion status or results, or awaiting completion of a stage. Implementations of CompletionStage may provide means of
        achieving such effects, as appropriate. Method :meth:`~java.util.concurrent.CompletionStage.toCompletableFuture` enables
        interoperability among different implementations of this interface by providing a common conversion type.
    
        Since:
            1.8
    
    
    """
    def acceptEither(self, completionStage: 'CompletionStage'[_CompletionStage__T], consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]]) -> 'CompletionStage'[None]: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: 'CompletionStage'[_CompletionStage__T], consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]]) -> 'CompletionStage'[None]: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: 'CompletionStage'[_CompletionStage__T], consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]], executor: 'Executor') -> 'CompletionStage'[None]: ...
    _applyToEither__U = typing.TypeVar('_applyToEither__U')  # <U>
    def applyToEither(self, completionStage: 'CompletionStage'[_CompletionStage__T], function: typing.Union[java.util.function.Function[_CompletionStage__T, _applyToEither__U], typing.Callable[[_CompletionStage__T], _applyToEither__U]]) -> 'CompletionStage'[_applyToEither__U]: ...
    _applyToEitherAsync_0__U = typing.TypeVar('_applyToEitherAsync_0__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, completionStage: 'CompletionStage'[_CompletionStage__T], function: typing.Union[java.util.function.Function[_CompletionStage__T, _applyToEitherAsync_0__U], typing.Callable[[_CompletionStage__T], _applyToEitherAsync_0__U]]) -> 'CompletionStage'[_applyToEitherAsync_0__U]: ...
    _applyToEitherAsync_1__U = typing.TypeVar('_applyToEitherAsync_1__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, completionStage: 'CompletionStage'[_CompletionStage__T], function: typing.Union[java.util.function.Function[_CompletionStage__T, _applyToEitherAsync_1__U], typing.Callable[[_CompletionStage__T], _applyToEitherAsync_1__U]], executor: 'Executor') -> 'CompletionStage'[_applyToEitherAsync_1__U]: ...
    def exceptionally(self, function: typing.Union[java.util.function.Function[java.lang.Throwable, _CompletionStage__T], typing.Callable[[java.lang.Throwable], _CompletionStage__T]]) -> 'CompletionStage'[_CompletionStage__T]: ...
    _handle__U = typing.TypeVar('_handle__U')  # <U>
    def handle(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handle__U], typing.Callable[[_CompletionStage__T, java.lang.Throwable], _handle__U]]) -> 'CompletionStage'[_handle__U]: ...
    _handleAsync_0__U = typing.TypeVar('_handleAsync_0__U')  # <U>
    @typing.overload
    def handleAsync(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handleAsync_0__U], typing.Callable[[_CompletionStage__T, java.lang.Throwable], _handleAsync_0__U]]) -> 'CompletionStage'[_handleAsync_0__U]: ...
    _handleAsync_1__U = typing.TypeVar('_handleAsync_1__U')  # <U>
    @typing.overload
    def handleAsync(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handleAsync_1__U], typing.Callable[[_CompletionStage__T, java.lang.Throwable], _handleAsync_1__U]], executor: 'Executor') -> 'CompletionStage'[_handleAsync_1__U]: ...
    def runAfterBoth(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable, executor: 'Executor') -> 'CompletionStage'[None]: ...
    def runAfterEither(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: 'CompletionStage'[typing.Any], runnable: java.lang.Runnable, executor: 'Executor') -> 'CompletionStage'[None]: ...
    def thenAccept(self, consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]]) -> 'CompletionStage'[None]: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]]) -> 'CompletionStage'[None]: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: typing.Union[java.util.function.Consumer[_CompletionStage__T], typing.Callable[[], _CompletionStage__T]], executor: 'Executor') -> 'CompletionStage'[None]: ...
    _thenAcceptBoth__U = typing.TypeVar('_thenAcceptBoth__U')  # <U>
    def thenAcceptBoth(self, completionStage: 'CompletionStage'[_thenAcceptBoth__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBoth__U], typing.Callable[[_CompletionStage__T], _thenAcceptBoth__U]]) -> 'CompletionStage'[None]: ...
    _thenAcceptBothAsync_0__U = typing.TypeVar('_thenAcceptBothAsync_0__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: 'CompletionStage'[_thenAcceptBothAsync_0__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBothAsync_0__U], typing.Callable[[_CompletionStage__T], _thenAcceptBothAsync_0__U]]) -> 'CompletionStage'[None]: ...
    _thenAcceptBothAsync_1__U = typing.TypeVar('_thenAcceptBothAsync_1__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: 'CompletionStage'[_thenAcceptBothAsync_1__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBothAsync_1__U], typing.Callable[[_CompletionStage__T], _thenAcceptBothAsync_1__U]], executor: 'Executor') -> 'CompletionStage'[None]: ...
    _thenApply__U = typing.TypeVar('_thenApply__U')  # <U>
    def thenApply(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, _thenApply__U], typing.Callable[[_CompletionStage__T], _thenApply__U]]) -> 'CompletionStage'[_thenApply__U]: ...
    _thenApplyAsync_0__U = typing.TypeVar('_thenApplyAsync_0__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, _thenApplyAsync_0__U], typing.Callable[[_CompletionStage__T], _thenApplyAsync_0__U]]) -> 'CompletionStage'[_thenApplyAsync_0__U]: ...
    _thenApplyAsync_1__U = typing.TypeVar('_thenApplyAsync_1__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, _thenApplyAsync_1__U], typing.Callable[[_CompletionStage__T], _thenApplyAsync_1__U]], executor: 'Executor') -> 'CompletionStage'[_thenApplyAsync_1__U]: ...
    _thenCombine__U = typing.TypeVar('_thenCombine__U')  # <U>
    _thenCombine__V = typing.TypeVar('_thenCombine__V')  # <V>
    def thenCombine(self, completionStage: 'CompletionStage'[_thenCombine__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, _thenCombine__U, _thenCombine__V], typing.Callable[[_CompletionStage__T, _thenCombine__U], _thenCombine__V]]) -> 'CompletionStage'[_thenCombine__V]: ...
    _thenCombineAsync_0__U = typing.TypeVar('_thenCombineAsync_0__U')  # <U>
    _thenCombineAsync_0__V = typing.TypeVar('_thenCombineAsync_0__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, completionStage: 'CompletionStage'[_thenCombineAsync_0__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, _thenCombineAsync_0__U, _thenCombineAsync_0__V], typing.Callable[[_CompletionStage__T, _thenCombineAsync_0__U], _thenCombineAsync_0__V]]) -> 'CompletionStage'[_thenCombineAsync_0__V]: ...
    _thenCombineAsync_1__U = typing.TypeVar('_thenCombineAsync_1__U')  # <U>
    _thenCombineAsync_1__V = typing.TypeVar('_thenCombineAsync_1__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, completionStage: 'CompletionStage'[_thenCombineAsync_1__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletionStage__T, _thenCombineAsync_1__U, _thenCombineAsync_1__V], typing.Callable[[_CompletionStage__T, _thenCombineAsync_1__U], _thenCombineAsync_1__V]], executor: 'Executor') -> 'CompletionStage'[_thenCombineAsync_1__V]: ...
    _thenCompose__U = typing.TypeVar('_thenCompose__U')  # <U>
    def thenCompose(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, 'CompletionStage'[_thenCompose__U]], typing.Callable[[_CompletionStage__T], 'CompletionStage'[_thenCompose__U]]]) -> 'CompletionStage'[_thenCompose__U]: ...
    _thenComposeAsync_0__U = typing.TypeVar('_thenComposeAsync_0__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, 'CompletionStage'[_thenComposeAsync_0__U]], typing.Callable[[_CompletionStage__T], 'CompletionStage'[_thenComposeAsync_0__U]]]) -> 'CompletionStage'[_thenComposeAsync_0__U]: ...
    _thenComposeAsync_1__U = typing.TypeVar('_thenComposeAsync_1__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, function: typing.Union[java.util.function.Function[_CompletionStage__T, 'CompletionStage'[_thenComposeAsync_1__U]], typing.Callable[[_CompletionStage__T], 'CompletionStage'[_thenComposeAsync_1__U]]], executor: 'Executor') -> 'CompletionStage'[_thenComposeAsync_1__U]: ...
    def thenRun(self, runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable) -> 'CompletionStage'[None]: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable, executor: 'Executor') -> 'CompletionStage'[None]: ...
    def toCompletableFuture(self) -> 'CompletableFuture'[_CompletionStage__T]: ...
    def whenComplete(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], typing.Callable[[_CompletionStage__T], java.lang.Throwable]]) -> 'CompletionStage'[_CompletionStage__T]: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], typing.Callable[[_CompletionStage__T], java.lang.Throwable]]) -> 'CompletionStage'[_CompletionStage__T]: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], typing.Callable[[_CompletionStage__T], java.lang.Throwable]], executor: 'Executor') -> 'CompletionStage'[_CompletionStage__T]: ...

_ConcurrentLinkedDeque__E = typing.TypeVar('_ConcurrentLinkedDeque__E')  # <E>
class ConcurrentLinkedDeque(java.util.AbstractCollection[_ConcurrentLinkedDeque__E], java.util.Deque[_ConcurrentLinkedDeque__E], java.io.Serializable, typing.Generic[_ConcurrentLinkedDeque__E]):
    """
    Java class 'java.util.concurrent.ConcurrentLinkedDeque'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.util.Deque, java.io.Serializable
    
      Constructors:
        * ConcurrentLinkedDeque(java.util.Collection)
        * ConcurrentLinkedDeque()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_ConcurrentLinkedDeque__E], typing.Sequence[_ConcurrentLinkedDeque__E]]): ...
    def add(self, e: _ConcurrentLinkedDeque__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_ConcurrentLinkedDeque__E], typing.Sequence[_ConcurrentLinkedDeque__E]]) -> bool: ...
    def addFirst(self, e: _ConcurrentLinkedDeque__E) -> None: ...
    def addLast(self, e: _ConcurrentLinkedDeque__E) -> None: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_ConcurrentLinkedDeque__E]: ...
    def element(self) -> _ConcurrentLinkedDeque__E: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ConcurrentLinkedDeque__E], typing.Callable[[], _ConcurrentLinkedDeque__E]]) -> None: ...
    def getFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def getLast(self) -> _ConcurrentLinkedDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentLinkedDeque__E]: ...
    def offer(self, e: _ConcurrentLinkedDeque__E) -> bool: ...
    def offerFirst(self, e: _ConcurrentLinkedDeque__E) -> bool: ...
    def offerLast(self, e: _ConcurrentLinkedDeque__E) -> bool: ...
    def peek(self) -> _ConcurrentLinkedDeque__E: ...
    def peekFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def peekLast(self) -> _ConcurrentLinkedDeque__E: ...
    def poll(self) -> _ConcurrentLinkedDeque__E: ...
    def pollFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def pollLast(self) -> _ConcurrentLinkedDeque__E: ...
    def pop(self) -> _ConcurrentLinkedDeque__E: ...
    def push(self, e: _ConcurrentLinkedDeque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ConcurrentLinkedDeque__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ConcurrentLinkedDeque__E], typing.Callable[[], _ConcurrentLinkedDeque__E]]) -> bool: ...
    def removeLast(self) -> _ConcurrentLinkedDeque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentLinkedDeque__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_ConcurrentLinkedQueue__E = typing.TypeVar('_ConcurrentLinkedQueue__E')  # <E>
class ConcurrentLinkedQueue(java.util.AbstractQueue[_ConcurrentLinkedQueue__E], java.util.Queue[_ConcurrentLinkedQueue__E], java.io.Serializable, typing.Generic[_ConcurrentLinkedQueue__E]):
    """
    Java class 'java.util.concurrent.ConcurrentLinkedQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.Queue, java.io.Serializable
    
      Constructors:
        * ConcurrentLinkedQueue()
        * ConcurrentLinkedQueue(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_ConcurrentLinkedQueue__E], typing.Sequence[_ConcurrentLinkedQueue__E]]): ...
    def add(self, e: _ConcurrentLinkedQueue__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_ConcurrentLinkedQueue__E], typing.Sequence[_ConcurrentLinkedQueue__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ConcurrentLinkedQueue__E], typing.Callable[[], _ConcurrentLinkedQueue__E]]) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentLinkedQueue__E]: ...
    def offer(self, e: _ConcurrentLinkedQueue__E) -> bool: ...
    def peek(self) -> _ConcurrentLinkedQueue__E: ...
    def poll(self) -> _ConcurrentLinkedQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ConcurrentLinkedQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ConcurrentLinkedQueue__E], typing.Callable[[], _ConcurrentLinkedQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentLinkedQueue__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_ConcurrentMap__K = typing.TypeVar('_ConcurrentMap__K')  # <K>
_ConcurrentMap__V = typing.TypeVar('_ConcurrentMap__V')  # <V>
class ConcurrentMap(java.util.Map[_ConcurrentMap__K, _ConcurrentMap__V], typing.Generic[_ConcurrentMap__K, _ConcurrentMap__V]):
    """
    Java class 'java.util.concurrent.ConcurrentMap'
    
        Interfaces:
            java.util.Map
    
    """
    def compute(self, k: _ConcurrentMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__K, _ConcurrentMap__V], _ConcurrentMap__V]]) -> _ConcurrentMap__V: ...
    def computeIfAbsent(self, k: _ConcurrentMap__K, function: typing.Union[java.util.function.Function[_ConcurrentMap__K, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__K], _ConcurrentMap__V]]) -> _ConcurrentMap__V: ...
    def computeIfPresent(self, k: _ConcurrentMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__K, _ConcurrentMap__V], _ConcurrentMap__V]]) -> _ConcurrentMap__V: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_ConcurrentMap__K, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__K], _ConcurrentMap__V]]) -> None: ...
    def getOrDefault(self, object: typing.Any, v: _ConcurrentMap__V) -> _ConcurrentMap__V: ...
    def hashCode(self) -> int: ...
    def merge(self, k: _ConcurrentMap__K, v: _ConcurrentMap__V, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentMap__V, _ConcurrentMap__V, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__V, _ConcurrentMap__V], _ConcurrentMap__V]]) -> _ConcurrentMap__V: ...
    def putIfAbsent(self, k: _ConcurrentMap__K, v: _ConcurrentMap__V) -> _ConcurrentMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ConcurrentMap__V: ...
    @typing.overload
    def replace(self, k: _ConcurrentMap__K, v: _ConcurrentMap__V, v2: _ConcurrentMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ConcurrentMap__K, v: _ConcurrentMap__V) -> _ConcurrentMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], typing.Callable[[_ConcurrentMap__K, _ConcurrentMap__V], _ConcurrentMap__V]]) -> None: ...

_ConcurrentSkipListSet__E = typing.TypeVar('_ConcurrentSkipListSet__E')  # <E>
class ConcurrentSkipListSet(java.util.AbstractSet[_ConcurrentSkipListSet__E], java.util.NavigableSet[_ConcurrentSkipListSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_ConcurrentSkipListSet__E]):
    """
    Java class 'java.util.concurrent.ConcurrentSkipListSet'
    
        Extends:
            java.util.AbstractSet
    
        Interfaces:
            java.util.NavigableSet, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * ConcurrentSkipListSet(java.util.SortedSet)
        * ConcurrentSkipListSet(java.util.Collection)
        * ConcurrentSkipListSet(java.util.Comparator)
        * ConcurrentSkipListSet()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_ConcurrentSkipListSet__E], typing.Sequence[_ConcurrentSkipListSet__E]]): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[java.util.Comparator[_ConcurrentSkipListSet__E], typing.Callable[[], _ConcurrentSkipListSet__E]]): ...
    @typing.overload
    def __init__(self, sortedSet: java.util.SortedSet[_ConcurrentSkipListSet__E]): ...
    def add(self, e: _ConcurrentSkipListSet__E) -> bool: ...
    def ceiling(self, e: _ConcurrentSkipListSet__E) -> _ConcurrentSkipListSet__E: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> 'ConcurrentSkipListSet'[_ConcurrentSkipListSet__E]: ...
    def comparator(self) -> java.util.Comparator[_ConcurrentSkipListSet__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_ConcurrentSkipListSet__E]: ...
    def descendingSet(self) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def first(self) -> _ConcurrentSkipListSet__E: ...
    def floor(self, e: _ConcurrentSkipListSet__E) -> _ConcurrentSkipListSet__E: ...
    @typing.overload
    def headSet(self, e: _ConcurrentSkipListSet__E) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def headSet(self, e: _ConcurrentSkipListSet__E, boolean: bool) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def headSet(self, object: typing.Any) -> java.util.SortedSet: ...
    def higher(self, e: _ConcurrentSkipListSet__E) -> _ConcurrentSkipListSet__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentSkipListSet__E]: ...
    def last(self) -> _ConcurrentSkipListSet__E: ...
    def lower(self, e: _ConcurrentSkipListSet__E) -> _ConcurrentSkipListSet__E: ...
    def pollFirst(self) -> _ConcurrentSkipListSet__E: ...
    def pollLast(self) -> _ConcurrentSkipListSet__E: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def subSet(self, e: _ConcurrentSkipListSet__E, boolean: bool, e2: _ConcurrentSkipListSet__E, boolean2: bool) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def subSet(self, e: _ConcurrentSkipListSet__E, e2: _ConcurrentSkipListSet__E) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def subSet(self, object: typing.Any, object2: typing.Any) -> java.util.SortedSet: ...
    @typing.overload
    def tailSet(self, e: _ConcurrentSkipListSet__E) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def tailSet(self, e: _ConcurrentSkipListSet__E, boolean: bool) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def tailSet(self, object: typing.Any) -> java.util.SortedSet: ...

_CopyOnWriteArrayList__E = typing.TypeVar('_CopyOnWriteArrayList__E')  # <E>
class CopyOnWriteArrayList(java.util.List[_CopyOnWriteArrayList__E], java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable, typing.Generic[_CopyOnWriteArrayList__E]):
    """
    Java class 'java.util.concurrent.CopyOnWriteArrayList'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.List, java.util.RandomAccess, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * CopyOnWriteArrayList(java.util.Collection)
        * CopyOnWriteArrayList()
        * CopyOnWriteArrayList(java.lang.Object[])
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, eArray: typing.List[_CopyOnWriteArrayList__E]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_CopyOnWriteArrayList__E], typing.Sequence[_CopyOnWriteArrayList__E]]): ...
    @typing.overload
    def add(self, e: _CopyOnWriteArrayList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _CopyOnWriteArrayList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[_CopyOnWriteArrayList__E], typing.Sequence[_CopyOnWriteArrayList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[_CopyOnWriteArrayList__E], typing.Sequence[_CopyOnWriteArrayList__E]]) -> bool: ...
    def addAllAbsent(self, collection: typing.Union[java.util.Collection[_CopyOnWriteArrayList__E], typing.Sequence[_CopyOnWriteArrayList__E]]) -> int: ...
    def addIfAbsent(self, e: _CopyOnWriteArrayList__E) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_CopyOnWriteArrayList__E], typing.Callable[[], _CopyOnWriteArrayList__E]]) -> None: ...
    def get(self, int: int) -> _CopyOnWriteArrayList__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def indexOf(self, e: _CopyOnWriteArrayList__E, int: int) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_CopyOnWriteArrayList__E]: ...
    @typing.overload
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def lastIndexOf(self, e: _CopyOnWriteArrayList__E, int: int) -> int: ...
    @typing.overload
    def listIterator(self) -> java.util.ListIterator[_CopyOnWriteArrayList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> java.util.ListIterator[_CopyOnWriteArrayList__E]: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_CopyOnWriteArrayList__E], typing.Callable[[], _CopyOnWriteArrayList__E]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_CopyOnWriteArrayList__E], typing.Callable[[], _CopyOnWriteArrayList__E]]) -> None: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _CopyOnWriteArrayList__E) -> _CopyOnWriteArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[java.util.Comparator[_CopyOnWriteArrayList__E], typing.Callable[[], _CopyOnWriteArrayList__E]]) -> None: ...
    def spliterator(self) -> java.util.Spliterator[_CopyOnWriteArrayList__E]: ...
    def subList(self, int: int, int2: int) -> java.util.List[_CopyOnWriteArrayList__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_CopyOnWriteArraySet__E = typing.TypeVar('_CopyOnWriteArraySet__E')  # <E>
class CopyOnWriteArraySet(java.util.AbstractSet[_CopyOnWriteArraySet__E], java.io.Serializable, typing.Generic[_CopyOnWriteArraySet__E]):
    """
    Java class 'java.util.concurrent.CopyOnWriteArraySet'
    
        Extends:
            java.util.AbstractSet
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * CopyOnWriteArraySet()
        * CopyOnWriteArraySet(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_CopyOnWriteArraySet__E], typing.Sequence[_CopyOnWriteArraySet__E]]): ...
    def add(self, e: _CopyOnWriteArraySet__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_CopyOnWriteArraySet__E], typing.Sequence[_CopyOnWriteArraySet__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_CopyOnWriteArraySet__E], typing.Callable[[], _CopyOnWriteArraySet__E]]) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_CopyOnWriteArraySet__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_CopyOnWriteArraySet__E], typing.Callable[[], _CopyOnWriteArraySet__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_CopyOnWriteArraySet__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

class CountDownLatch(java.lang.Object):
    """
    Java class 'java.util.concurrent.CountDownLatch'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * CountDownLatch(int)
    
    """
    def __init__(self, int: int): ...
    def countDown(self) -> None: ...
    def getCount(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class CyclicBarrier(java.lang.Object):
    """
    Java class 'java.util.concurrent.CyclicBarrier'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * CyclicBarrier(int)
        * CyclicBarrier(int, java.lang.Runnable)
    
    """
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, runnable: java.lang.Runnable): ...
    def getNumberWaiting(self) -> int: ...
    def getParties(self) -> int: ...
    def isBroken(self) -> bool: ...
    def reset(self) -> None: ...

class Delayed(java.lang.Comparable[java.util.concurrent.Delayed]):
    """
    Java class 'java.util.concurrent.Delayed'
    
        Interfaces:
            java.lang.Comparable
    
    """
    def getDelay(self, timeUnit: 'TimeUnit') -> int: ...

_Exchanger__V = typing.TypeVar('_Exchanger__V')  # <V>
class Exchanger(java.lang.Object, typing.Generic[_Exchanger__V]):
    """
    Java class 'java.util.concurrent.Exchanger'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Exchanger()
    
    """
    def __init__(self): ...
    @typing.overload
    def exchange(self, v: _Exchanger__V) -> _Exchanger__V: ...
    @typing.overload
    def exchange(self, v: _Exchanger__V, long: int, timeUnit: 'TimeUnit') -> _Exchanger__V: ...

class ExecutionException(java.lang.Exception):
    """
    Java class 'java.util.concurrent.ExecutionException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * ExecutionException(java.lang.Throwable)
        * ExecutionException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Executor(java.lang.Object):
    """
    public interface Executor
    
        An object that executes submitted :class:`~java.lang.Runnable` tasks. This interface provides a way of decoupling task
        submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An
        :code:`Executor` is normally used instead of explicitly creating threads. For example, rather than invoking :code:`new
        Thread(new RunnableTask()).start()` for each of a set of tasks, you might use:
    
        .. code-block: java
        
         
         Executor executor = anExecutor();
         executor.execute(new RunnableTask1());
         executor.execute(new RunnableTask2());
         ...
        However, the :code:`Executor` interface does not strictly require that execution be asynchronous. In the simplest case,
        an executor can run the submitted task immediately in the caller's thread:
    
        .. code-block: java
        
         
         class DirectExecutor implements Executor {
           public void execute(Runnable r) {
             r.run();
           }
         }
        More typically, tasks are executed in some thread other than the caller's thread. The executor below spawns a new thread
        for each task.
    
        .. code-block: java
        
         
         class ThreadPerTaskExecutor implements Executor {
           public void execute(Runnable r) {
             new Thread(r).start();
           }
         }
        Many :code:`Executor` implementations impose some sort of limitation on how and when tasks are scheduled. The executor
        below serializes the submission of tasks to a second executor, illustrating a composite executor.
    
        .. code-block: java
        
         
         class SerialExecutor implements Executor {
           final Queue<Runnable> tasks = new ArrayDeque<&gt;();
           final Executor executor;
           Runnable active;
        
           SerialExecutor(Executor executor) {
             this.executor = executor;
           }
        
           public synchronized void execute(Runnable r) {
             tasks.add(() -> {
               try {
                 r.run();
               } finally {
                 scheduleNext();
               }
             });
             if (active == null) {
               scheduleNext();
             }
           }
        
           protected synchronized void scheduleNext() {
             if ((active = tasks.poll()) != null) {
               executor.execute(active);
             }
           }
         }
        The :code:`Executor` implementations provided in this package implement :class:`~java.util.concurrent.ExecutorService`,
        which is a more extensive interface. The :class:`~java.util.concurrent.ThreadPoolExecutor` class provides an extensible
        thread pool implementation. The :class:`~java.util.concurrent.Executors` class provides convenient factory methods for
        these Executors.
    
        Memory consistency effects: Actions in a thread prior to submitting a :code:`Runnable` object to an :code:`Executor`
        :meth:`~java.util.concurrent.package` its execution begins, perhaps in another thread.
    
        Since:
            1.5
    
    
    """
    def execute(self, runnable: java.lang.Runnable) -> None: ...

class Executors(java.lang.Object):
    """
    Java class 'java.util.concurrent.Executors'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    @typing.overload
    def callable(cls, runnable: java.lang.Runnable) -> Callable[typing.Any]: ...
    _callable_1__T = typing.TypeVar('_callable_1__T')  # <T>
    @classmethod
    @typing.overload
    def callable(cls, runnable: java.lang.Runnable, t: _callable_1__T) -> Callable[_callable_1__T]: ...
    @classmethod
    @typing.overload
    def callable(cls, privilegedAction: java.security.PrivilegedAction[typing.Any]) -> Callable[typing.Any]: ...
    @classmethod
    @typing.overload
    def callable(cls, privilegedExceptionAction: java.security.PrivilegedExceptionAction[typing.Any]) -> Callable[typing.Any]: ...
    @classmethod
    def defaultThreadFactory(cls) -> 'ThreadFactory': ...
    @classmethod
    @typing.overload
    def newCachedThreadPool(cls) -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newCachedThreadPool(cls, threadFactory: 'ThreadFactory') -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newFixedThreadPool(cls, int: int) -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newFixedThreadPool(cls, int: int, threadFactory: 'ThreadFactory') -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newScheduledThreadPool(cls, int: int) -> 'ScheduledExecutorService': ...
    @classmethod
    @typing.overload
    def newScheduledThreadPool(cls, int: int, threadFactory: 'ThreadFactory') -> 'ScheduledExecutorService': ...
    @classmethod
    @typing.overload
    def newSingleThreadExecutor(cls) -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newSingleThreadExecutor(cls, threadFactory: 'ThreadFactory') -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newSingleThreadScheduledExecutor(cls) -> 'ScheduledExecutorService': ...
    @classmethod
    @typing.overload
    def newSingleThreadScheduledExecutor(cls, threadFactory: 'ThreadFactory') -> 'ScheduledExecutorService': ...
    @classmethod
    @typing.overload
    def newWorkStealingPool(cls) -> 'ExecutorService': ...
    @classmethod
    @typing.overload
    def newWorkStealingPool(cls, int: int) -> 'ExecutorService': ...
    _privilegedCallable__T = typing.TypeVar('_privilegedCallable__T')  # <T>
    @classmethod
    def privilegedCallable(cls, callable: typing.Union[Callable[_privilegedCallable__T], typing.Callable[[], _privilegedCallable__T]]) -> Callable[_privilegedCallable__T]: ...
    _privilegedCallableUsingCurrentClassLoader__T = typing.TypeVar('_privilegedCallableUsingCurrentClassLoader__T')  # <T>
    @classmethod
    def privilegedCallableUsingCurrentClassLoader(cls, callable: typing.Union[Callable[_privilegedCallableUsingCurrentClassLoader__T], typing.Callable[[], _privilegedCallableUsingCurrentClassLoader__T]]) -> Callable[_privilegedCallableUsingCurrentClassLoader__T]: ...
    @classmethod
    def privilegedThreadFactory(cls) -> 'ThreadFactory': ...
    @classmethod
    def unconfigurableExecutorService(cls, executorService: 'ExecutorService') -> 'ExecutorService': ...
    @classmethod
    def unconfigurableScheduledExecutorService(cls, scheduledExecutorService: 'ScheduledExecutorService') -> 'ScheduledExecutorService': ...

class ForkJoinWorkerThread(java.lang.Thread):
    """
    Java class 'java.util.concurrent.ForkJoinWorkerThread'
    
        Extends:
            java.lang.Thread
    
    """
    def getPool(self) -> 'ForkJoinPool': ...
    def getPoolIndex(self) -> int: ...
    def run(self) -> None: ...

_Future__V = typing.TypeVar('_Future__V')  # <V>
class Future(java.lang.Object, typing.Generic[_Future__V]):
    """
    public interface Future<V>
    
        A :code:`Future` represents the result of an asynchronous computation. Methods are provided to check if the computation
        is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved
        using method :code:`get` when the computation has completed, blocking if necessary until it is ready. Cancellation is
        performed by the :code:`cancel` method. Additional methods are provided to determine if the task completed normally or
        was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a
        :code:`Future` for the sake of cancellability but not provide a usable result, you can declare types of the form
        :code:`Future<?>` and return :code:`null` as a result of the underlying task.
    
        **Sample Usage** (Note that the following classes are all made-up.)
    
        .. code-block: java
        
         
         interface ArchiveSearcher { String search(String target); }
         class App {
           ExecutorService executor = ...
           ArchiveSearcher searcher = ...
           void showSearch(String target) throws InterruptedException {
             Callable<String> task = () -> searcher.search(target);
             Future<String> future = executor.submit(task);
             displayOtherThings(); // do other things while searching
             try {
               displayText(future.get()); // use future
             } catch (ExecutionException ex) { cleanup(); return; }
           }
         }
        The :class:`~java.util.concurrent.FutureTask` class is an implementation of :code:`Future` that implements
        :code:`Runnable`, and so may be executed by an :code:`Executor`. For example, the above construction with :code:`submit`
        could be replaced by:
    
        .. code-block: java
        
         
         FutureTask<String> future = new FutureTask<&gt;(task);
         executor.execute(future);
    
        Memory consistency effects: Actions taken by the asynchronous computation :meth:`~java.util.concurrent.package` actions
        following the corresponding :code:`Future.get()` in another thread.
    
        Since:
            1.5
    
        Also see:
            :class:`~java.util.concurrent.FutureTask`, :class:`~java.util.concurrent.Executor`
    
    
    """
    def cancel(self, boolean: bool) -> bool: ...
    @typing.overload
    def get(self) -> _Future__V: ...
    @typing.overload
    def get(self, long: int, timeUnit: 'TimeUnit') -> _Future__V: ...
    def isCancelled(self) -> bool: ...
    def isDone(self) -> bool: ...

class Phaser(java.lang.Object):
    """
    Java class 'java.util.concurrent.Phaser'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Phaser(java.util.concurrent.Phaser, int)
        * Phaser(java.util.concurrent.Phaser)
        * Phaser(int)
        * Phaser()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, phaser: 'Phaser'): ...
    @typing.overload
    def __init__(self, phaser: 'Phaser', int: int): ...
    def arrive(self) -> int: ...
    def arriveAndAwaitAdvance(self) -> int: ...
    def arriveAndDeregister(self) -> int: ...
    def awaitAdvance(self, int: int) -> int: ...
    @typing.overload
    def awaitAdvanceInterruptibly(self, int: int) -> int: ...
    @typing.overload
    def awaitAdvanceInterruptibly(self, int: int, long: int, timeUnit: 'TimeUnit') -> int: ...
    def bulkRegister(self, int: int) -> int: ...
    def forceTermination(self) -> None: ...
    def getArrivedParties(self) -> int: ...
    def getParent(self) -> 'Phaser': ...
    def getPhase(self) -> int: ...
    def getRegisteredParties(self) -> int: ...
    def getRoot(self) -> 'Phaser': ...
    def getUnarrivedParties(self) -> int: ...
    def isTerminated(self) -> bool: ...
    def register(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class RejectedExecutionException(java.lang.RuntimeException):
    """
    Java class 'java.util.concurrent.RejectedExecutionException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * RejectedExecutionException(java.lang.Throwable)
        * RejectedExecutionException(java.lang.String, java.lang.Throwable)
        * RejectedExecutionException(java.lang.String)
        * RejectedExecutionException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class RejectedExecutionHandler(java.lang.Object):
    """
    public interface RejectedExecutionHandler
    
        A handler for tasks that cannot be executed by a :class:`~java.util.concurrent.ThreadPoolExecutor`.
    
        Since:
            1.5
    
    
    """
    def rejectedExecution(self, runnable: java.lang.Runnable, threadPoolExecutor: 'ThreadPoolExecutor') -> None: ...

class Semaphore(java.io.Serializable):
    """
    Java class 'java.util.concurrent.Semaphore'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * Semaphore(int)
        * Semaphore(int, boolean)
    
    """
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, boolean: bool): ...
    @typing.overload
    def acquire(self) -> None: ...
    @typing.overload
    def acquire(self, int: int) -> None: ...
    @typing.overload
    def acquireUninterruptibly(self) -> None: ...
    @typing.overload
    def acquireUninterruptibly(self, int: int) -> None: ...
    def availablePermits(self) -> int: ...
    def drainPermits(self) -> int: ...
    def getQueueLength(self) -> int: ...
    def hasQueuedThreads(self) -> bool: ...
    def isFair(self) -> bool: ...
    @typing.overload
    def release(self) -> None: ...
    @typing.overload
    def release(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def tryAcquire(self) -> bool: ...
    @typing.overload
    def tryAcquire(self, int: int) -> bool: ...
    @typing.overload
    def tryAcquire(self, int: int, long: int, timeUnit: 'TimeUnit') -> bool: ...
    @typing.overload
    def tryAcquire(self, long: int, timeUnit: 'TimeUnit') -> bool: ...

class ThreadFactory(java.lang.Object):
    """
    public interface ThreadFactory
    
        An object that creates new threads on demand. Using thread factories removes hardwiring of calls to
        :meth:`~java.lang.Thread.%3Cinit%3E`, enabling applications to use special thread subclasses, priorities, etc.
    
        The simplest implementation of this interface is just:
    
        .. code-block: java
        
         
         class SimpleThreadFactory implements ThreadFactory {
           public Thread newThread(Runnable r) {
             return new Thread(r);
           }
         }
        The :meth:`~java.util.concurrent.Executors.defaultThreadFactory` method provides a more useful simple implementation,
        that sets the created thread context to known values before returning it.
    
        Since:
            1.5
    
    
    """
    def newThread(self, runnable: java.lang.Runnable) -> java.lang.Thread: ...

class ThreadLocalRandom(java.util.Random):
    """
    Java class 'java.util.concurrent.ThreadLocalRandom'
    
        Extends:
            java.util.Random
    
    """
    @classmethod
    def current(cls) -> 'ThreadLocalRandom': ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextDouble(self) -> float: ...
    @typing.overload
    def nextDouble(self, double: float) -> float: ...
    @typing.overload
    def nextDouble(self, double: float, double2: float) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    @typing.overload
    def nextInt(self, int: int, int2: int) -> int: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, long: int) -> int: ...
    @typing.overload
    def nextLong(self, long: int, long2: int) -> int: ...
    def setSeed(self, long: int) -> None: ...

class TimeUnit(java.lang.Enum[java.util.concurrent.TimeUnit]):
    """
    Java class 'java.util.concurrent.TimeUnit'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        NANOSECONDS (java.util.concurrent.TimeUnit): final static enum constant
        MICROSECONDS (java.util.concurrent.TimeUnit): final static enum constant
        MILLISECONDS (java.util.concurrent.TimeUnit): final static enum constant
        SECONDS (java.util.concurrent.TimeUnit): final static enum constant
        MINUTES (java.util.concurrent.TimeUnit): final static enum constant
        HOURS (java.util.concurrent.TimeUnit): final static enum constant
        DAYS (java.util.concurrent.TimeUnit): final static enum constant
    
    """
    NANOSECONDS: typing.ClassVar['TimeUnit'] = ...
    MICROSECONDS: typing.ClassVar['TimeUnit'] = ...
    MILLISECONDS: typing.ClassVar['TimeUnit'] = ...
    SECONDS: typing.ClassVar['TimeUnit'] = ...
    MINUTES: typing.ClassVar['TimeUnit'] = ...
    HOURS: typing.ClassVar['TimeUnit'] = ...
    DAYS: typing.ClassVar['TimeUnit'] = ...
    @typing.overload
    def convert(self, duration: java.time.Duration) -> int: ...
    @typing.overload
    def convert(self, long: int, timeUnit: 'TimeUnit') -> int: ...
    @classmethod
    def of(cls, chronoUnit: java.time.temporal.ChronoUnit) -> 'TimeUnit': ...
    def sleep(self, long: int) -> None: ...
    def timedJoin(self, thread: java.lang.Thread, long: int) -> None: ...
    def timedWait(self, object: typing.Any, long: int) -> None: ...
    def toChronoUnit(self) -> java.time.temporal.ChronoUnit: ...
    def toDays(self, long: int) -> int: ...
    def toHours(self, long: int) -> int: ...
    def toMicros(self, long: int) -> int: ...
    def toMillis(self, long: int) -> int: ...
    def toMinutes(self, long: int) -> int: ...
    def toNanos(self, long: int) -> int: ...
    def toSeconds(self, long: int) -> int: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'TimeUnit': ...
    @classmethod
    def values(cls) -> typing.List['TimeUnit']: ...

class TimeoutException(java.lang.Exception):
    """
    Java class 'java.util.concurrent.TimeoutException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * TimeoutException()
        * TimeoutException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

_ArrayBlockingQueue__E = typing.TypeVar('_ArrayBlockingQueue__E')  # <E>
class ArrayBlockingQueue(java.util.AbstractQueue[_ArrayBlockingQueue__E], BlockingQueue[_ArrayBlockingQueue__E], java.io.Serializable, typing.Generic[_ArrayBlockingQueue__E]):
    """
    Java class 'java.util.concurrent.ArrayBlockingQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingQueue, java.io.Serializable
    
      Constructors:
        * ArrayBlockingQueue(int)
        * ArrayBlockingQueue(int, boolean)
        * ArrayBlockingQueue(int, boolean, java.util.Collection)
    
    """
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, boolean: bool): ...
    @typing.overload
    def __init__(self, int: int, boolean: bool, collection: typing.Union[java.util.Collection[_ArrayBlockingQueue__E], typing.Sequence[_ArrayBlockingQueue__E]]): ...
    def add(self, e: _ArrayBlockingQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_ArrayBlockingQueue__E], typing.Sequence[_ArrayBlockingQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_ArrayBlockingQueue__E], typing.Sequence[_ArrayBlockingQueue__E]], int: int) -> int: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ArrayBlockingQueue__E], typing.Callable[[], _ArrayBlockingQueue__E]]) -> None: ...
    def iterator(self) -> java.util.Iterator[_ArrayBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _ArrayBlockingQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _ArrayBlockingQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _ArrayBlockingQueue__E: ...
    @typing.overload
    def poll(self) -> _ArrayBlockingQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _ArrayBlockingQueue__E: ...
    def put(self, e: _ArrayBlockingQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ArrayBlockingQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ArrayBlockingQueue__E], typing.Callable[[], _ArrayBlockingQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ArrayBlockingQueue__E]: ...
    def take(self) -> _ArrayBlockingQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_BlockingDeque__E = typing.TypeVar('_BlockingDeque__E')  # <E>
class BlockingDeque(BlockingQueue[_BlockingDeque__E], java.util.Deque[_BlockingDeque__E], typing.Generic[_BlockingDeque__E]):
    """
    Java class 'java.util.concurrent.BlockingDeque'
    
        Interfaces:
            java.util.concurrent.BlockingQueue, java.util.Deque
    
    """
    def add(self, e: _BlockingDeque__E) -> bool: ...
    def addFirst(self, e: _BlockingDeque__E) -> None: ...
    def addLast(self, e: _BlockingDeque__E) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def element(self) -> _BlockingDeque__E: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> java.util.Iterator[_BlockingDeque__E]: ...
    @typing.overload
    def offer(self, e: _BlockingDeque__E) -> bool: ...
    @typing.overload
    def offer(self, e: _BlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _BlockingDeque__E) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _BlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def offerLast(self, e: _BlockingDeque__E) -> bool: ...
    @typing.overload
    def offerLast(self, e: _BlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _BlockingDeque__E: ...
    @typing.overload
    def poll(self) -> _BlockingDeque__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _BlockingDeque__E: ...
    @typing.overload
    def pollFirst(self) -> _BlockingDeque__E: ...
    @typing.overload
    def pollFirst(self, long: int, timeUnit: TimeUnit) -> _BlockingDeque__E: ...
    @typing.overload
    def pollLast(self) -> _BlockingDeque__E: ...
    @typing.overload
    def pollLast(self, long: int, timeUnit: TimeUnit) -> _BlockingDeque__E: ...
    def push(self, e: _BlockingDeque__E) -> None: ...
    def put(self, e: _BlockingDeque__E) -> None: ...
    def putFirst(self, e: _BlockingDeque__E) -> None: ...
    def putLast(self, e: _BlockingDeque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _BlockingDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def take(self) -> _BlockingDeque__E: ...
    def takeFirst(self) -> _BlockingDeque__E: ...
    def takeLast(self) -> _BlockingDeque__E: ...

_CompletableFuture__T = typing.TypeVar('_CompletableFuture__T')  # <T>
class CompletableFuture(Future[_CompletableFuture__T], CompletionStage[_CompletableFuture__T], typing.Generic[_CompletableFuture__T]):
    """
    Java class 'java.util.concurrent.CompletableFuture'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.Future,
            java.util.concurrent.CompletionStage
    
      Constructors:
        * CompletableFuture()
    
    """
    def __init__(self): ...
    @typing.overload
    def acceptEither(self, completionStage: CompletionStage[_CompletableFuture__T], consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]]) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def acceptEither(self, completionStage: CompletionStage, consumer: java.util.function.Consumer) -> CompletionStage: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: CompletionStage[_CompletableFuture__T], consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]]) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: CompletionStage[_CompletableFuture__T], consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]], executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: CompletionStage, consumer: java.util.function.Consumer) -> CompletionStage: ...
    @typing.overload
    def acceptEitherAsync(self, completionStage: CompletionStage, consumer: java.util.function.Consumer, executor: Executor) -> CompletionStage: ...
    @classmethod
    def allOf(cls, completableFutureArray: typing.List['CompletableFuture'[typing.Any]]) -> 'CompletableFuture'[None]: ...
    @classmethod
    def anyOf(cls, completableFutureArray: typing.List['CompletableFuture'[typing.Any]]) -> 'CompletableFuture'[typing.Any]: ...
    _applyToEither_0__U = typing.TypeVar('_applyToEither_0__U')  # <U>
    @typing.overload
    def applyToEither(self, completionStage: CompletionStage[_CompletableFuture__T], function: typing.Union[java.util.function.Function[_CompletableFuture__T, _applyToEither_0__U], typing.Callable[[_CompletableFuture__T], _applyToEither_0__U]]) -> 'CompletableFuture'[_applyToEither_0__U]: ...
    @typing.overload
    def applyToEither(self, completionStage: CompletionStage, function: java.util.function.Function) -> CompletionStage: ...
    _applyToEitherAsync_0__U = typing.TypeVar('_applyToEitherAsync_0__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, completionStage: CompletionStage[_CompletableFuture__T], function: typing.Union[java.util.function.Function[_CompletableFuture__T, _applyToEitherAsync_0__U], typing.Callable[[_CompletableFuture__T], _applyToEitherAsync_0__U]]) -> 'CompletableFuture'[_applyToEitherAsync_0__U]: ...
    _applyToEitherAsync_1__U = typing.TypeVar('_applyToEitherAsync_1__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, completionStage: CompletionStage[_CompletableFuture__T], function: typing.Union[java.util.function.Function[_CompletableFuture__T, _applyToEitherAsync_1__U], typing.Callable[[_CompletableFuture__T], _applyToEitherAsync_1__U]], executor: Executor) -> 'CompletableFuture'[_applyToEitherAsync_1__U]: ...
    @typing.overload
    def applyToEitherAsync(self, completionStage: CompletionStage, function: java.util.function.Function) -> CompletionStage: ...
    @typing.overload
    def applyToEitherAsync(self, completionStage: CompletionStage, function: java.util.function.Function, executor: Executor) -> CompletionStage: ...
    def cancel(self, boolean: bool) -> bool: ...
    def complete(self, t: _CompletableFuture__T) -> bool: ...
    @typing.overload
    def completeAsync(self, supplier: typing.Union[java.util.function.Supplier[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]]) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def completeAsync(self, supplier: typing.Union[java.util.function.Supplier[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]], executor: Executor) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    def completeExceptionally(self, throwable: java.lang.Throwable) -> bool: ...
    def completeOnTimeout(self, t: _CompletableFuture__T, long: int, timeUnit: TimeUnit) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    _completedFuture__U = typing.TypeVar('_completedFuture__U')  # <U>
    @classmethod
    def completedFuture(cls, u: _completedFuture__U) -> 'CompletableFuture'[_completedFuture__U]: ...
    _completedStage__U = typing.TypeVar('_completedStage__U')  # <U>
    @classmethod
    def completedStage(cls, u: _completedStage__U) -> CompletionStage[_completedStage__U]: ...
    def copy(self) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    def defaultExecutor(self) -> Executor: ...
    @classmethod
    @typing.overload
    def delayedExecutor(cls, long: int, timeUnit: TimeUnit) -> Executor: ...
    @classmethod
    @typing.overload
    def delayedExecutor(cls, long: int, timeUnit: TimeUnit, executor: Executor) -> Executor: ...
    @typing.overload
    def exceptionally(self, function: typing.Union[java.util.function.Function[java.lang.Throwable, _CompletableFuture__T], typing.Callable[[java.lang.Throwable], _CompletableFuture__T]]) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def exceptionally(self, function: java.util.function.Function) -> CompletionStage: ...
    _failedFuture__U = typing.TypeVar('_failedFuture__U')  # <U>
    @classmethod
    def failedFuture(cls, throwable: java.lang.Throwable) -> 'CompletableFuture'[_failedFuture__U]: ...
    _failedStage__U = typing.TypeVar('_failedStage__U')  # <U>
    @classmethod
    def failedStage(cls, throwable: java.lang.Throwable) -> CompletionStage[_failedStage__U]: ...
    @typing.overload
    def get(self) -> _CompletableFuture__T: ...
    @typing.overload
    def get(self, long: int, timeUnit: TimeUnit) -> _CompletableFuture__T: ...
    def getNow(self, t: _CompletableFuture__T) -> _CompletableFuture__T: ...
    def getNumberOfDependents(self) -> int: ...
    _handle_0__U = typing.TypeVar('_handle_0__U')  # <U>
    @typing.overload
    def handle(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handle_0__U], typing.Callable[[_CompletableFuture__T, java.lang.Throwable], _handle_0__U]]) -> 'CompletableFuture'[_handle_0__U]: ...
    @typing.overload
    def handle(self, biFunction: java.util.function.BiFunction) -> CompletionStage: ...
    _handleAsync_0__U = typing.TypeVar('_handleAsync_0__U')  # <U>
    @typing.overload
    def handleAsync(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handleAsync_0__U], typing.Callable[[_CompletableFuture__T, java.lang.Throwable], _handleAsync_0__U]]) -> 'CompletableFuture'[_handleAsync_0__U]: ...
    _handleAsync_1__U = typing.TypeVar('_handleAsync_1__U')  # <U>
    @typing.overload
    def handleAsync(self, biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handleAsync_1__U], typing.Callable[[_CompletableFuture__T, java.lang.Throwable], _handleAsync_1__U]], executor: Executor) -> 'CompletableFuture'[_handleAsync_1__U]: ...
    @typing.overload
    def handleAsync(self, biFunction: java.util.function.BiFunction) -> CompletionStage: ...
    @typing.overload
    def handleAsync(self, biFunction: java.util.function.BiFunction, executor: Executor) -> CompletionStage: ...
    def isCancelled(self) -> bool: ...
    def isCompletedExceptionally(self) -> bool: ...
    def isDone(self) -> bool: ...
    def join(self) -> _CompletableFuture__T: ...
    def minimalCompletionStage(self) -> CompletionStage[_CompletableFuture__T]: ...
    _newIncompleteFuture__U = typing.TypeVar('_newIncompleteFuture__U')  # <U>
    def newIncompleteFuture(self) -> 'CompletableFuture'[_newIncompleteFuture__U]: ...
    def obtrudeException(self, throwable: java.lang.Throwable) -> None: ...
    def obtrudeValue(self, t: _CompletableFuture__T) -> None: ...
    def orTimeout(self, long: int, timeUnit: TimeUnit) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def runAfterBoth(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterBoth(self, completionStage: CompletionStage, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable, executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: CompletionStage, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def runAfterBothAsync(self, completionStage: CompletionStage, runnable: java.lang.Runnable, executor: Executor) -> CompletionStage: ...
    @typing.overload
    def runAfterEither(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterEither(self, completionStage: CompletionStage, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: CompletionStage[typing.Any], runnable: java.lang.Runnable, executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: CompletionStage, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def runAfterEitherAsync(self, completionStage: CompletionStage, runnable: java.lang.Runnable, executor: Executor) -> CompletionStage: ...
    @classmethod
    @typing.overload
    def runAsync(cls, runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @classmethod
    @typing.overload
    def runAsync(cls, runnable: java.lang.Runnable, executor: Executor) -> 'CompletableFuture'[None]: ...
    _supplyAsync_0__U = typing.TypeVar('_supplyAsync_0__U')  # <U>
    @classmethod
    @typing.overload
    def supplyAsync(cls, supplier: typing.Union[java.util.function.Supplier[_supplyAsync_0__U], typing.Callable[[], _supplyAsync_0__U]]) -> 'CompletableFuture'[_supplyAsync_0__U]: ...
    _supplyAsync_1__U = typing.TypeVar('_supplyAsync_1__U')  # <U>
    @classmethod
    @typing.overload
    def supplyAsync(cls, supplier: typing.Union[java.util.function.Supplier[_supplyAsync_1__U], typing.Callable[[], _supplyAsync_1__U]], executor: Executor) -> 'CompletableFuture'[_supplyAsync_1__U]: ...
    @typing.overload
    def thenAccept(self, consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]]) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenAccept(self, consumer: java.util.function.Consumer) -> CompletionStage: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]]) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: typing.Union[java.util.function.Consumer[_CompletableFuture__T], typing.Callable[[], _CompletableFuture__T]], executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: java.util.function.Consumer) -> CompletionStage: ...
    @typing.overload
    def thenAcceptAsync(self, consumer: java.util.function.Consumer, executor: Executor) -> CompletionStage: ...
    _thenAcceptBoth_0__U = typing.TypeVar('_thenAcceptBoth_0__U')  # <U>
    @typing.overload
    def thenAcceptBoth(self, completionStage: CompletionStage[_thenAcceptBoth_0__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBoth_0__U], typing.Callable[[_CompletableFuture__T], _thenAcceptBoth_0__U]]) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenAcceptBoth(self, completionStage: CompletionStage, biConsumer: java.util.function.BiConsumer) -> CompletionStage: ...
    _thenAcceptBothAsync_0__U = typing.TypeVar('_thenAcceptBothAsync_0__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: CompletionStage[_thenAcceptBothAsync_0__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBothAsync_0__U], typing.Callable[[_CompletableFuture__T], _thenAcceptBothAsync_0__U]]) -> 'CompletableFuture'[None]: ...
    _thenAcceptBothAsync_1__U = typing.TypeVar('_thenAcceptBothAsync_1__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: CompletionStage[_thenAcceptBothAsync_1__U], biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBothAsync_1__U], typing.Callable[[_CompletableFuture__T], _thenAcceptBothAsync_1__U]], executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: CompletionStage, biConsumer: java.util.function.BiConsumer) -> CompletionStage: ...
    @typing.overload
    def thenAcceptBothAsync(self, completionStage: CompletionStage, biConsumer: java.util.function.BiConsumer, executor: Executor) -> CompletionStage: ...
    _thenApply_0__U = typing.TypeVar('_thenApply_0__U')  # <U>
    @typing.overload
    def thenApply(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, _thenApply_0__U], typing.Callable[[_CompletableFuture__T], _thenApply_0__U]]) -> 'CompletableFuture'[_thenApply_0__U]: ...
    @typing.overload
    def thenApply(self, function: java.util.function.Function) -> CompletionStage: ...
    _thenApplyAsync_0__U = typing.TypeVar('_thenApplyAsync_0__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, _thenApplyAsync_0__U], typing.Callable[[_CompletableFuture__T], _thenApplyAsync_0__U]]) -> 'CompletableFuture'[_thenApplyAsync_0__U]: ...
    _thenApplyAsync_1__U = typing.TypeVar('_thenApplyAsync_1__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, _thenApplyAsync_1__U], typing.Callable[[_CompletableFuture__T], _thenApplyAsync_1__U]], executor: Executor) -> 'CompletableFuture'[_thenApplyAsync_1__U]: ...
    @typing.overload
    def thenApplyAsync(self, function: java.util.function.Function) -> CompletionStage: ...
    @typing.overload
    def thenApplyAsync(self, function: java.util.function.Function, executor: Executor) -> CompletionStage: ...
    _thenCombine_0__U = typing.TypeVar('_thenCombine_0__U')  # <U>
    _thenCombine_0__V = typing.TypeVar('_thenCombine_0__V')  # <V>
    @typing.overload
    def thenCombine(self, completionStage: CompletionStage[_thenCombine_0__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, _thenCombine_0__U, _thenCombine_0__V], typing.Callable[[_CompletableFuture__T, _thenCombine_0__U], _thenCombine_0__V]]) -> 'CompletableFuture'[_thenCombine_0__V]: ...
    @typing.overload
    def thenCombine(self, completionStage: CompletionStage, biFunction: java.util.function.BiFunction) -> CompletionStage: ...
    _thenCombineAsync_0__U = typing.TypeVar('_thenCombineAsync_0__U')  # <U>
    _thenCombineAsync_0__V = typing.TypeVar('_thenCombineAsync_0__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, completionStage: CompletionStage[_thenCombineAsync_0__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, _thenCombineAsync_0__U, _thenCombineAsync_0__V], typing.Callable[[_CompletableFuture__T, _thenCombineAsync_0__U], _thenCombineAsync_0__V]]) -> 'CompletableFuture'[_thenCombineAsync_0__V]: ...
    _thenCombineAsync_1__U = typing.TypeVar('_thenCombineAsync_1__U')  # <U>
    _thenCombineAsync_1__V = typing.TypeVar('_thenCombineAsync_1__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, completionStage: CompletionStage[_thenCombineAsync_1__U], biFunction: typing.Union[java.util.function.BiFunction[_CompletableFuture__T, _thenCombineAsync_1__U, _thenCombineAsync_1__V], typing.Callable[[_CompletableFuture__T, _thenCombineAsync_1__U], _thenCombineAsync_1__V]], executor: Executor) -> 'CompletableFuture'[_thenCombineAsync_1__V]: ...
    @typing.overload
    def thenCombineAsync(self, completionStage: CompletionStage, biFunction: java.util.function.BiFunction) -> CompletionStage: ...
    @typing.overload
    def thenCombineAsync(self, completionStage: CompletionStage, biFunction: java.util.function.BiFunction, executor: Executor) -> CompletionStage: ...
    _thenCompose_0__U = typing.TypeVar('_thenCompose_0__U')  # <U>
    @typing.overload
    def thenCompose(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenCompose_0__U]], typing.Callable[[_CompletableFuture__T], CompletionStage[_thenCompose_0__U]]]) -> 'CompletableFuture'[_thenCompose_0__U]: ...
    @typing.overload
    def thenCompose(self, function: java.util.function.Function) -> CompletionStage: ...
    _thenComposeAsync_0__U = typing.TypeVar('_thenComposeAsync_0__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenComposeAsync_0__U]], typing.Callable[[_CompletableFuture__T], CompletionStage[_thenComposeAsync_0__U]]]) -> 'CompletableFuture'[_thenComposeAsync_0__U]: ...
    _thenComposeAsync_1__U = typing.TypeVar('_thenComposeAsync_1__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, function: typing.Union[java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenComposeAsync_1__U]], typing.Callable[[_CompletableFuture__T], CompletionStage[_thenComposeAsync_1__U]]], executor: Executor) -> 'CompletableFuture'[_thenComposeAsync_1__U]: ...
    @typing.overload
    def thenComposeAsync(self, function: java.util.function.Function) -> CompletionStage: ...
    @typing.overload
    def thenComposeAsync(self, function: java.util.function.Function, executor: Executor) -> CompletionStage: ...
    @typing.overload
    def thenRun(self, runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenRun(self, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable, executor: Executor) -> 'CompletableFuture'[None]: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable) -> CompletionStage: ...
    @typing.overload
    def thenRunAsync(self, runnable: java.lang.Runnable, executor: Executor) -> CompletionStage: ...
    def toCompletableFuture(self) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def whenComplete(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], typing.Callable[[_CompletableFuture__T], java.lang.Throwable]]) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def whenComplete(self, biConsumer: java.util.function.BiConsumer) -> CompletionStage: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], typing.Callable[[_CompletableFuture__T], java.lang.Throwable]]) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: typing.Union[java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], typing.Callable[[_CompletableFuture__T], java.lang.Throwable]], executor: Executor) -> 'CompletableFuture'[_CompletableFuture__T]: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: java.util.function.BiConsumer) -> CompletionStage: ...
    @typing.overload
    def whenCompleteAsync(self, biConsumer: java.util.function.BiConsumer, executor: Executor) -> CompletionStage: ...
    class AsynchronousCompletionTask(java.lang.Object):
        """
        Java class 'java.util.concurrent.CompletableFuture$AsynchronousCompletionTask'
        
        """

_ConcurrentNavigableMap__K = typing.TypeVar('_ConcurrentNavigableMap__K')  # <K>
_ConcurrentNavigableMap__V = typing.TypeVar('_ConcurrentNavigableMap__V')  # <V>
class ConcurrentNavigableMap(ConcurrentMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V], java.util.NavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V], typing.Generic[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]):
    """
    Java class 'java.util.concurrent.ConcurrentNavigableMap'
    
        Interfaces:
            java.util.concurrent.ConcurrentMap, java.util.NavigableMap
    
    """
    def descendingKeySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    @typing.overload
    def descendingMap(self) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def descendingMap(self) -> java.util.NavigableMap: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def headMap(self, k: _ConcurrentNavigableMap__K) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def headMap(self, k: _ConcurrentNavigableMap__K, boolean: bool) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def headMap(self, object: typing.Any, boolean: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def headMap(self, object: typing.Any) -> java.util.SortedMap: ...
    @typing.overload
    def keySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    @typing.overload
    def keySet(self) -> java.util.Set: ...
    def navigableKeySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    @typing.overload
    def subMap(self, k: _ConcurrentNavigableMap__K, boolean: bool, k2: _ConcurrentNavigableMap__K, boolean2: bool) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _ConcurrentNavigableMap__K, k2: _ConcurrentNavigableMap__K) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def subMap(self, object: typing.Any, boolean: bool, object2: typing.Any, boolean2: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def subMap(self, object: typing.Any, object2: typing.Any) -> java.util.SortedMap: ...
    @typing.overload
    def tailMap(self, k: _ConcurrentNavigableMap__K) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ConcurrentNavigableMap__K, boolean: bool) -> 'ConcurrentNavigableMap'[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, object: typing.Any, boolean: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def tailMap(self, object: typing.Any) -> java.util.SortedMap: ...

_DelayQueue__E = typing.TypeVar('_DelayQueue__E', bound=Delayed)  # <E>
class DelayQueue(java.util.AbstractQueue[_DelayQueue__E], BlockingQueue[_DelayQueue__E], typing.Generic[_DelayQueue__E]):
    """
    Java class 'java.util.concurrent.DelayQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingQueue
    
      Constructors:
        * DelayQueue()
        * DelayQueue(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_DelayQueue__E], typing.Sequence[_DelayQueue__E]]): ...
    @typing.overload
    def add(self, object: typing.Any) -> bool: ...
    @typing.overload
    def add(self, e: _DelayQueue__E) -> bool: ...
    def clear(self) -> None: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_DelayQueue__E], typing.Sequence[_DelayQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_DelayQueue__E], typing.Sequence[_DelayQueue__E]], int: int) -> int: ...
    def iterator(self) -> java.util.Iterator[_DelayQueue__E]: ...
    @typing.overload
    def offer(self, object: typing.Any) -> bool: ...
    @typing.overload
    def offer(self, object: typing.Any, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def offer(self, e: _DelayQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _DelayQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def peek(self) -> typing.Any: ...
    @typing.overload
    def peek(self) -> _DelayQueue__E: ...
    @typing.overload
    def poll(self) -> typing.Any: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> typing.Any: ...
    @typing.overload
    def poll(self) -> _DelayQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _DelayQueue__E: ...
    @typing.overload
    def put(self, object: typing.Any) -> None: ...
    @typing.overload
    def put(self, e: _DelayQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _DelayQueue__E: ...
    def size(self) -> int: ...
    @typing.overload
    def take(self) -> typing.Any: ...
    @typing.overload
    def take(self) -> _DelayQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_ExecutorCompletionService__V = typing.TypeVar('_ExecutorCompletionService__V')  # <V>
class ExecutorCompletionService(CompletionService[_ExecutorCompletionService__V], typing.Generic[_ExecutorCompletionService__V]):
    """
    Java class 'java.util.concurrent.ExecutorCompletionService'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.CompletionService
    
      Constructors:
        * ExecutorCompletionService(java.util.concurrent.Executor)
        * ExecutorCompletionService(java.util.concurrent.Executor, java.util.concurrent.BlockingQueue)
    
    """
    @typing.overload
    def __init__(self, executor: Executor): ...
    @typing.overload
    def __init__(self, executor: Executor, blockingQueue: BlockingQueue[Future[_ExecutorCompletionService__V]]): ...
    @typing.overload
    def poll(self) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, v: _ExecutorCompletionService__V) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_ExecutorCompletionService__V], typing.Callable[[], _ExecutorCompletionService__V]]) -> Future[_ExecutorCompletionService__V]: ...
    def take(self) -> Future[_ExecutorCompletionService__V]: ...

class ExecutorService(Executor):
    """
    Java class 'java.util.concurrent.ExecutorService'
    
        Interfaces:
            java.util.concurrent.Executor
    
    """
    def awaitTermination(self, long: int, timeUnit: TimeUnit) -> bool: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_0__T]], typing.Sequence[Callable[_invokeAll_0__T]]]) -> java.util.List[Future[_invokeAll_0__T]]: ...
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_1__T]], typing.Sequence[Callable[_invokeAll_1__T]]], long: int, timeUnit: TimeUnit) -> java.util.List[Future[_invokeAll_1__T]]: ...
    _invokeAny_0__T = typing.TypeVar('_invokeAny_0__T')  # <T>
    @typing.overload
    def invokeAny(self, collection: typing.Union[java.util.Collection[Callable[_invokeAny_0__T]], typing.Sequence[Callable[_invokeAny_0__T]]]) -> _invokeAny_0__T: ...
    _invokeAny_1__T = typing.TypeVar('_invokeAny_1__T')  # <T>
    @typing.overload
    def invokeAny(self, collection: typing.Union[java.util.Collection[Callable[_invokeAny_1__T]], typing.Sequence[Callable[_invokeAny_1__T]]], long: int, timeUnit: TimeUnit) -> _invokeAny_1__T: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable) -> Future[typing.Any]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, t: _submit_1__T) -> Future[_submit_1__T]: ...
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_submit_2__T], typing.Callable[[], _submit_2__T]]) -> Future[_submit_2__T]: ...

_ForkJoinTask__V = typing.TypeVar('_ForkJoinTask__V')  # <V>
class ForkJoinTask(Future[_ForkJoinTask__V], java.io.Serializable, typing.Generic[_ForkJoinTask__V]):
    """
    Java class 'java.util.concurrent.ForkJoinTask'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.Future, java.io.Serializable
    
      Constructors:
        * ForkJoinTask()
    
    """
    def __init__(self): ...
    @classmethod
    @typing.overload
    def adapt(cls, runnable: java.lang.Runnable) -> 'ForkJoinTask'[typing.Any]: ...
    _adapt_1__T = typing.TypeVar('_adapt_1__T')  # <T>
    @classmethod
    @typing.overload
    def adapt(cls, runnable: java.lang.Runnable, t: _adapt_1__T) -> 'ForkJoinTask'[_adapt_1__T]: ...
    _adapt_2__T = typing.TypeVar('_adapt_2__T')  # <T>
    @classmethod
    @typing.overload
    def adapt(cls, callable: typing.Union[Callable[_adapt_2__T], typing.Callable[[], _adapt_2__T]]) -> 'ForkJoinTask'[_adapt_2__T]: ...
    def cancel(self, boolean: bool) -> bool: ...
    def compareAndSetForkJoinTaskTag(self, short: int, short2: int) -> bool: ...
    def complete(self, v: _ForkJoinTask__V) -> None: ...
    def completeExceptionally(self, throwable: java.lang.Throwable) -> None: ...
    def fork(self) -> 'ForkJoinTask'[_ForkJoinTask__V]: ...
    @typing.overload
    def get(self) -> _ForkJoinTask__V: ...
    @typing.overload
    def get(self, long: int, timeUnit: TimeUnit) -> _ForkJoinTask__V: ...
    def getException(self) -> java.lang.Throwable: ...
    def getForkJoinTaskTag(self) -> int: ...
    @classmethod
    def getPool(cls) -> 'ForkJoinPool': ...
    @classmethod
    def getQueuedTaskCount(cls) -> int: ...
    def getRawResult(self) -> _ForkJoinTask__V: ...
    @classmethod
    def getSurplusQueuedTaskCount(cls) -> int: ...
    @classmethod
    def helpQuiesce(cls) -> None: ...
    @classmethod
    def inForkJoinPool(cls) -> bool: ...
    def invoke(self) -> _ForkJoinTask__V: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T', bound='ForkJoinTask')  # <T>
    @classmethod
    @typing.overload
    def invokeAll(cls, collection: typing.Union[java.util.Collection[_invokeAll_0__T], typing.Sequence[_invokeAll_0__T]]) -> java.util.Collection[_invokeAll_0__T]: ...
    @classmethod
    @typing.overload
    def invokeAll(cls, forkJoinTask: 'ForkJoinTask'[typing.Any], forkJoinTask2: 'ForkJoinTask'[typing.Any]) -> None: ...
    @classmethod
    @typing.overload
    def invokeAll(cls, forkJoinTaskArray: typing.List['ForkJoinTask'[typing.Any]]) -> None: ...
    def isCancelled(self) -> bool: ...
    def isCompletedAbnormally(self) -> bool: ...
    def isCompletedNormally(self) -> bool: ...
    def isDone(self) -> bool: ...
    def join(self) -> _ForkJoinTask__V: ...
    def quietlyComplete(self) -> None: ...
    def quietlyInvoke(self) -> None: ...
    def quietlyJoin(self) -> None: ...
    def reinitialize(self) -> None: ...
    def setForkJoinTaskTag(self, short: int) -> int: ...
    def tryUnfork(self) -> bool: ...

_LinkedBlockingQueue__E = typing.TypeVar('_LinkedBlockingQueue__E')  # <E>
class LinkedBlockingQueue(java.util.AbstractQueue[_LinkedBlockingQueue__E], BlockingQueue[_LinkedBlockingQueue__E], java.io.Serializable, typing.Generic[_LinkedBlockingQueue__E]):
    """
    Java class 'java.util.concurrent.LinkedBlockingQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingQueue, java.io.Serializable
    
      Constructors:
        * LinkedBlockingQueue(int)
        * LinkedBlockingQueue(java.util.Collection)
        * LinkedBlockingQueue()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_LinkedBlockingQueue__E], typing.Sequence[_LinkedBlockingQueue__E]]): ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedBlockingQueue__E], typing.Sequence[_LinkedBlockingQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedBlockingQueue__E], typing.Sequence[_LinkedBlockingQueue__E]], int: int) -> int: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_LinkedBlockingQueue__E], typing.Callable[[], _LinkedBlockingQueue__E]]) -> None: ...
    def iterator(self) -> java.util.Iterator[_LinkedBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _LinkedBlockingQueue__E: ...
    @typing.overload
    def poll(self) -> _LinkedBlockingQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _LinkedBlockingQueue__E: ...
    def put(self, e: _LinkedBlockingQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _LinkedBlockingQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_LinkedBlockingQueue__E], typing.Callable[[], _LinkedBlockingQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedBlockingQueue__E]: ...
    def take(self) -> _LinkedBlockingQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_PriorityBlockingQueue__E = typing.TypeVar('_PriorityBlockingQueue__E')  # <E>
class PriorityBlockingQueue(java.util.AbstractQueue[_PriorityBlockingQueue__E], BlockingQueue[_PriorityBlockingQueue__E], java.io.Serializable, typing.Generic[_PriorityBlockingQueue__E]):
    """
    Java class 'java.util.concurrent.PriorityBlockingQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingQueue, java.io.Serializable
    
      Constructors:
        * PriorityBlockingQueue(java.util.Collection)
        * PriorityBlockingQueue()
        * PriorityBlockingQueue(int)
        * PriorityBlockingQueue(int, java.util.Comparator)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, comparator: typing.Union[java.util.Comparator[_PriorityBlockingQueue__E], typing.Callable[[], _PriorityBlockingQueue__E]]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_PriorityBlockingQueue__E], typing.Sequence[_PriorityBlockingQueue__E]]): ...
    def add(self, e: _PriorityBlockingQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> java.util.Comparator[_PriorityBlockingQueue__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_PriorityBlockingQueue__E], typing.Sequence[_PriorityBlockingQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_PriorityBlockingQueue__E], typing.Sequence[_PriorityBlockingQueue__E]], int: int) -> int: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_PriorityBlockingQueue__E], typing.Callable[[], _PriorityBlockingQueue__E]]) -> None: ...
    def iterator(self) -> java.util.Iterator[_PriorityBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _PriorityBlockingQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _PriorityBlockingQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _PriorityBlockingQueue__E: ...
    @typing.overload
    def poll(self) -> _PriorityBlockingQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _PriorityBlockingQueue__E: ...
    def put(self, e: _PriorityBlockingQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _PriorityBlockingQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_PriorityBlockingQueue__E], typing.Callable[[], _PriorityBlockingQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_PriorityBlockingQueue__E]: ...
    def take(self) -> _PriorityBlockingQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_RunnableFuture__V = typing.TypeVar('_RunnableFuture__V')  # <V>
class RunnableFuture(java.lang.Runnable, Future[_RunnableFuture__V], typing.Generic[_RunnableFuture__V]):
    """
    Java class 'java.util.concurrent.RunnableFuture'
    
        Interfaces:
            java.lang.Runnable, java.util.concurrent.Future
    
    """
    def run(self) -> None: ...

_ScheduledFuture__V = typing.TypeVar('_ScheduledFuture__V')  # <V>
class ScheduledFuture(Delayed, Future[_ScheduledFuture__V], typing.Generic[_ScheduledFuture__V]):
    """
    Java class 'java.util.concurrent.ScheduledFuture'
    
        Interfaces:
            java.util.concurrent.Delayed, java.util.concurrent.Future
    
    """

_SynchronousQueue__E = typing.TypeVar('_SynchronousQueue__E')  # <E>
class SynchronousQueue(java.util.AbstractQueue[_SynchronousQueue__E], BlockingQueue[_SynchronousQueue__E], java.io.Serializable, typing.Generic[_SynchronousQueue__E]):
    """
    Java class 'java.util.concurrent.SynchronousQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingQueue, java.io.Serializable
    
      Constructors:
        * SynchronousQueue()
        * SynchronousQueue(boolean)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_SynchronousQueue__E], typing.Sequence[_SynchronousQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_SynchronousQueue__E], typing.Sequence[_SynchronousQueue__E]], int: int) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_SynchronousQueue__E]: ...
    @typing.overload
    def offer(self, e: _SynchronousQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _SynchronousQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _SynchronousQueue__E: ...
    @typing.overload
    def poll(self) -> _SynchronousQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _SynchronousQueue__E: ...
    def put(self, e: _SynchronousQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _SynchronousQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_SynchronousQueue__E]: ...
    def take(self) -> _SynchronousQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_TransferQueue__E = typing.TypeVar('_TransferQueue__E')  # <E>
class TransferQueue(BlockingQueue[_TransferQueue__E], typing.Generic[_TransferQueue__E]):
    """
    Java class 'java.util.concurrent.TransferQueue'
    
        Interfaces:
            java.util.concurrent.BlockingQueue
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getWaitingConsumerCount(self) -> int: ...
    def hasWaitingConsumer(self) -> bool: ...
    def hashCode(self) -> int: ...
    def transfer(self, e: _TransferQueue__E) -> None: ...
    @typing.overload
    def tryTransfer(self, e: _TransferQueue__E) -> bool: ...
    @typing.overload
    def tryTransfer(self, e: _TransferQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...

class AbstractExecutorService(ExecutorService):
    """
    Java class 'java.util.concurrent.AbstractExecutorService'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.ExecutorService
    
      Constructors:
        * AbstractExecutorService()
    
    """
    def __init__(self): ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_0__T]], typing.Sequence[Callable[_invokeAll_0__T]]]) -> java.util.List[Future[_invokeAll_0__T]]: ...
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_1__T]], typing.Sequence[Callable[_invokeAll_1__T]]], long: int, timeUnit: TimeUnit) -> java.util.List[Future[_invokeAll_1__T]]: ...
    _invokeAny_0__T = typing.TypeVar('_invokeAny_0__T')  # <T>
    @typing.overload
    def invokeAny(self, collection: typing.Union[java.util.Collection[Callable[_invokeAny_0__T]], typing.Sequence[Callable[_invokeAny_0__T]]]) -> _invokeAny_0__T: ...
    _invokeAny_1__T = typing.TypeVar('_invokeAny_1__T')  # <T>
    @typing.overload
    def invokeAny(self, collection: typing.Union[java.util.Collection[Callable[_invokeAny_1__T]], typing.Sequence[Callable[_invokeAny_1__T]]], long: int, timeUnit: TimeUnit) -> _invokeAny_1__T: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable) -> Future[typing.Any]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, t: _submit_1__T) -> Future[_submit_1__T]: ...
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_submit_2__T], typing.Callable[[], _submit_2__T]]) -> Future[_submit_2__T]: ...

_ConcurrentSkipListMap__K = typing.TypeVar('_ConcurrentSkipListMap__K')  # <K>
_ConcurrentSkipListMap__V = typing.TypeVar('_ConcurrentSkipListMap__V')  # <V>
class ConcurrentSkipListMap(java.util.AbstractMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]):
    """
    Java class 'java.util.concurrent.ConcurrentSkipListMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.concurrent.ConcurrentNavigableMap,
            java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * ConcurrentSkipListMap()
        * ConcurrentSkipListMap(java.util.Map)
        * ConcurrentSkipListMap(java.util.SortedMap)
        * ConcurrentSkipListMap(java.util.Comparator)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[java.util.Comparator[_ConcurrentSkipListMap__K], typing.Callable[[], _ConcurrentSkipListMap__K]]): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], typing.Mapping[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]]): ...
    @typing.overload
    def __init__(self, sortedMap: java.util.SortedMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]): ...
    def ceilingEntry(self, k: _ConcurrentSkipListMap__K) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def ceilingKey(self, k: _ConcurrentSkipListMap__K) -> _ConcurrentSkipListMap__K: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> 'ConcurrentSkipListMap'[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def comparator(self) -> java.util.Comparator[_ConcurrentSkipListMap__K]: ...
    def compute(self, k: _ConcurrentSkipListMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], _ConcurrentSkipListMap__V]]) -> _ConcurrentSkipListMap__V: ...
    def computeIfAbsent(self, k: _ConcurrentSkipListMap__K, function: typing.Union[java.util.function.Function[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__K], _ConcurrentSkipListMap__V]]) -> _ConcurrentSkipListMap__V: ...
    def computeIfPresent(self, k: _ConcurrentSkipListMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], _ConcurrentSkipListMap__V]]) -> _ConcurrentSkipListMap__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def descendingKeySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    @typing.overload
    def descendingMap(self) -> java.util.NavigableMap: ...
    @typing.overload
    def descendingMap(self) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def firstKey(self) -> _ConcurrentSkipListMap__K: ...
    def floorEntry(self, k: _ConcurrentSkipListMap__K) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def floorKey(self, k: _ConcurrentSkipListMap__K) -> _ConcurrentSkipListMap__K: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__K], _ConcurrentSkipListMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _ConcurrentSkipListMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _ConcurrentSkipListMap__V) -> _ConcurrentSkipListMap__V: ...
    @typing.overload
    def headMap(self, object: typing.Any, boolean: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def headMap(self, object: typing.Any) -> java.util.SortedMap: ...
    @typing.overload
    def headMap(self, k: _ConcurrentSkipListMap__K) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def headMap(self, k: _ConcurrentSkipListMap__K, boolean: bool) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def higherEntry(self, k: _ConcurrentSkipListMap__K) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def higherKey(self, k: _ConcurrentSkipListMap__K) -> _ConcurrentSkipListMap__K: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def keySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    @typing.overload
    def keySet(self) -> java.util.Set: ...
    def lastEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def lastKey(self) -> _ConcurrentSkipListMap__K: ...
    def lowerEntry(self, k: _ConcurrentSkipListMap__K) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def lowerKey(self, k: _ConcurrentSkipListMap__K) -> _ConcurrentSkipListMap__K: ...
    def merge(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], _ConcurrentSkipListMap__V]]) -> _ConcurrentSkipListMap__V: ...
    def navigableKeySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    def pollFirstEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def pollLastEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def put(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V) -> _ConcurrentSkipListMap__V: ...
    def putIfAbsent(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V) -> _ConcurrentSkipListMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ConcurrentSkipListMap__V: ...
    @typing.overload
    def replace(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V, v2: _ConcurrentSkipListMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V) -> _ConcurrentSkipListMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], typing.Callable[[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], _ConcurrentSkipListMap__V]]) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, object: typing.Any, boolean: bool, object2: typing.Any, boolean2: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def subMap(self, object: typing.Any, object2: typing.Any) -> java.util.SortedMap: ...
    @typing.overload
    def subMap(self, k: _ConcurrentSkipListMap__K, boolean: bool, k2: _ConcurrentSkipListMap__K, boolean2: bool) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def subMap(self, k: _ConcurrentSkipListMap__K, k2: _ConcurrentSkipListMap__K) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def tailMap(self, object: typing.Any, boolean: bool) -> java.util.NavigableMap: ...
    @typing.overload
    def tailMap(self, object: typing.Any) -> java.util.SortedMap: ...
    @typing.overload
    def tailMap(self, k: _ConcurrentSkipListMap__K) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ConcurrentSkipListMap__K, boolean: bool) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def values(self) -> java.util.Collection[_ConcurrentSkipListMap__V]: ...

_CountedCompleter__T = typing.TypeVar('_CountedCompleter__T')  # <T>
class CountedCompleter(ForkJoinTask[_CountedCompleter__T], typing.Generic[_CountedCompleter__T]):
    """
    Java class 'java.util.concurrent.CountedCompleter'
    
        Extends:
            java.util.concurrent.ForkJoinTask
    
    """
    def addToPendingCount(self, int: int) -> None: ...
    def compareAndSetPendingCount(self, int: int, int2: int) -> bool: ...
    def complete(self, t: _CountedCompleter__T) -> None: ...
    def compute(self) -> None: ...
    def decrementPendingCountUnlessZero(self) -> int: ...
    def firstComplete(self) -> 'CountedCompleter'[typing.Any]: ...
    def getCompleter(self) -> 'CountedCompleter'[typing.Any]: ...
    def getPendingCount(self) -> int: ...
    def getRawResult(self) -> _CountedCompleter__T: ...
    def getRoot(self) -> 'CountedCompleter'[typing.Any]: ...
    def helpComplete(self, int: int) -> None: ...
    def nextComplete(self) -> 'CountedCompleter'[typing.Any]: ...
    def onCompletion(self, countedCompleter: 'CountedCompleter'[typing.Any]) -> None: ...
    def onExceptionalCompletion(self, throwable: java.lang.Throwable, countedCompleter: 'CountedCompleter'[typing.Any]) -> bool: ...
    def propagateCompletion(self) -> None: ...
    def quietlyCompleteRoot(self) -> None: ...
    def setPendingCount(self, int: int) -> None: ...
    def tryComplete(self) -> None: ...

_FutureTask__V = typing.TypeVar('_FutureTask__V')  # <V>
class FutureTask(RunnableFuture[_FutureTask__V], typing.Generic[_FutureTask__V]):
    """
    Java class 'java.util.concurrent.FutureTask'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.RunnableFuture
    
      Constructors:
        * FutureTask(java.lang.Runnable, java.lang.Object)
        * FutureTask(java.util.concurrent.Callable)
    
    """
    @typing.overload
    def __init__(self, runnable: java.lang.Runnable, v: _FutureTask__V): ...
    @typing.overload
    def __init__(self, callable: typing.Union[Callable[_FutureTask__V], typing.Callable[[], _FutureTask__V]]): ...
    def cancel(self, boolean: bool) -> bool: ...
    @typing.overload
    def get(self) -> _FutureTask__V: ...
    @typing.overload
    def get(self, long: int, timeUnit: TimeUnit) -> _FutureTask__V: ...
    def isCancelled(self) -> bool: ...
    def isDone(self) -> bool: ...
    def run(self) -> None: ...
    def toString(self) -> java.lang.String: ...

_LinkedBlockingDeque__E = typing.TypeVar('_LinkedBlockingDeque__E')  # <E>
class LinkedBlockingDeque(java.util.AbstractQueue[_LinkedBlockingDeque__E], BlockingDeque[_LinkedBlockingDeque__E], java.io.Serializable, typing.Generic[_LinkedBlockingDeque__E]):
    """
    Java class 'java.util.concurrent.LinkedBlockingDeque'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.BlockingDeque, java.io.Serializable
    
      Constructors:
        * LinkedBlockingDeque()
        * LinkedBlockingDeque(int)
        * LinkedBlockingDeque(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_LinkedBlockingDeque__E], typing.Sequence[_LinkedBlockingDeque__E]]): ...
    def add(self, e: _LinkedBlockingDeque__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_LinkedBlockingDeque__E], typing.Sequence[_LinkedBlockingDeque__E]]) -> bool: ...
    def addFirst(self, e: _LinkedBlockingDeque__E) -> None: ...
    def addLast(self, e: _LinkedBlockingDeque__E) -> None: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_LinkedBlockingDeque__E]: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedBlockingDeque__E], typing.Sequence[_LinkedBlockingDeque__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedBlockingDeque__E], typing.Sequence[_LinkedBlockingDeque__E]], int: int) -> int: ...
    def element(self) -> _LinkedBlockingDeque__E: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_LinkedBlockingDeque__E], typing.Callable[[], _LinkedBlockingDeque__E]]) -> None: ...
    def getFirst(self) -> _LinkedBlockingDeque__E: ...
    def getLast(self) -> _LinkedBlockingDeque__E: ...
    def iterator(self) -> java.util.Iterator[_LinkedBlockingDeque__E]: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingDeque__E) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _LinkedBlockingDeque__E) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _LinkedBlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    @typing.overload
    def offerLast(self, e: _LinkedBlockingDeque__E) -> bool: ...
    @typing.overload
    def offerLast(self, e: _LinkedBlockingDeque__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _LinkedBlockingDeque__E: ...
    def peekFirst(self) -> _LinkedBlockingDeque__E: ...
    def peekLast(self) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def poll(self) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def pollFirst(self) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def pollFirst(self, long: int, timeUnit: TimeUnit) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def pollLast(self) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def pollLast(self, long: int, timeUnit: TimeUnit) -> _LinkedBlockingDeque__E: ...
    def pop(self) -> _LinkedBlockingDeque__E: ...
    def push(self, e: _LinkedBlockingDeque__E) -> None: ...
    def put(self, e: _LinkedBlockingDeque__E) -> None: ...
    def putFirst(self, e: _LinkedBlockingDeque__E) -> None: ...
    def putLast(self, e: _LinkedBlockingDeque__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _LinkedBlockingDeque__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeFirst(self) -> _LinkedBlockingDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_LinkedBlockingDeque__E], typing.Callable[[], _LinkedBlockingDeque__E]]) -> bool: ...
    def removeLast(self) -> _LinkedBlockingDeque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedBlockingDeque__E]: ...
    def take(self) -> _LinkedBlockingDeque__E: ...
    def takeFirst(self) -> _LinkedBlockingDeque__E: ...
    def takeLast(self) -> _LinkedBlockingDeque__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_LinkedTransferQueue__E = typing.TypeVar('_LinkedTransferQueue__E')  # <E>
class LinkedTransferQueue(java.util.AbstractQueue[_LinkedTransferQueue__E], TransferQueue[_LinkedTransferQueue__E], java.io.Serializable, typing.Generic[_LinkedTransferQueue__E]):
    """
    Java class 'java.util.concurrent.LinkedTransferQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.util.concurrent.TransferQueue, java.io.Serializable
    
      Constructors:
        * LinkedTransferQueue()
        * LinkedTransferQueue(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[_LinkedTransferQueue__E], typing.Sequence[_LinkedTransferQueue__E]]): ...
    def add(self, e: _LinkedTransferQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedTransferQueue__E], typing.Sequence[_LinkedTransferQueue__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_LinkedTransferQueue__E], typing.Sequence[_LinkedTransferQueue__E]], int: int) -> int: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_LinkedTransferQueue__E], typing.Callable[[], _LinkedTransferQueue__E]]) -> None: ...
    def getWaitingConsumerCount(self) -> int: ...
    def hasWaitingConsumer(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_LinkedTransferQueue__E]: ...
    @typing.overload
    def offer(self, e: _LinkedTransferQueue__E) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedTransferQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...
    def peek(self) -> _LinkedTransferQueue__E: ...
    @typing.overload
    def poll(self) -> _LinkedTransferQueue__E: ...
    @typing.overload
    def poll(self, long: int, timeUnit: TimeUnit) -> _LinkedTransferQueue__E: ...
    def put(self, e: _LinkedTransferQueue__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _LinkedTransferQueue__E: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_LinkedTransferQueue__E], typing.Callable[[], _LinkedTransferQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedTransferQueue__E]: ...
    def take(self) -> _LinkedTransferQueue__E: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...
    def transfer(self, e: _LinkedTransferQueue__E) -> None: ...
    @typing.overload
    def tryTransfer(self, e: _LinkedTransferQueue__E) -> bool: ...
    @typing.overload
    def tryTransfer(self, e: _LinkedTransferQueue__E, long: int, timeUnit: TimeUnit) -> bool: ...

class RecursiveAction(ForkJoinTask[None]):
    """
    Java class 'java.util.concurrent.RecursiveAction'
    
        Extends:
            java.util.concurrent.ForkJoinTask
    
      Constructors:
        * RecursiveAction()
    
    """
    def __init__(self): ...
    @typing.overload
    def getRawResult(self) -> None: ...
    @typing.overload
    def getRawResult(self) -> typing.Any: ...

_RecursiveTask__V = typing.TypeVar('_RecursiveTask__V')  # <V>
class RecursiveTask(ForkJoinTask[_RecursiveTask__V], typing.Generic[_RecursiveTask__V]):
    """
    Java class 'java.util.concurrent.RecursiveTask'
    
        Extends:
            java.util.concurrent.ForkJoinTask
    
      Constructors:
        * RecursiveTask()
    
    """
    def __init__(self): ...
    def getRawResult(self) -> _RecursiveTask__V: ...

_RunnableScheduledFuture__V = typing.TypeVar('_RunnableScheduledFuture__V')  # <V>
class RunnableScheduledFuture(RunnableFuture[_RunnableScheduledFuture__V], ScheduledFuture[_RunnableScheduledFuture__V], typing.Generic[_RunnableScheduledFuture__V]):
    """
    Java class 'java.util.concurrent.RunnableScheduledFuture'
    
        Interfaces:
            java.util.concurrent.RunnableFuture,
            java.util.concurrent.ScheduledFuture
    
    """
    def isPeriodic(self) -> bool: ...

class ScheduledExecutorService(ExecutorService):
    """
    Java class 'java.util.concurrent.ScheduledExecutorService'
    
        Interfaces:
            java.util.concurrent.ExecutorService
    
    """
    @typing.overload
    def schedule(self, runnable: java.lang.Runnable, long: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...
    _schedule_1__V = typing.TypeVar('_schedule_1__V')  # <V>
    @typing.overload
    def schedule(self, callable: typing.Union[Callable[_schedule_1__V], typing.Callable[[], _schedule_1__V]], long: int, timeUnit: TimeUnit) -> ScheduledFuture[_schedule_1__V]: ...
    def scheduleAtFixedRate(self, runnable: java.lang.Runnable, long: int, long2: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...
    def scheduleWithFixedDelay(self, runnable: java.lang.Runnable, long: int, long2: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...

class ForkJoinPool(AbstractExecutorService):
    """
    Java class 'java.util.concurrent.ForkJoinPool'
    
        Extends:
            java.util.concurrent.AbstractExecutorService
    
      Constructors:
        * ForkJoinPool(int, java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory, java.lang.Thread.UncaughtExceptionHandler, boolean, int, int, int, java.util.function.Predicate, long, java.util.concurrent.TimeUnit)
        * ForkJoinPool()
        * ForkJoinPool(int, java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory, java.lang.Thread.UncaughtExceptionHandler, boolean)
        * ForkJoinPool(int)
    
      Attributes:
        defaultForkJoinWorkerThreadFactory (java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory): final static field
    
    """
    defaultForkJoinWorkerThreadFactory: typing.ClassVar['ForkJoinPool.ForkJoinWorkerThreadFactory'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, forkJoinWorkerThreadFactory: 'ForkJoinPool.ForkJoinWorkerThreadFactory', uncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler, boolean: bool): ...
    @typing.overload
    def __init__(self, int: int, forkJoinWorkerThreadFactory: 'ForkJoinPool.ForkJoinWorkerThreadFactory', uncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler, boolean: bool, int2: int, int3: int, int4: int, predicate: typing.Union[java.util.function.Predicate['ForkJoinPool'], typing.Callable[[], 'ForkJoinPool']], long: int, timeUnit: TimeUnit): ...
    def awaitQuiescence(self, long: int, timeUnit: TimeUnit) -> bool: ...
    def awaitTermination(self, long: int, timeUnit: TimeUnit) -> bool: ...
    @classmethod
    def commonPool(cls) -> 'ForkJoinPool': ...
    @typing.overload
    def execute(self, runnable: java.lang.Runnable) -> None: ...
    @typing.overload
    def execute(self, forkJoinTask: ForkJoinTask[typing.Any]) -> None: ...
    def getActiveThreadCount(self) -> int: ...
    def getAsyncMode(self) -> bool: ...
    @classmethod
    def getCommonPoolParallelism(cls) -> int: ...
    def getFactory(self) -> 'ForkJoinPool.ForkJoinWorkerThreadFactory': ...
    def getParallelism(self) -> int: ...
    def getPoolSize(self) -> int: ...
    def getQueuedSubmissionCount(self) -> int: ...
    def getQueuedTaskCount(self) -> int: ...
    def getRunningThreadCount(self) -> int: ...
    def getStealCount(self) -> int: ...
    def getUncaughtExceptionHandler(self) -> java.lang.Thread.UncaughtExceptionHandler: ...
    def hasQueuedSubmissions(self) -> bool: ...
    _invoke__T = typing.TypeVar('_invoke__T')  # <T>
    def invoke(self, forkJoinTask: ForkJoinTask[_invoke__T]) -> _invoke__T: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_0__T]], typing.Sequence[Callable[_invokeAll_0__T]]], long: int, timeUnit: TimeUnit) -> java.util.List[Future[_invokeAll_0__T]]: ...
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, collection: typing.Union[java.util.Collection[Callable[_invokeAll_1__T]], typing.Sequence[Callable[_invokeAll_1__T]]]) -> java.util.List[Future[_invokeAll_1__T]]: ...
    def isQuiescent(self) -> bool: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def isTerminating(self) -> bool: ...
    @classmethod
    def managedBlock(cls, managedBlocker: 'ForkJoinPool.ManagedBlocker') -> None: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable) -> ForkJoinTask[typing.Any]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, t: _submit_1__T) -> ForkJoinTask[_submit_1__T]: ...
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_submit_2__T], typing.Callable[[], _submit_2__T]]) -> ForkJoinTask[_submit_2__T]: ...
    _submit_3__T = typing.TypeVar('_submit_3__T')  # <T>
    @typing.overload
    def submit(self, forkJoinTask: ForkJoinTask[_submit_3__T]) -> ForkJoinTask[_submit_3__T]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable) -> Future: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, object: typing.Any) -> Future: ...
    @typing.overload
    def submit(self, callable: Callable) -> Future: ...
    def toString(self) -> java.lang.String: ...
    class ForkJoinWorkerThreadFactory(java.lang.Object):
        """
        Java class 'java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory'
        
        """
        def newThread(self, forkJoinPool: 'ForkJoinPool') -> ForkJoinWorkerThread: ...
    class ManagedBlocker(java.lang.Object):
        """
        Java class 'java.util.concurrent.ForkJoinPool$ManagedBlocker'
        
        """
        def block(self) -> bool: ...
        def isReleasable(self) -> bool: ...

class ThreadPoolExecutor(AbstractExecutorService):
    """
    Java class 'java.util.concurrent.ThreadPoolExecutor'
    
        Extends:
            java.util.concurrent.AbstractExecutorService
    
      Constructors:
        * ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)
        * ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)
        * ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)
        * ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)
    
    """
    @typing.overload
    def __init__(self, int: int, int2: int, long: int, timeUnit: TimeUnit, blockingQueue: BlockingQueue[java.lang.Runnable]): ...
    @typing.overload
    def __init__(self, int: int, int2: int, long: int, timeUnit: TimeUnit, blockingQueue: BlockingQueue[java.lang.Runnable], rejectedExecutionHandler: RejectedExecutionHandler): ...
    @typing.overload
    def __init__(self, int: int, int2: int, long: int, timeUnit: TimeUnit, blockingQueue: BlockingQueue[java.lang.Runnable], threadFactory: ThreadFactory): ...
    @typing.overload
    def __init__(self, int: int, int2: int, long: int, timeUnit: TimeUnit, blockingQueue: BlockingQueue[java.lang.Runnable], threadFactory: ThreadFactory, rejectedExecutionHandler: RejectedExecutionHandler): ...
    def allowCoreThreadTimeOut(self, boolean: bool) -> None: ...
    def allowsCoreThreadTimeOut(self) -> bool: ...
    def awaitTermination(self, long: int, timeUnit: TimeUnit) -> bool: ...
    def execute(self, runnable: java.lang.Runnable) -> None: ...
    def getActiveCount(self) -> int: ...
    def getCompletedTaskCount(self) -> int: ...
    def getCorePoolSize(self) -> int: ...
    def getKeepAliveTime(self, timeUnit: TimeUnit) -> int: ...
    def getLargestPoolSize(self) -> int: ...
    def getMaximumPoolSize(self) -> int: ...
    def getPoolSize(self) -> int: ...
    def getQueue(self) -> BlockingQueue[java.lang.Runnable]: ...
    def getRejectedExecutionHandler(self) -> RejectedExecutionHandler: ...
    def getTaskCount(self) -> int: ...
    def getThreadFactory(self) -> ThreadFactory: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def isTerminating(self) -> bool: ...
    def prestartAllCoreThreads(self) -> int: ...
    def prestartCoreThread(self) -> bool: ...
    def purge(self) -> None: ...
    def remove(self, runnable: java.lang.Runnable) -> bool: ...
    def setCorePoolSize(self, int: int) -> None: ...
    def setKeepAliveTime(self, long: int, timeUnit: TimeUnit) -> None: ...
    def setMaximumPoolSize(self, int: int) -> None: ...
    def setRejectedExecutionHandler(self, rejectedExecutionHandler: RejectedExecutionHandler) -> None: ...
    def setThreadFactory(self, threadFactory: ThreadFactory) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    def toString(self) -> java.lang.String: ...
    class AbortPolicy(RejectedExecutionHandler):
        """
        Java class 'java.util.concurrent.ThreadPoolExecutor$AbortPolicy'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.concurrent.RejectedExecutionHandler
        
          Constructors:
            * AbortPolicy()
        
        """
        def __init__(self): ...
        def rejectedExecution(self, runnable: java.lang.Runnable, threadPoolExecutor: 'ThreadPoolExecutor') -> None: ...
    class CallerRunsPolicy(RejectedExecutionHandler):
        """
        Java class 'java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.concurrent.RejectedExecutionHandler
        
          Constructors:
            * CallerRunsPolicy()
        
        """
        def __init__(self): ...
        def rejectedExecution(self, runnable: java.lang.Runnable, threadPoolExecutor: 'ThreadPoolExecutor') -> None: ...
    class DiscardOldestPolicy(RejectedExecutionHandler):
        """
        Java class 'java.util.concurrent.ThreadPoolExecutor$DiscardOldestPolicy'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.concurrent.RejectedExecutionHandler
        
          Constructors:
            * DiscardOldestPolicy()
        
        """
        def __init__(self): ...
        def rejectedExecution(self, runnable: java.lang.Runnable, threadPoolExecutor: 'ThreadPoolExecutor') -> None: ...
    class DiscardPolicy(RejectedExecutionHandler):
        """
        Java class 'java.util.concurrent.ThreadPoolExecutor$DiscardPolicy'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.concurrent.RejectedExecutionHandler
        
          Constructors:
            * DiscardPolicy()
        
        """
        def __init__(self): ...
        def rejectedExecution(self, runnable: java.lang.Runnable, threadPoolExecutor: 'ThreadPoolExecutor') -> None: ...

class ScheduledThreadPoolExecutor(ThreadPoolExecutor, ScheduledExecutorService):
    """
    Java class 'java.util.concurrent.ScheduledThreadPoolExecutor'
    
        Extends:
            java.util.concurrent.ThreadPoolExecutor
    
        Interfaces:
            java.util.concurrent.ScheduledExecutorService
    
      Constructors:
        * ScheduledThreadPoolExecutor(int)
        * ScheduledThreadPoolExecutor(int, java.util.concurrent.ThreadFactory)
        * ScheduledThreadPoolExecutor(int, java.util.concurrent.RejectedExecutionHandler)
        * ScheduledThreadPoolExecutor(int, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)
    
    """
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, rejectedExecutionHandler: RejectedExecutionHandler): ...
    @typing.overload
    def __init__(self, int: int, threadFactory: ThreadFactory): ...
    @typing.overload
    def __init__(self, int: int, threadFactory: ThreadFactory, rejectedExecutionHandler: RejectedExecutionHandler): ...
    def execute(self, runnable: java.lang.Runnable) -> None: ...
    def getContinueExistingPeriodicTasksAfterShutdownPolicy(self) -> bool: ...
    def getExecuteExistingDelayedTasksAfterShutdownPolicy(self) -> bool: ...
    def getQueue(self) -> BlockingQueue[java.lang.Runnable]: ...
    def getRemoveOnCancelPolicy(self) -> bool: ...
    @typing.overload
    def schedule(self, runnable: java.lang.Runnable, long: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...
    _schedule_1__V = typing.TypeVar('_schedule_1__V')  # <V>
    @typing.overload
    def schedule(self, callable: typing.Union[Callable[_schedule_1__V], typing.Callable[[], _schedule_1__V]], long: int, timeUnit: TimeUnit) -> ScheduledFuture[_schedule_1__V]: ...
    def scheduleAtFixedRate(self, runnable: java.lang.Runnable, long: int, long2: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...
    def scheduleWithFixedDelay(self, runnable: java.lang.Runnable, long: int, long2: int, timeUnit: TimeUnit) -> ScheduledFuture[typing.Any]: ...
    def setContinueExistingPeriodicTasksAfterShutdownPolicy(self, boolean: bool) -> None: ...
    def setExecuteExistingDelayedTasksAfterShutdownPolicy(self, boolean: bool) -> None: ...
    def setRemoveOnCancelPolicy(self, boolean: bool) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    @typing.overload
    def submit(self, runnable: java.lang.Runnable) -> Future[typing.Any]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    @typing.overload
    def submit(self, runnable: java.lang.Runnable, t: _submit_1__T) -> Future[_submit_1__T]: ...
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, callable: typing.Union[Callable[_submit_2__T], typing.Callable[[], _submit_2__T]]) -> Future[_submit_2__T]: ...

_ConcurrentHashMap__KeySetView__K = typing.TypeVar('_ConcurrentHashMap__KeySetView__K')  # <K>
_ConcurrentHashMap__KeySetView__V = typing.TypeVar('_ConcurrentHashMap__KeySetView__V')  # <V>
_ConcurrentHashMap__K = typing.TypeVar('_ConcurrentHashMap__K')  # <K>
_ConcurrentHashMap__V = typing.TypeVar('_ConcurrentHashMap__V')  # <V>
class ConcurrentHashMap(java.util.AbstractMap[_ConcurrentHashMap__K, _ConcurrentHashMap__V], ConcurrentMap[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.io.Serializable, typing.Generic[_ConcurrentHashMap__K, _ConcurrentHashMap__V]):
    """
    Java class 'java.util.concurrent.ConcurrentHashMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.concurrent.ConcurrentMap, java.io.Serializable
    
      Constructors:
        * ConcurrentHashMap()
        * ConcurrentHashMap(int)
        * ConcurrentHashMap(java.util.Map)
        * ConcurrentHashMap(int, float, int)
        * ConcurrentHashMap(int, float)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, int: int, float: float, int2: int): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Mapping[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]): ...
    def clear(self) -> None: ...
    def compute(self, k: _ConcurrentHashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _ConcurrentHashMap__V]]) -> _ConcurrentHashMap__V: ...
    def computeIfAbsent(self, k: _ConcurrentHashMap__K, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]]) -> _ConcurrentHashMap__V: ...
    def computeIfPresent(self, k: _ConcurrentHashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _ConcurrentHashMap__V]]) -> _ConcurrentHashMap__V: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def elements(self) -> java.util.Enumeration[_ConcurrentHashMap__V]: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]]) -> None: ...
    @typing.overload
    def forEach(self, long: int, biConsumer: typing.Union[java.util.function.BiConsumer[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]]) -> None: ...
    _forEach_2__U = typing.TypeVar('_forEach_2__U')  # <U>
    @typing.overload
    def forEach(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _forEach_2__U], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _forEach_2__U]], consumer: typing.Union[java.util.function.Consumer[_forEach_2__U], typing.Callable[[], _forEach_2__U]]) -> None: ...
    @typing.overload
    def forEachEntry(self, long: int, consumer: typing.Union[java.util.function.Consumer[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], typing.Callable[[], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]]) -> None: ...
    _forEachEntry_1__U = typing.TypeVar('_forEachEntry_1__U')  # <U>
    @typing.overload
    def forEachEntry(self, long: int, function: typing.Union[java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _forEachEntry_1__U], typing.Callable[[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], _forEachEntry_1__U]], consumer: typing.Union[java.util.function.Consumer[_forEachEntry_1__U], typing.Callable[[], _forEachEntry_1__U]]) -> None: ...
    @typing.overload
    def forEachKey(self, long: int, consumer: typing.Union[java.util.function.Consumer[_ConcurrentHashMap__K], typing.Callable[[], _ConcurrentHashMap__K]]) -> None: ...
    _forEachKey_1__U = typing.TypeVar('_forEachKey_1__U')  # <U>
    @typing.overload
    def forEachKey(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__K, _forEachKey_1__U], typing.Callable[[_ConcurrentHashMap__K], _forEachKey_1__U]], consumer: typing.Union[java.util.function.Consumer[_forEachKey_1__U], typing.Callable[[], _forEachKey_1__U]]) -> None: ...
    @typing.overload
    def forEachValue(self, long: int, consumer: typing.Union[java.util.function.Consumer[_ConcurrentHashMap__V], typing.Callable[[], _ConcurrentHashMap__V]]) -> None: ...
    _forEachValue_1__U = typing.TypeVar('_forEachValue_1__U')  # <U>
    @typing.overload
    def forEachValue(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__V, _forEachValue_1__U], typing.Callable[[_ConcurrentHashMap__V], _forEachValue_1__U]], consumer: typing.Union[java.util.function.Consumer[_forEachValue_1__U], typing.Callable[[], _forEachValue_1__U]]) -> None: ...
    def get(self, object: typing.Any) -> _ConcurrentHashMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _ConcurrentHashMap__V) -> _ConcurrentHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def keySet(self) -> java.util.Set: ...
    @typing.overload
    def keySet(self) -> 'ConcurrentHashMap.KeySetView'[_ConcurrentHashMap__K, _ConcurrentHashMap__V]: ...
    @typing.overload
    def keySet(self, v: _ConcurrentHashMap__V) -> 'ConcurrentHashMap.KeySetView'[_ConcurrentHashMap__K, _ConcurrentHashMap__V]: ...
    def keys(self) -> java.util.Enumeration[_ConcurrentHashMap__K]: ...
    def mappingCount(self) -> int: ...
    def merge(self, k: _ConcurrentHashMap__K, v: _ConcurrentHashMap__V, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__V, _ConcurrentHashMap__V, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__V, _ConcurrentHashMap__V], _ConcurrentHashMap__V]]) -> _ConcurrentHashMap__V: ...
    _newKeySet_0__K = typing.TypeVar('_newKeySet_0__K')  # <K>
    @classmethod
    @typing.overload
    def newKeySet(cls) -> 'ConcurrentHashMap.KeySetView'[_newKeySet_0__K, bool]: ...
    _newKeySet_1__K = typing.TypeVar('_newKeySet_1__K')  # <K>
    @classmethod
    @typing.overload
    def newKeySet(cls, int: int) -> 'ConcurrentHashMap.KeySetView'[_newKeySet_1__K, bool]: ...
    def put(self, k: _ConcurrentHashMap__K, v: _ConcurrentHashMap__V) -> _ConcurrentHashMap__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Mapping[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]) -> None: ...
    def putIfAbsent(self, k: _ConcurrentHashMap__K, v: _ConcurrentHashMap__V) -> _ConcurrentHashMap__V: ...
    _reduce__U = typing.TypeVar('_reduce__U')  # <U>
    def reduce(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _reduce__U], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _reduce__U]], biFunction2: typing.Union[java.util.function.BiFunction[_reduce__U, _reduce__U, _reduce__U], typing.Callable[[_reduce__U, _reduce__U], _reduce__U]]) -> _reduce__U: ...
    _reduceEntries_0__U = typing.TypeVar('_reduceEntries_0__U')  # <U>
    @typing.overload
    def reduceEntries(self, long: int, function: typing.Union[java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _reduceEntries_0__U], typing.Callable[[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], _reduceEntries_0__U]], biFunction: typing.Union[java.util.function.BiFunction[_reduceEntries_0__U, _reduceEntries_0__U, _reduceEntries_0__U], typing.Callable[[_reduceEntries_0__U, _reduceEntries_0__U], _reduceEntries_0__U]]) -> _reduceEntries_0__U: ...
    @typing.overload
    def reduceEntries(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], typing.Callable[[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]]) -> java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]: ...
    def reduceEntriesToDouble(self, long: int, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], typing.Callable[[], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]], double: float, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> float: ...
    def reduceEntriesToInt(self, long: int, toIntFunction: typing.Union[java.util.function.ToIntFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], typing.Callable[[], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]], int: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> int: ...
    def reduceEntriesToLong(self, long: int, toLongFunction: typing.Union[java.util.function.ToLongFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], typing.Callable[[], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]], long2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> int: ...
    @typing.overload
    def reduceKeys(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__K, _ConcurrentHashMap__K], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__K], _ConcurrentHashMap__K]]) -> _ConcurrentHashMap__K: ...
    _reduceKeys_1__U = typing.TypeVar('_reduceKeys_1__U')  # <U>
    @typing.overload
    def reduceKeys(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__K, _reduceKeys_1__U], typing.Callable[[_ConcurrentHashMap__K], _reduceKeys_1__U]], biFunction: typing.Union[java.util.function.BiFunction[_reduceKeys_1__U, _reduceKeys_1__U, _reduceKeys_1__U], typing.Callable[[_reduceKeys_1__U, _reduceKeys_1__U], _reduceKeys_1__U]]) -> _reduceKeys_1__U: ...
    def reduceKeysToDouble(self, long: int, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_ConcurrentHashMap__K], typing.Callable[[], _ConcurrentHashMap__K]], double: float, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> float: ...
    def reduceKeysToInt(self, long: int, toIntFunction: typing.Union[java.util.function.ToIntFunction[_ConcurrentHashMap__K], typing.Callable[[], _ConcurrentHashMap__K]], int: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> int: ...
    def reduceKeysToLong(self, long: int, toLongFunction: typing.Union[java.util.function.ToLongFunction[_ConcurrentHashMap__K], typing.Callable[[], _ConcurrentHashMap__K]], long2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> int: ...
    def reduceToDouble(self, long: int, toDoubleBiFunction: typing.Union[java.util.function.ToDoubleBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]], double: float, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> float: ...
    def reduceToInt(self, long: int, toIntBiFunction: typing.Union[java.util.function.ToIntBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]], int: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> int: ...
    def reduceToLong(self, long: int, toLongBiFunction: typing.Union[java.util.function.ToLongBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K], _ConcurrentHashMap__V]], long2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> int: ...
    @typing.overload
    def reduceValues(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__V, _ConcurrentHashMap__V, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__V, _ConcurrentHashMap__V], _ConcurrentHashMap__V]]) -> _ConcurrentHashMap__V: ...
    _reduceValues_1__U = typing.TypeVar('_reduceValues_1__U')  # <U>
    @typing.overload
    def reduceValues(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__V, _reduceValues_1__U], typing.Callable[[_ConcurrentHashMap__V], _reduceValues_1__U]], biFunction: typing.Union[java.util.function.BiFunction[_reduceValues_1__U, _reduceValues_1__U, _reduceValues_1__U], typing.Callable[[_reduceValues_1__U, _reduceValues_1__U], _reduceValues_1__U]]) -> _reduceValues_1__U: ...
    def reduceValuesToDouble(self, long: int, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_ConcurrentHashMap__V], typing.Callable[[], _ConcurrentHashMap__V]], double: float, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> float: ...
    def reduceValuesToInt(self, long: int, toIntFunction: typing.Union[java.util.function.ToIntFunction[_ConcurrentHashMap__V], typing.Callable[[], _ConcurrentHashMap__V]], int: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> int: ...
    def reduceValuesToLong(self, long: int, toLongFunction: typing.Union[java.util.function.ToLongFunction[_ConcurrentHashMap__V], typing.Callable[[], _ConcurrentHashMap__V]], long2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ConcurrentHashMap__V: ...
    @typing.overload
    def replace(self, k: _ConcurrentHashMap__K, v: _ConcurrentHashMap__V, v2: _ConcurrentHashMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ConcurrentHashMap__K, v: _ConcurrentHashMap__V) -> _ConcurrentHashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _ConcurrentHashMap__V]]) -> None: ...
    _search__U = typing.TypeVar('_search__U')  # <U>
    def search(self, long: int, biFunction: typing.Union[java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _search__U], typing.Callable[[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _search__U]]) -> _search__U: ...
    _searchEntries__U = typing.TypeVar('_searchEntries__U')  # <U>
    def searchEntries(self, long: int, function: typing.Union[java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _searchEntries__U], typing.Callable[[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], _searchEntries__U]]) -> _searchEntries__U: ...
    _searchKeys__U = typing.TypeVar('_searchKeys__U')  # <U>
    def searchKeys(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__K, _searchKeys__U], typing.Callable[[_ConcurrentHashMap__K], _searchKeys__U]]) -> _searchKeys__U: ...
    _searchValues__U = typing.TypeVar('_searchValues__U')  # <U>
    def searchValues(self, long: int, function: typing.Union[java.util.function.Function[_ConcurrentHashMap__V, _searchValues__U], typing.Callable[[_ConcurrentHashMap__V], _searchValues__U]]) -> _searchValues__U: ...
    def size(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def values(self) -> java.util.Collection[_ConcurrentHashMap__V]: ...
    class KeySetView(java.util.concurrent.ConcurrentHashMap.CollectionView[_ConcurrentHashMap__KeySetView__K, _ConcurrentHashMap__KeySetView__V, _ConcurrentHashMap__KeySetView__K], java.util.Set[_ConcurrentHashMap__KeySetView__K], typing.Generic[_ConcurrentHashMap__KeySetView__K, _ConcurrentHashMap__KeySetView__V]):
        """
        Java class 'java.util.concurrent.ConcurrentHashMap$KeySetView'
        
            Extends:
                java.util.concurrent.ConcurrentHashMap$CollectionView
        
            Interfaces:
                java.util.Set, java.io.Serializable
        
        """
        def add(self, k: _ConcurrentHashMap__KeySetView__K) -> bool: ...
        def addAll(self, collection: typing.Union[java.util.Collection[_ConcurrentHashMap__KeySetView__K], typing.Sequence[_ConcurrentHashMap__KeySetView__K]]) -> bool: ...
        def contains(self, object: typing.Any) -> bool: ...
        def equals(self, object: typing.Any) -> bool: ...
        def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ConcurrentHashMap__KeySetView__K], typing.Callable[[], _ConcurrentHashMap__KeySetView__K]]) -> None: ...
        def getMap(self) -> 'ConcurrentHashMap': ...
        def getMappedValue(self) -> _ConcurrentHashMap__KeySetView__V: ...
        def hashCode(self) -> int: ...
        def iterator(self) -> java.util.Iterator[_ConcurrentHashMap__KeySetView__K]: ...
        def remove(self, object: typing.Any) -> bool: ...
        def removeAll(self, collection: java.util.Collection) -> bool: ...
        def spliterator(self) -> java.util.Spliterator[_ConcurrentHashMap__KeySetView__K]: ...
    class CollectionView: ...

_Flow__Processor__T = typing.TypeVar('_Flow__Processor__T')  # <T>
_Flow__Processor__R = typing.TypeVar('_Flow__Processor__R')  # <R>
_Flow__Publisher__T = typing.TypeVar('_Flow__Publisher__T')  # <T>
_Flow__Subscriber__T = typing.TypeVar('_Flow__Subscriber__T')  # <T>
class Flow(java.lang.Object):
    """
    Java class 'java.util.concurrent.Flow'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def defaultBufferSize(cls) -> int: ...
    class Processor(java.util.concurrent.Flow.Subscriber[_Flow__Processor__T], java.util.concurrent.Flow.Publisher[_Flow__Processor__R], typing.Generic[_Flow__Processor__T, _Flow__Processor__R]):
        """
        Java class 'java.util.concurrent.Flow$Processor'
        
            Interfaces:
                java.util.concurrent.Flow.Subscriber,
                java.util.concurrent.Flow.Publisher
        
        """
    class Publisher(java.lang.Object, typing.Generic[_Flow__Publisher__T]):
        """
        Java class 'java.util.concurrent.Flow$Publisher'
        
        """
        def subscribe(self, subscriber: 'Flow.Subscriber'[_Flow__Publisher__T]) -> None: ...
    class Subscriber(java.lang.Object, typing.Generic[_Flow__Subscriber__T]):
        """
        Java class 'java.util.concurrent.Flow$Subscriber'
        
        """
        def onComplete(self) -> None: ...
        def onError(self, throwable: java.lang.Throwable) -> None: ...
        def onNext(self, t: _Flow__Subscriber__T) -> None: ...
        def onSubscribe(self, subscription: 'Flow.Subscription') -> None: ...
    class Subscription(java.lang.Object):
        """
        Java class 'java.util.concurrent.Flow$Subscription'
        
        """
        def cancel(self) -> None: ...
        def request(self, long: int) -> None: ...

_SubmissionPublisher__T = typing.TypeVar('_SubmissionPublisher__T')  # <T>
class SubmissionPublisher(Flow.Publisher[_SubmissionPublisher__T], java.lang.AutoCloseable, typing.Generic[_SubmissionPublisher__T]):
    """
    Java class 'java.util.concurrent.SubmissionPublisher'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.concurrent.Flow.Publisher, java.lang.AutoCloseable
    
      Constructors:
        * SubmissionPublisher()
        * SubmissionPublisher(java.util.concurrent.Executor, int)
        * SubmissionPublisher(java.util.concurrent.Executor, int, java.util.function.BiConsumer)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, executor: Executor, int: int): ...
    @typing.overload
    def __init__(self, executor: Executor, int: int, biConsumer: typing.Union[java.util.function.BiConsumer[Flow.Subscriber[_SubmissionPublisher__T], java.lang.Throwable], typing.Callable[[Flow.Subscriber[_SubmissionPublisher__T]], java.lang.Throwable]]): ...
    def close(self) -> None: ...
    def closeExceptionally(self, throwable: java.lang.Throwable) -> None: ...
    def consume(self, consumer: typing.Union[java.util.function.Consumer[_SubmissionPublisher__T], typing.Callable[[], _SubmissionPublisher__T]]) -> CompletableFuture[None]: ...
    def estimateMaximumLag(self) -> int: ...
    def estimateMinimumDemand(self) -> int: ...
    def getClosedException(self) -> java.lang.Throwable: ...
    def getExecutor(self) -> Executor: ...
    def getMaxBufferCapacity(self) -> int: ...
    def getNumberOfSubscribers(self) -> int: ...
    def getSubscribers(self) -> java.util.List[Flow.Subscriber[_SubmissionPublisher__T]]: ...
    def hasSubscribers(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isSubscribed(self, subscriber: Flow.Subscriber[_SubmissionPublisher__T]) -> bool: ...
    @typing.overload
    def offer(self, t: _SubmissionPublisher__T, biPredicate: typing.Union[java.util.function.BiPredicate[Flow.Subscriber[_SubmissionPublisher__T], _SubmissionPublisher__T], typing.Callable[[Flow.Subscriber[_SubmissionPublisher__T]], _SubmissionPublisher__T]]) -> int: ...
    @typing.overload
    def offer(self, t: _SubmissionPublisher__T, long: int, timeUnit: TimeUnit, biPredicate: typing.Union[java.util.function.BiPredicate[Flow.Subscriber[_SubmissionPublisher__T], _SubmissionPublisher__T], typing.Callable[[Flow.Subscriber[_SubmissionPublisher__T]], _SubmissionPublisher__T]]) -> int: ...
    def submit(self, t: _SubmissionPublisher__T) -> int: ...
    def subscribe(self, subscriber: Flow.Subscriber[_SubmissionPublisher__T]) -> None: ...

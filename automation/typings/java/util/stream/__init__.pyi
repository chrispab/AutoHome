import java
import java.lang
import java.util
import java.util.concurrent
import java.util.function
import typing


_BaseStream__T = typing.TypeVar('_BaseStream__T')  # <T>
_BaseStream__S = typing.TypeVar('_BaseStream__S', bound='BaseStream')  # <S>
class BaseStream(java.lang.AutoCloseable, typing.Generic[_BaseStream__T, _BaseStream__S]):
    """
    Java class 'java.util.stream.BaseStream'
    
        Interfaces:
            java.lang.AutoCloseable
    
    """
    def close(self) -> None: ...
    def isParallel(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_BaseStream__T]: ...
    def onClose(self, runnable: java.lang.Runnable) -> _BaseStream__S: ...
    def parallel(self) -> _BaseStream__S: ...
    def sequential(self) -> _BaseStream__S: ...
    def spliterator(self) -> java.util.Spliterator[_BaseStream__T]: ...
    def unordered(self) -> _BaseStream__S: ...

_Collector__T = typing.TypeVar('_Collector__T')  # <T>
_Collector__A = typing.TypeVar('_Collector__A')  # <A>
_Collector__R = typing.TypeVar('_Collector__R')  # <R>
class Collector(java.lang.Object, typing.Generic[_Collector__T, _Collector__A, _Collector__R]):
    """
    public interface Collector<T,​A,​R>
    
        A :meth:`~java.util.stream.package` that accumulates input elements into a mutable result container, optionally
        transforming the accumulated result into a final representation after all input elements have been processed. Reduction
        operations can be performed either sequentially or in parallel.
    
        Examples of mutable reduction operations include: accumulating elements into a :code:`Collection`; concatenating strings
        using a :code:`StringBuilder`; computing summary information about elements such as sum, min, max, or average; computing
        "pivot table" summaries such as "maximum valued transaction by seller", etc. The class
        :class:`~java.util.stream.Collectors` provides implementations of many common mutable reductions.
    
        A :code:`Collector` is specified by four functions that work together to accumulate entries into a mutable result
        container, and optionally perform a final transform on the result. They are:
    
          - creation of a new result container (:meth:`~java.util.stream.Collector.supplier`)
          - incorporating a new data element into a result container (:meth:`~java.util.stream.Collector.accumulator`)
          - combining two result containers into one (:meth:`~java.util.stream.Collector.combiner`)
          - performing an optional final transform on the container (:meth:`~java.util.stream.Collector.finisher`)
    
    
        Collectors also have a set of characteristics, such as :meth:`~java.util.stream.Collector.Characteristics.CONCURRENT`,
        that provide hints that can be used by a reduction implementation to provide better performance.
    
        A sequential implementation of a reduction using a collector would create a single result container using the supplier
        function, and invoke the accumulator function once for each input element. A parallel implementation would partition the
        input, create a result container for each partition, accumulate the contents of each partition into a subresult for that
        partition, and then use the combiner function to merge the subresults into a combined result.
    
        To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an
        *identity* and an :meth:`~java.util.stream.package` constraints.
    
        The identity constraint says that for any partially accumulated result, combining it with an empty result container must
        produce an equivalent result. That is, for a partially accumulated result :code:`a` that is the result of any series of
        accumulator and combiner invocations, :code:`a` must be equivalent to :code:`combiner.apply(a, supplier.get())`.
    
        The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any
        input elements :code:`t1` and :code:`t2`, the results :code:`r1` and :code:`r2` in the computation below must be
        equivalent:
    
        .. code-block: java
        
             A a1 = supplier.get();
             accumulator.accept(a1, t1);
             accumulator.accept(a1, t2);
             R r1 = finisher.apply(a1);  // result without splitting
        
             A a2 = supplier.get();
             accumulator.accept(a2, t1);
             A a3 = supplier.get();
             accumulator.accept(a3, t2);
             R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
          
    
        For collectors that do not have the :code:`UNORDERED` characteristic, two accumulated results :code:`a1` and :code:`a2`
        are equivalent if :code:`finisher.apply(a1).equals(finisher.apply(a2))`. For unordered collectors, equivalence is
        relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated
        elements to a :code:`List` would consider two lists equivalent if they contained the same elements, ignoring order.)
    
        Libraries that implement reduction based on :code:`Collector`, such as :meth:`~java.util.stream.Stream.collect`, must
        adhere to the following constraints:
    
          - The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument
            passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or
            combiner functions.
          - The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner
            functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the
            caller of the reduction operation.
          - If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it
            is never used again.
          - Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.
          - For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be
            serially thread-confined. This enables collection to occur in parallel without the :code:`Collector` needing to
            implement any additional synchronization. The reduction implementation must manage that the input is properly
            partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.
          - For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A
            concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same
            concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent
            reduction should only be applied if the collector has the :meth:`~java.util.stream.Collector.Characteristics.UNORDERED`
            characteristics or if the originating data is unordered.
    
    
        In addition to the predefined implementations in :class:`~java.util.stream.Collectors`, the static factory methods
        :meth:`~java.util.stream.Collector.of` can be used to construct collectors. For example, you could create a collector
        that accumulates widgets into a :code:`TreeSet` with:
    
        .. code-block: java
        
             Collector<Widget, ?, TreeSet<Widget>&gt; intoSet =
                 Collector.of(TreeSet::new, TreeSet::add,
                              (left, right) -> { left.addAll(right); return left; });
         
        (This behavior is also implemented by the predefined collector :meth:`~java.util.stream.Collectors.toCollection`).
    
        API Note:
            Performing a reduction operation with a :code:`Collector` should produce a result equivalent to:
    
            .. code-block: java
            
                 R container = collector.supplier().get();
                 for (T t : data)
                     collector.accumulator().accept(container, t);
                 return collector.finisher().apply(container);
             
    
            However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner
            function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation,
            this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)
    
            Collectors are designed to be *composed*; many of the methods in :class:`~java.util.stream.Collectors` are functions
            that take a collector and produce a new collector. For example, given the following collector that computes the sum of
            the salaries of a stream of employees:
    
            .. code-block: java
            
                 Collector<Employee, ?, Integer> summingSalaries
                     = Collectors.summingInt(Employee::getSalary))
             
            If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the "sum of salaries"
            logic using :meth:`~java.util.stream.Collectors.groupingBy`:
    
            .. code-block: java
            
                 Collector<Employee, ?, Map<Department, Integer>&gt; summingSalariesByDept
                     = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
             
    
        Since:
            1.8
    
        Also see:
            :meth:`~java.util.stream.Stream.collect`, :class:`~java.util.stream.Collectors`
    
    
    """
    def accumulator(self) -> java.util.function.BiConsumer[_Collector__A, _Collector__T]: ...
    def characteristics(self) -> java.util.Set['Collector.Characteristics']: ...
    def combiner(self) -> java.util.function.BinaryOperator[_Collector__A]: ...
    def finisher(self) -> java.util.function.Function[_Collector__A, _Collector__R]: ...
    _of_0__T = typing.TypeVar('_of_0__T')  # <T>
    _of_0__A = typing.TypeVar('_of_0__A')  # <A>
    _of_0__R = typing.TypeVar('_of_0__R')  # <R>
    @classmethod
    @typing.overload
    def of(cls, supplier: typing.Union[java.util.function.Supplier[_of_0__A], typing.Callable[[], _of_0__A]], biConsumer: typing.Union[java.util.function.BiConsumer[_of_0__A, _of_0__T], typing.Callable[[_of_0__A], _of_0__T]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_of_0__A], typing.Callable[[], _of_0__A]], function: typing.Union[java.util.function.Function[_of_0__A, _of_0__R], typing.Callable[[_of_0__A], _of_0__R]], characteristicsArray: typing.List['Collector.Characteristics']) -> 'Collector'[_of_0__T, _of_0__A, _of_0__R]: ...
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    _of_1__R = typing.TypeVar('_of_1__R')  # <R>
    @classmethod
    @typing.overload
    def of(cls, supplier: typing.Union[java.util.function.Supplier[_of_1__R], typing.Callable[[], _of_1__R]], biConsumer: typing.Union[java.util.function.BiConsumer[_of_1__R, _of_1__T], typing.Callable[[_of_1__R], _of_1__T]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_of_1__R], typing.Callable[[], _of_1__R]], characteristicsArray: typing.List['Collector.Characteristics']) -> 'Collector'[_of_1__T, _of_1__R, _of_1__R]: ...
    def supplier(self) -> java.util.function.Supplier[_Collector__A]: ...
    class Characteristics(java.lang.Enum[java.util.stream.Collector.Characteristics]):
        """
        Java class 'java.util.stream.Collector$Characteristics'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            CONCURRENT (java.util.stream.Collector$Characteristics): final static enum constant
            UNORDERED (java.util.stream.Collector$Characteristics): final static enum constant
            IDENTITY_FINISH (java.util.stream.Collector$Characteristics): final static enum constant
        
        """
        CONCURRENT: typing.ClassVar['Collector.Characteristics'] = ...
        UNORDERED: typing.ClassVar['Collector.Characteristics'] = ...
        IDENTITY_FINISH: typing.ClassVar['Collector.Characteristics'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Collector.Characteristics': ...
        @classmethod
        def values(cls) -> typing.List['Collector.Characteristics']: ...

class Collectors(java.lang.Object):
    """
    Java class 'java.util.stream.Collectors'
    
        Extends:
            java.lang.Object
    
    """
    _averagingDouble__T = typing.TypeVar('_averagingDouble__T')  # <T>
    @classmethod
    def averagingDouble(cls, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_averagingDouble__T], typing.Callable[[], _averagingDouble__T]]) -> Collector[_averagingDouble__T, typing.Any, float]: ...
    _averagingInt__T = typing.TypeVar('_averagingInt__T')  # <T>
    @classmethod
    def averagingInt(cls, toIntFunction: typing.Union[java.util.function.ToIntFunction[_averagingInt__T], typing.Callable[[], _averagingInt__T]]) -> Collector[_averagingInt__T, typing.Any, float]: ...
    _averagingLong__T = typing.TypeVar('_averagingLong__T')  # <T>
    @classmethod
    def averagingLong(cls, toLongFunction: typing.Union[java.util.function.ToLongFunction[_averagingLong__T], typing.Callable[[], _averagingLong__T]]) -> Collector[_averagingLong__T, typing.Any, float]: ...
    _collectingAndThen__T = typing.TypeVar('_collectingAndThen__T')  # <T>
    _collectingAndThen__A = typing.TypeVar('_collectingAndThen__A')  # <A>
    _collectingAndThen__R = typing.TypeVar('_collectingAndThen__R')  # <R>
    _collectingAndThen__RR = typing.TypeVar('_collectingAndThen__RR')  # <RR>
    @classmethod
    def collectingAndThen(cls, collector: Collector[_collectingAndThen__T, _collectingAndThen__A, _collectingAndThen__R], function: typing.Union[java.util.function.Function[_collectingAndThen__R, _collectingAndThen__RR], typing.Callable[[_collectingAndThen__R], _collectingAndThen__RR]]) -> Collector[_collectingAndThen__T, _collectingAndThen__A, _collectingAndThen__RR]: ...
    _counting__T = typing.TypeVar('_counting__T')  # <T>
    @classmethod
    def counting(cls) -> Collector[_counting__T, typing.Any, int]: ...
    _filtering__T = typing.TypeVar('_filtering__T')  # <T>
    _filtering__A = typing.TypeVar('_filtering__A')  # <A>
    _filtering__R = typing.TypeVar('_filtering__R')  # <R>
    @classmethod
    def filtering(cls, predicate: typing.Union[java.util.function.Predicate[_filtering__T], typing.Callable[[], _filtering__T]], collector: Collector[_filtering__T, _filtering__A, _filtering__R]) -> Collector[_filtering__T, typing.Any, _filtering__R]: ...
    _flatMapping__T = typing.TypeVar('_flatMapping__T')  # <T>
    _flatMapping__U = typing.TypeVar('_flatMapping__U')  # <U>
    _flatMapping__A = typing.TypeVar('_flatMapping__A')  # <A>
    _flatMapping__R = typing.TypeVar('_flatMapping__R')  # <R>
    @classmethod
    def flatMapping(cls, function: typing.Union[java.util.function.Function[_flatMapping__T, 'Stream'[_flatMapping__U]], typing.Callable[[_flatMapping__T], 'Stream'[_flatMapping__U]]], collector: Collector[_flatMapping__U, _flatMapping__A, _flatMapping__R]) -> Collector[_flatMapping__T, typing.Any, _flatMapping__R]: ...
    _groupingBy_0__T = typing.TypeVar('_groupingBy_0__T')  # <T>
    _groupingBy_0__K = typing.TypeVar('_groupingBy_0__K')  # <K>
    @classmethod
    @typing.overload
    def groupingBy(cls, function: typing.Union[java.util.function.Function[_groupingBy_0__T, _groupingBy_0__K], typing.Callable[[_groupingBy_0__T], _groupingBy_0__K]]) -> Collector[_groupingBy_0__T, typing.Any, java.util.Map[_groupingBy_0__K, java.util.List[_groupingBy_0__T]]]: ...
    _groupingBy_1__T = typing.TypeVar('_groupingBy_1__T')  # <T>
    _groupingBy_1__K = typing.TypeVar('_groupingBy_1__K')  # <K>
    _groupingBy_1__D = typing.TypeVar('_groupingBy_1__D')  # <D>
    _groupingBy_1__A = typing.TypeVar('_groupingBy_1__A')  # <A>
    _groupingBy_1__M = typing.TypeVar('_groupingBy_1__M', bound=java.util.Map)  # <M>
    @classmethod
    @typing.overload
    def groupingBy(cls, function: typing.Union[java.util.function.Function[_groupingBy_1__T, _groupingBy_1__K], typing.Callable[[_groupingBy_1__T], _groupingBy_1__K]], supplier: typing.Union[java.util.function.Supplier[_groupingBy_1__M], typing.Callable[[], _groupingBy_1__M]], collector: Collector[_groupingBy_1__T, _groupingBy_1__A, _groupingBy_1__D]) -> Collector[_groupingBy_1__T, typing.Any, _groupingBy_1__M]: ...
    _groupingBy_2__T = typing.TypeVar('_groupingBy_2__T')  # <T>
    _groupingBy_2__K = typing.TypeVar('_groupingBy_2__K')  # <K>
    _groupingBy_2__A = typing.TypeVar('_groupingBy_2__A')  # <A>
    _groupingBy_2__D = typing.TypeVar('_groupingBy_2__D')  # <D>
    @classmethod
    @typing.overload
    def groupingBy(cls, function: typing.Union[java.util.function.Function[_groupingBy_2__T, _groupingBy_2__K], typing.Callable[[_groupingBy_2__T], _groupingBy_2__K]], collector: Collector[_groupingBy_2__T, _groupingBy_2__A, _groupingBy_2__D]) -> Collector[_groupingBy_2__T, typing.Any, java.util.Map[_groupingBy_2__K, _groupingBy_2__D]]: ...
    _groupingByConcurrent_0__T = typing.TypeVar('_groupingByConcurrent_0__T')  # <T>
    _groupingByConcurrent_0__K = typing.TypeVar('_groupingByConcurrent_0__K')  # <K>
    @classmethod
    @typing.overload
    def groupingByConcurrent(cls, function: typing.Union[java.util.function.Function[_groupingByConcurrent_0__T, _groupingByConcurrent_0__K], typing.Callable[[_groupingByConcurrent_0__T], _groupingByConcurrent_0__K]]) -> Collector[_groupingByConcurrent_0__T, typing.Any, java.util.concurrent.ConcurrentMap[_groupingByConcurrent_0__K, java.util.List[_groupingByConcurrent_0__T]]]: ...
    _groupingByConcurrent_1__T = typing.TypeVar('_groupingByConcurrent_1__T')  # <T>
    _groupingByConcurrent_1__K = typing.TypeVar('_groupingByConcurrent_1__K')  # <K>
    _groupingByConcurrent_1__A = typing.TypeVar('_groupingByConcurrent_1__A')  # <A>
    _groupingByConcurrent_1__D = typing.TypeVar('_groupingByConcurrent_1__D')  # <D>
    _groupingByConcurrent_1__M = typing.TypeVar('_groupingByConcurrent_1__M', bound=java.util.concurrent.ConcurrentMap)  # <M>
    @classmethod
    @typing.overload
    def groupingByConcurrent(cls, function: typing.Union[java.util.function.Function[_groupingByConcurrent_1__T, _groupingByConcurrent_1__K], typing.Callable[[_groupingByConcurrent_1__T], _groupingByConcurrent_1__K]], supplier: typing.Union[java.util.function.Supplier[_groupingByConcurrent_1__M], typing.Callable[[], _groupingByConcurrent_1__M]], collector: Collector[_groupingByConcurrent_1__T, _groupingByConcurrent_1__A, _groupingByConcurrent_1__D]) -> Collector[_groupingByConcurrent_1__T, typing.Any, _groupingByConcurrent_1__M]: ...
    _groupingByConcurrent_2__T = typing.TypeVar('_groupingByConcurrent_2__T')  # <T>
    _groupingByConcurrent_2__K = typing.TypeVar('_groupingByConcurrent_2__K')  # <K>
    _groupingByConcurrent_2__A = typing.TypeVar('_groupingByConcurrent_2__A')  # <A>
    _groupingByConcurrent_2__D = typing.TypeVar('_groupingByConcurrent_2__D')  # <D>
    @classmethod
    @typing.overload
    def groupingByConcurrent(cls, function: typing.Union[java.util.function.Function[_groupingByConcurrent_2__T, _groupingByConcurrent_2__K], typing.Callable[[_groupingByConcurrent_2__T], _groupingByConcurrent_2__K]], collector: Collector[_groupingByConcurrent_2__T, _groupingByConcurrent_2__A, _groupingByConcurrent_2__D]) -> Collector[_groupingByConcurrent_2__T, typing.Any, java.util.concurrent.ConcurrentMap[_groupingByConcurrent_2__K, _groupingByConcurrent_2__D]]: ...
    @classmethod
    @typing.overload
    def joining(cls) -> Collector[java.lang.CharSequence, typing.Any, java.lang.String]: ...
    @classmethod
    @typing.overload
    def joining(cls, charSequence: java.lang.CharSequence) -> Collector[java.lang.CharSequence, typing.Any, java.lang.String]: ...
    @classmethod
    @typing.overload
    def joining(cls, charSequence: java.lang.CharSequence, charSequence2: java.lang.CharSequence, charSequence3: java.lang.CharSequence) -> Collector[java.lang.CharSequence, typing.Any, java.lang.String]: ...
    _mapping__T = typing.TypeVar('_mapping__T')  # <T>
    _mapping__U = typing.TypeVar('_mapping__U')  # <U>
    _mapping__A = typing.TypeVar('_mapping__A')  # <A>
    _mapping__R = typing.TypeVar('_mapping__R')  # <R>
    @classmethod
    def mapping(cls, function: typing.Union[java.util.function.Function[_mapping__T, _mapping__U], typing.Callable[[_mapping__T], _mapping__U]], collector: Collector[_mapping__U, _mapping__A, _mapping__R]) -> Collector[_mapping__T, typing.Any, _mapping__R]: ...
    _maxBy__T = typing.TypeVar('_maxBy__T')  # <T>
    @classmethod
    def maxBy(cls, comparator: typing.Union[java.util.Comparator[_maxBy__T], typing.Callable[[], _maxBy__T]]) -> Collector[_maxBy__T, typing.Any, java.util.Optional[_maxBy__T]]: ...
    _minBy__T = typing.TypeVar('_minBy__T')  # <T>
    @classmethod
    def minBy(cls, comparator: typing.Union[java.util.Comparator[_minBy__T], typing.Callable[[], _minBy__T]]) -> Collector[_minBy__T, typing.Any, java.util.Optional[_minBy__T]]: ...
    _partitioningBy_0__T = typing.TypeVar('_partitioningBy_0__T')  # <T>
    @classmethod
    @typing.overload
    def partitioningBy(cls, predicate: typing.Union[java.util.function.Predicate[_partitioningBy_0__T], typing.Callable[[], _partitioningBy_0__T]]) -> Collector[_partitioningBy_0__T, typing.Any, java.util.Map[bool, java.util.List[_partitioningBy_0__T]]]: ...
    _partitioningBy_1__T = typing.TypeVar('_partitioningBy_1__T')  # <T>
    _partitioningBy_1__D = typing.TypeVar('_partitioningBy_1__D')  # <D>
    _partitioningBy_1__A = typing.TypeVar('_partitioningBy_1__A')  # <A>
    @classmethod
    @typing.overload
    def partitioningBy(cls, predicate: typing.Union[java.util.function.Predicate[_partitioningBy_1__T], typing.Callable[[], _partitioningBy_1__T]], collector: Collector[_partitioningBy_1__T, _partitioningBy_1__A, _partitioningBy_1__D]) -> Collector[_partitioningBy_1__T, typing.Any, java.util.Map[bool, _partitioningBy_1__D]]: ...
    _reducing_0__T = typing.TypeVar('_reducing_0__T')  # <T>
    @classmethod
    @typing.overload
    def reducing(cls, t: _reducing_0__T, binaryOperator: typing.Union[java.util.function.BinaryOperator[_reducing_0__T], typing.Callable[[], _reducing_0__T]]) -> Collector[_reducing_0__T, typing.Any, _reducing_0__T]: ...
    _reducing_1__T = typing.TypeVar('_reducing_1__T')  # <T>
    _reducing_1__U = typing.TypeVar('_reducing_1__U')  # <U>
    @classmethod
    @typing.overload
    def reducing(cls, u: _reducing_1__U, function: typing.Union[java.util.function.Function[_reducing_1__T, _reducing_1__U], typing.Callable[[_reducing_1__T], _reducing_1__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_reducing_1__U], typing.Callable[[], _reducing_1__U]]) -> Collector[_reducing_1__T, typing.Any, _reducing_1__U]: ...
    _reducing_2__T = typing.TypeVar('_reducing_2__T')  # <T>
    @classmethod
    @typing.overload
    def reducing(cls, binaryOperator: typing.Union[java.util.function.BinaryOperator[_reducing_2__T], typing.Callable[[], _reducing_2__T]]) -> Collector[_reducing_2__T, typing.Any, java.util.Optional[_reducing_2__T]]: ...
    _summarizingDouble__T = typing.TypeVar('_summarizingDouble__T')  # <T>
    @classmethod
    def summarizingDouble(cls, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_summarizingDouble__T], typing.Callable[[], _summarizingDouble__T]]) -> Collector[_summarizingDouble__T, typing.Any, java.util.DoubleSummaryStatistics]: ...
    _summarizingInt__T = typing.TypeVar('_summarizingInt__T')  # <T>
    @classmethod
    def summarizingInt(cls, toIntFunction: typing.Union[java.util.function.ToIntFunction[_summarizingInt__T], typing.Callable[[], _summarizingInt__T]]) -> Collector[_summarizingInt__T, typing.Any, java.util.IntSummaryStatistics]: ...
    _summarizingLong__T = typing.TypeVar('_summarizingLong__T')  # <T>
    @classmethod
    def summarizingLong(cls, toLongFunction: typing.Union[java.util.function.ToLongFunction[_summarizingLong__T], typing.Callable[[], _summarizingLong__T]]) -> Collector[_summarizingLong__T, typing.Any, java.util.LongSummaryStatistics]: ...
    _summingDouble__T = typing.TypeVar('_summingDouble__T')  # <T>
    @classmethod
    def summingDouble(cls, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_summingDouble__T], typing.Callable[[], _summingDouble__T]]) -> Collector[_summingDouble__T, typing.Any, float]: ...
    _summingInt__T = typing.TypeVar('_summingInt__T')  # <T>
    @classmethod
    def summingInt(cls, toIntFunction: typing.Union[java.util.function.ToIntFunction[_summingInt__T], typing.Callable[[], _summingInt__T]]) -> Collector[_summingInt__T, typing.Any, int]: ...
    _summingLong__T = typing.TypeVar('_summingLong__T')  # <T>
    @classmethod
    def summingLong(cls, toLongFunction: typing.Union[java.util.function.ToLongFunction[_summingLong__T], typing.Callable[[], _summingLong__T]]) -> Collector[_summingLong__T, typing.Any, int]: ...
    _toCollection__T = typing.TypeVar('_toCollection__T')  # <T>
    _toCollection__C = typing.TypeVar('_toCollection__C', bound=java.util.Collection)  # <C>
    @classmethod
    def toCollection(cls, supplier: typing.Union[java.util.function.Supplier[_toCollection__C], typing.Callable[[], _toCollection__C]]) -> Collector[_toCollection__T, typing.Any, _toCollection__C]: ...
    _toConcurrentMap_0__T = typing.TypeVar('_toConcurrentMap_0__T')  # <T>
    _toConcurrentMap_0__K = typing.TypeVar('_toConcurrentMap_0__K')  # <K>
    _toConcurrentMap_0__U = typing.TypeVar('_toConcurrentMap_0__U')  # <U>
    @classmethod
    @typing.overload
    def toConcurrentMap(cls, function: typing.Union[java.util.function.Function[_toConcurrentMap_0__T, _toConcurrentMap_0__K], typing.Callable[[_toConcurrentMap_0__T], _toConcurrentMap_0__K]], function2: typing.Union[java.util.function.Function[_toConcurrentMap_0__T, _toConcurrentMap_0__U], typing.Callable[[_toConcurrentMap_0__T], _toConcurrentMap_0__U]]) -> Collector[_toConcurrentMap_0__T, typing.Any, java.util.concurrent.ConcurrentMap[_toConcurrentMap_0__K, _toConcurrentMap_0__U]]: ...
    _toConcurrentMap_1__T = typing.TypeVar('_toConcurrentMap_1__T')  # <T>
    _toConcurrentMap_1__K = typing.TypeVar('_toConcurrentMap_1__K')  # <K>
    _toConcurrentMap_1__U = typing.TypeVar('_toConcurrentMap_1__U')  # <U>
    @classmethod
    @typing.overload
    def toConcurrentMap(cls, function: typing.Union[java.util.function.Function[_toConcurrentMap_1__T, _toConcurrentMap_1__K], typing.Callable[[_toConcurrentMap_1__T], _toConcurrentMap_1__K]], function2: typing.Union[java.util.function.Function[_toConcurrentMap_1__T, _toConcurrentMap_1__U], typing.Callable[[_toConcurrentMap_1__T], _toConcurrentMap_1__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toConcurrentMap_1__U], typing.Callable[[], _toConcurrentMap_1__U]]) -> Collector[_toConcurrentMap_1__T, typing.Any, java.util.concurrent.ConcurrentMap[_toConcurrentMap_1__K, _toConcurrentMap_1__U]]: ...
    _toConcurrentMap_2__T = typing.TypeVar('_toConcurrentMap_2__T')  # <T>
    _toConcurrentMap_2__K = typing.TypeVar('_toConcurrentMap_2__K')  # <K>
    _toConcurrentMap_2__U = typing.TypeVar('_toConcurrentMap_2__U')  # <U>
    _toConcurrentMap_2__M = typing.TypeVar('_toConcurrentMap_2__M', bound=java.util.concurrent.ConcurrentMap)  # <M>
    @classmethod
    @typing.overload
    def toConcurrentMap(cls, function: typing.Union[java.util.function.Function[_toConcurrentMap_2__T, _toConcurrentMap_2__K], typing.Callable[[_toConcurrentMap_2__T], _toConcurrentMap_2__K]], function2: typing.Union[java.util.function.Function[_toConcurrentMap_2__T, _toConcurrentMap_2__U], typing.Callable[[_toConcurrentMap_2__T], _toConcurrentMap_2__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toConcurrentMap_2__U], typing.Callable[[], _toConcurrentMap_2__U]], supplier: typing.Union[java.util.function.Supplier[_toConcurrentMap_2__M], typing.Callable[[], _toConcurrentMap_2__M]]) -> Collector[_toConcurrentMap_2__T, typing.Any, _toConcurrentMap_2__M]: ...
    _toList__T = typing.TypeVar('_toList__T')  # <T>
    @classmethod
    def toList(cls) -> Collector[_toList__T, typing.Any, java.util.List[_toList__T]]: ...
    _toMap_0__T = typing.TypeVar('_toMap_0__T')  # <T>
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__U = typing.TypeVar('_toMap_0__U')  # <U>
    @classmethod
    @typing.overload
    def toMap(cls, function: typing.Union[java.util.function.Function[_toMap_0__T, _toMap_0__K], typing.Callable[[_toMap_0__T], _toMap_0__K]], function2: typing.Union[java.util.function.Function[_toMap_0__T, _toMap_0__U], typing.Callable[[_toMap_0__T], _toMap_0__U]]) -> Collector[_toMap_0__T, typing.Any, java.util.Map[_toMap_0__K, _toMap_0__U]]: ...
    _toMap_1__T = typing.TypeVar('_toMap_1__T')  # <T>
    _toMap_1__K = typing.TypeVar('_toMap_1__K')  # <K>
    _toMap_1__U = typing.TypeVar('_toMap_1__U')  # <U>
    @classmethod
    @typing.overload
    def toMap(cls, function: typing.Union[java.util.function.Function[_toMap_1__T, _toMap_1__K], typing.Callable[[_toMap_1__T], _toMap_1__K]], function2: typing.Union[java.util.function.Function[_toMap_1__T, _toMap_1__U], typing.Callable[[_toMap_1__T], _toMap_1__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toMap_1__U], typing.Callable[[], _toMap_1__U]]) -> Collector[_toMap_1__T, typing.Any, java.util.Map[_toMap_1__K, _toMap_1__U]]: ...
    _toMap_2__T = typing.TypeVar('_toMap_2__T')  # <T>
    _toMap_2__K = typing.TypeVar('_toMap_2__K')  # <K>
    _toMap_2__U = typing.TypeVar('_toMap_2__U')  # <U>
    _toMap_2__M = typing.TypeVar('_toMap_2__M', bound=java.util.Map)  # <M>
    @classmethod
    @typing.overload
    def toMap(cls, function: typing.Union[java.util.function.Function[_toMap_2__T, _toMap_2__K], typing.Callable[[_toMap_2__T], _toMap_2__K]], function2: typing.Union[java.util.function.Function[_toMap_2__T, _toMap_2__U], typing.Callable[[_toMap_2__T], _toMap_2__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toMap_2__U], typing.Callable[[], _toMap_2__U]], supplier: typing.Union[java.util.function.Supplier[_toMap_2__M], typing.Callable[[], _toMap_2__M]]) -> Collector[_toMap_2__T, typing.Any, _toMap_2__M]: ...
    _toSet__T = typing.TypeVar('_toSet__T')  # <T>
    @classmethod
    def toSet(cls) -> Collector[_toSet__T, typing.Any, java.util.Set[_toSet__T]]: ...
    _toUnmodifiableList__T = typing.TypeVar('_toUnmodifiableList__T')  # <T>
    @classmethod
    def toUnmodifiableList(cls) -> Collector[_toUnmodifiableList__T, typing.Any, java.util.List[_toUnmodifiableList__T]]: ...
    _toUnmodifiableMap_0__T = typing.TypeVar('_toUnmodifiableMap_0__T')  # <T>
    _toUnmodifiableMap_0__K = typing.TypeVar('_toUnmodifiableMap_0__K')  # <K>
    _toUnmodifiableMap_0__U = typing.TypeVar('_toUnmodifiableMap_0__U')  # <U>
    @classmethod
    @typing.overload
    def toUnmodifiableMap(cls, function: typing.Union[java.util.function.Function[_toUnmodifiableMap_0__T, _toUnmodifiableMap_0__K], typing.Callable[[_toUnmodifiableMap_0__T], _toUnmodifiableMap_0__K]], function2: typing.Union[java.util.function.Function[_toUnmodifiableMap_0__T, _toUnmodifiableMap_0__U], typing.Callable[[_toUnmodifiableMap_0__T], _toUnmodifiableMap_0__U]]) -> Collector[_toUnmodifiableMap_0__T, typing.Any, java.util.Map[_toUnmodifiableMap_0__K, _toUnmodifiableMap_0__U]]: ...
    _toUnmodifiableMap_1__T = typing.TypeVar('_toUnmodifiableMap_1__T')  # <T>
    _toUnmodifiableMap_1__K = typing.TypeVar('_toUnmodifiableMap_1__K')  # <K>
    _toUnmodifiableMap_1__U = typing.TypeVar('_toUnmodifiableMap_1__U')  # <U>
    @classmethod
    @typing.overload
    def toUnmodifiableMap(cls, function: typing.Union[java.util.function.Function[_toUnmodifiableMap_1__T, _toUnmodifiableMap_1__K], typing.Callable[[_toUnmodifiableMap_1__T], _toUnmodifiableMap_1__K]], function2: typing.Union[java.util.function.Function[_toUnmodifiableMap_1__T, _toUnmodifiableMap_1__U], typing.Callable[[_toUnmodifiableMap_1__T], _toUnmodifiableMap_1__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toUnmodifiableMap_1__U], typing.Callable[[], _toUnmodifiableMap_1__U]]) -> Collector[_toUnmodifiableMap_1__T, typing.Any, java.util.Map[_toUnmodifiableMap_1__K, _toUnmodifiableMap_1__U]]: ...
    _toUnmodifiableSet__T = typing.TypeVar('_toUnmodifiableSet__T')  # <T>
    @classmethod
    def toUnmodifiableSet(cls) -> Collector[_toUnmodifiableSet__T, typing.Any, java.util.Set[_toUnmodifiableSet__T]]: ...

class StreamSupport(java.lang.Object):
    """
    Java class 'java.util.stream.StreamSupport'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    @typing.overload
    def doubleStream(cls, ofDouble: java.util.Spliterator.OfDouble, boolean: bool) -> 'DoubleStream': ...
    @classmethod
    @typing.overload
    def doubleStream(cls, supplier: typing.Union[java.util.function.Supplier[java.util.Spliterator.OfDouble], typing.Callable[[], java.util.Spliterator.OfDouble]], int: int, boolean: bool) -> 'DoubleStream': ...
    @classmethod
    @typing.overload
    def intStream(cls, ofInt: java.util.Spliterator.OfInt, boolean: bool) -> 'IntStream': ...
    @classmethod
    @typing.overload
    def intStream(cls, supplier: typing.Union[java.util.function.Supplier[java.util.Spliterator.OfInt], typing.Callable[[], java.util.Spliterator.OfInt]], int: int, boolean: bool) -> 'IntStream': ...
    @classmethod
    @typing.overload
    def longStream(cls, ofLong: java.util.Spliterator.OfLong, boolean: bool) -> 'LongStream': ...
    @classmethod
    @typing.overload
    def longStream(cls, supplier: typing.Union[java.util.function.Supplier[java.util.Spliterator.OfLong], typing.Callable[[], java.util.Spliterator.OfLong]], int: int, boolean: bool) -> 'LongStream': ...
    _stream_0__T = typing.TypeVar('_stream_0__T')  # <T>
    @classmethod
    @typing.overload
    def stream(cls, spliterator: java.util.Spliterator[_stream_0__T], boolean: bool) -> 'Stream'[_stream_0__T]: ...
    _stream_1__T = typing.TypeVar('_stream_1__T')  # <T>
    @classmethod
    @typing.overload
    def stream(cls, supplier: typing.Union[java.util.function.Supplier[java.util.Spliterator[_stream_1__T]], typing.Callable[[], java.util.Spliterator[_stream_1__T]]], int: int, boolean: bool) -> 'Stream'[_stream_1__T]: ...

class DoubleStream(BaseStream[float, java.util.stream.DoubleStream]):
    """
    Java class 'java.util.stream.DoubleStream'
    
        Interfaces:
            java.util.stream.BaseStream
    
    """
    def allMatch(self, doublePredicate: java.util.function.DoublePredicate) -> bool: ...
    def anyMatch(self, doublePredicate: java.util.function.DoublePredicate) -> bool: ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> 'Stream'[float]: ...
    @classmethod
    def builder(cls) -> 'DoubleStream.Builder': ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, supplier: typing.Union[java.util.function.Supplier[_collect__R], typing.Callable[[], _collect__R]], objDoubleConsumer: typing.Union[java.util.function.ObjDoubleConsumer[_collect__R], typing.Callable[[], _collect__R]], biConsumer: typing.Union[java.util.function.BiConsumer[_collect__R, _collect__R], typing.Callable[[_collect__R], _collect__R]]) -> _collect__R: ...
    @classmethod
    def concat(cls, doubleStream: 'DoubleStream', doubleStream2: 'DoubleStream') -> 'DoubleStream': ...
    def count(self) -> int: ...
    def distinct(self) -> 'DoubleStream': ...
    def dropWhile(self, doublePredicate: java.util.function.DoublePredicate) -> 'DoubleStream': ...
    @classmethod
    def empty(cls) -> 'DoubleStream': ...
    def filter(self, doublePredicate: java.util.function.DoublePredicate) -> 'DoubleStream': ...
    def findAny(self) -> java.util.OptionalDouble: ...
    def findFirst(self) -> java.util.OptionalDouble: ...
    def flatMap(self, doubleFunction: typing.Union[java.util.function.DoubleFunction['DoubleStream'], typing.Callable[[], 'DoubleStream']]) -> 'DoubleStream': ...
    def forEach(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
    def forEachOrdered(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
    @classmethod
    def generate(cls, doubleSupplier: java.util.function.DoubleSupplier) -> 'DoubleStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, double: float, doublePredicate: java.util.function.DoublePredicate, doubleUnaryOperator: java.util.function.DoubleUnaryOperator) -> 'DoubleStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, double: float, doubleUnaryOperator: java.util.function.DoubleUnaryOperator) -> 'DoubleStream': ...
    @typing.overload
    def iterator(self) -> java.util.PrimitiveIterator.OfDouble: ...
    @typing.overload
    def iterator(self) -> java.util.Iterator: ...
    def limit(self, long: int) -> 'DoubleStream': ...
    def map(self, doubleUnaryOperator: java.util.function.DoubleUnaryOperator) -> 'DoubleStream': ...
    def mapToInt(self, doubleToIntFunction: java.util.function.DoubleToIntFunction) -> 'IntStream': ...
    def mapToLong(self, doubleToLongFunction: java.util.function.DoubleToLongFunction) -> 'LongStream': ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, doubleFunction: typing.Union[java.util.function.DoubleFunction[_mapToObj__U], typing.Callable[[], _mapToObj__U]]) -> 'Stream'[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalDouble: ...
    def min(self) -> java.util.OptionalDouble: ...
    def noneMatch(self, doublePredicate: java.util.function.DoublePredicate) -> bool: ...
    @classmethod
    @typing.overload
    def of(cls, double: float) -> 'DoubleStream': ...
    @classmethod
    @typing.overload
    def of(cls, doubleArray: typing.List[float]) -> 'DoubleStream': ...
    @typing.overload
    def parallel(self) -> 'DoubleStream': ...
    @typing.overload
    def parallel(self) -> BaseStream: ...
    def peek(self, doubleConsumer: java.util.function.DoubleConsumer) -> 'DoubleStream': ...
    @typing.overload
    def reduce(self, double: float, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> float: ...
    @typing.overload
    def reduce(self, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> java.util.OptionalDouble: ...
    @typing.overload
    def sequential(self) -> 'DoubleStream': ...
    @typing.overload
    def sequential(self) -> BaseStream: ...
    def skip(self, long: int) -> 'DoubleStream': ...
    def sorted(self) -> 'DoubleStream': ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator.OfDouble: ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator: ...
    def sum(self) -> float: ...
    def summaryStatistics(self) -> java.util.DoubleSummaryStatistics: ...
    def takeWhile(self, doublePredicate: java.util.function.DoublePredicate) -> 'DoubleStream': ...
    def toArray(self) -> typing.List[float]: ...
    class Builder(java.util.function.DoubleConsumer):
        """
        Java class 'java.util.stream.DoubleStream$Builder'
        
            Interfaces:
                java.util.function.DoubleConsumer
        
        """
        def accept(self, double: float) -> None: ...
        def add(self, double: float) -> 'DoubleStream.Builder': ...
        def build(self) -> 'DoubleStream': ...

class IntStream(BaseStream[int, java.util.stream.IntStream]):
    """
    Java class 'java.util.stream.IntStream'
    
        Interfaces:
            java.util.stream.BaseStream
    
    """
    def allMatch(self, intPredicate: java.util.function.IntPredicate) -> bool: ...
    def anyMatch(self, intPredicate: java.util.function.IntPredicate) -> bool: ...
    def asDoubleStream(self) -> DoubleStream: ...
    def asLongStream(self) -> 'LongStream': ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> 'Stream'[int]: ...
    @classmethod
    def builder(cls) -> 'IntStream.Builder': ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, supplier: typing.Union[java.util.function.Supplier[_collect__R], typing.Callable[[], _collect__R]], objIntConsumer: typing.Union[java.util.function.ObjIntConsumer[_collect__R], typing.Callable[[], _collect__R]], biConsumer: typing.Union[java.util.function.BiConsumer[_collect__R, _collect__R], typing.Callable[[_collect__R], _collect__R]]) -> _collect__R: ...
    @classmethod
    def concat(cls, intStream: 'IntStream', intStream2: 'IntStream') -> 'IntStream': ...
    def count(self) -> int: ...
    def distinct(self) -> 'IntStream': ...
    def dropWhile(self, intPredicate: java.util.function.IntPredicate) -> 'IntStream': ...
    @classmethod
    def empty(cls) -> 'IntStream': ...
    def filter(self, intPredicate: java.util.function.IntPredicate) -> 'IntStream': ...
    def findAny(self) -> java.util.OptionalInt: ...
    def findFirst(self) -> java.util.OptionalInt: ...
    def flatMap(self, intFunction: typing.Union[java.util.function.IntFunction['IntStream'], typing.Callable[[], 'IntStream']]) -> 'IntStream': ...
    def forEach(self, intConsumer: java.util.function.IntConsumer) -> None: ...
    def forEachOrdered(self, intConsumer: java.util.function.IntConsumer) -> None: ...
    @classmethod
    def generate(cls, intSupplier: java.util.function.IntSupplier) -> 'IntStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, int: int, intPredicate: java.util.function.IntPredicate, intUnaryOperator: java.util.function.IntUnaryOperator) -> 'IntStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, int: int, intUnaryOperator: java.util.function.IntUnaryOperator) -> 'IntStream': ...
    @typing.overload
    def iterator(self) -> java.util.PrimitiveIterator.OfInt: ...
    @typing.overload
    def iterator(self) -> java.util.Iterator: ...
    def limit(self, long: int) -> 'IntStream': ...
    def map(self, intUnaryOperator: java.util.function.IntUnaryOperator) -> 'IntStream': ...
    def mapToDouble(self, intToDoubleFunction: java.util.function.IntToDoubleFunction) -> DoubleStream: ...
    def mapToLong(self, intToLongFunction: java.util.function.IntToLongFunction) -> 'LongStream': ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, intFunction: typing.Union[java.util.function.IntFunction[_mapToObj__U], typing.Callable[[], _mapToObj__U]]) -> 'Stream'[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalInt: ...
    def min(self) -> java.util.OptionalInt: ...
    def noneMatch(self, intPredicate: java.util.function.IntPredicate) -> bool: ...
    @classmethod
    @typing.overload
    def of(cls, int: int) -> 'IntStream': ...
    @classmethod
    @typing.overload
    def of(cls, intArray: typing.List[int]) -> 'IntStream': ...
    @typing.overload
    def parallel(self) -> 'IntStream': ...
    @typing.overload
    def parallel(self) -> BaseStream: ...
    def peek(self, intConsumer: java.util.function.IntConsumer) -> 'IntStream': ...
    @classmethod
    def range(cls, int: int, int2: int) -> 'IntStream': ...
    @classmethod
    def rangeClosed(cls, int: int, int2: int) -> 'IntStream': ...
    @typing.overload
    def reduce(self, int: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> int: ...
    @typing.overload
    def reduce(self, intBinaryOperator: java.util.function.IntBinaryOperator) -> java.util.OptionalInt: ...
    @typing.overload
    def sequential(self) -> 'IntStream': ...
    @typing.overload
    def sequential(self) -> BaseStream: ...
    def skip(self, long: int) -> 'IntStream': ...
    def sorted(self) -> 'IntStream': ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator.OfInt: ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator: ...
    def sum(self) -> int: ...
    def summaryStatistics(self) -> java.util.IntSummaryStatistics: ...
    def takeWhile(self, intPredicate: java.util.function.IntPredicate) -> 'IntStream': ...
    def toArray(self) -> typing.List[int]: ...
    class Builder(java.util.function.IntConsumer):
        """
        Java class 'java.util.stream.IntStream$Builder'
        
            Interfaces:
                java.util.function.IntConsumer
        
        """
        def accept(self, int: int) -> None: ...
        def add(self, int: int) -> 'IntStream.Builder': ...
        def build(self) -> 'IntStream': ...

class LongStream(BaseStream[int, java.util.stream.LongStream]):
    """
    Java class 'java.util.stream.LongStream'
    
        Interfaces:
            java.util.stream.BaseStream
    
    """
    def allMatch(self, longPredicate: java.util.function.LongPredicate) -> bool: ...
    def anyMatch(self, longPredicate: java.util.function.LongPredicate) -> bool: ...
    def asDoubleStream(self) -> DoubleStream: ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> 'Stream'[int]: ...
    @classmethod
    def builder(cls) -> 'LongStream.Builder': ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, supplier: typing.Union[java.util.function.Supplier[_collect__R], typing.Callable[[], _collect__R]], objLongConsumer: typing.Union[java.util.function.ObjLongConsumer[_collect__R], typing.Callable[[], _collect__R]], biConsumer: typing.Union[java.util.function.BiConsumer[_collect__R, _collect__R], typing.Callable[[_collect__R], _collect__R]]) -> _collect__R: ...
    @classmethod
    def concat(cls, longStream: 'LongStream', longStream2: 'LongStream') -> 'LongStream': ...
    def count(self) -> int: ...
    def distinct(self) -> 'LongStream': ...
    def dropWhile(self, longPredicate: java.util.function.LongPredicate) -> 'LongStream': ...
    @classmethod
    def empty(cls) -> 'LongStream': ...
    def filter(self, longPredicate: java.util.function.LongPredicate) -> 'LongStream': ...
    def findAny(self) -> java.util.OptionalLong: ...
    def findFirst(self) -> java.util.OptionalLong: ...
    def flatMap(self, longFunction: typing.Union[java.util.function.LongFunction['LongStream'], typing.Callable[[], 'LongStream']]) -> 'LongStream': ...
    def forEach(self, longConsumer: java.util.function.LongConsumer) -> None: ...
    def forEachOrdered(self, longConsumer: java.util.function.LongConsumer) -> None: ...
    @classmethod
    def generate(cls, longSupplier: java.util.function.LongSupplier) -> 'LongStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, long: int, longPredicate: java.util.function.LongPredicate, longUnaryOperator: java.util.function.LongUnaryOperator) -> 'LongStream': ...
    @classmethod
    @typing.overload
    def iterate(cls, long: int, longUnaryOperator: java.util.function.LongUnaryOperator) -> 'LongStream': ...
    @typing.overload
    def iterator(self) -> java.util.PrimitiveIterator.OfLong: ...
    @typing.overload
    def iterator(self) -> java.util.Iterator: ...
    def limit(self, long: int) -> 'LongStream': ...
    def map(self, longUnaryOperator: java.util.function.LongUnaryOperator) -> 'LongStream': ...
    def mapToDouble(self, longToDoubleFunction: java.util.function.LongToDoubleFunction) -> DoubleStream: ...
    def mapToInt(self, longToIntFunction: java.util.function.LongToIntFunction) -> IntStream: ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, longFunction: typing.Union[java.util.function.LongFunction[_mapToObj__U], typing.Callable[[], _mapToObj__U]]) -> 'Stream'[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalLong: ...
    def min(self) -> java.util.OptionalLong: ...
    def noneMatch(self, longPredicate: java.util.function.LongPredicate) -> bool: ...
    @classmethod
    @typing.overload
    def of(cls, long: int) -> 'LongStream': ...
    @classmethod
    @typing.overload
    def of(cls, longArray: typing.List[int]) -> 'LongStream': ...
    @typing.overload
    def parallel(self) -> 'LongStream': ...
    @typing.overload
    def parallel(self) -> BaseStream: ...
    def peek(self, longConsumer: java.util.function.LongConsumer) -> 'LongStream': ...
    @classmethod
    def range(cls, long: int, long2: int) -> 'LongStream': ...
    @classmethod
    def rangeClosed(cls, long: int, long2: int) -> 'LongStream': ...
    @typing.overload
    def reduce(self, longBinaryOperator: java.util.function.LongBinaryOperator) -> java.util.OptionalLong: ...
    @typing.overload
    def reduce(self, long: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> int: ...
    @typing.overload
    def sequential(self) -> 'LongStream': ...
    @typing.overload
    def sequential(self) -> BaseStream: ...
    def skip(self, long: int) -> 'LongStream': ...
    def sorted(self) -> 'LongStream': ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator.OfLong: ...
    @typing.overload
    def spliterator(self) -> java.util.Spliterator: ...
    def sum(self) -> int: ...
    def summaryStatistics(self) -> java.util.LongSummaryStatistics: ...
    def takeWhile(self, longPredicate: java.util.function.LongPredicate) -> 'LongStream': ...
    def toArray(self) -> typing.List[int]: ...
    class Builder(java.util.function.LongConsumer):
        """
        Java class 'java.util.stream.LongStream$Builder'
        
            Interfaces:
                java.util.function.LongConsumer
        
        """
        def accept(self, long: int) -> None: ...
        def add(self, long: int) -> 'LongStream.Builder': ...
        def build(self) -> 'LongStream': ...

_Stream__Builder__T = typing.TypeVar('_Stream__Builder__T')  # <T>
_Stream__T = typing.TypeVar('_Stream__T')  # <T>
class Stream(BaseStream[_Stream__T, java.util.stream.Stream[_Stream__T]], typing.Generic[_Stream__T]):
    """
    Java class 'java.util.stream.Stream'
    
        Interfaces:
            java.util.stream.BaseStream
    
    """
    def allMatch(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> bool: ...
    def anyMatch(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> bool: ...
    _builder__T = typing.TypeVar('_builder__T')  # <T>
    @classmethod
    def builder(cls) -> 'Stream.Builder'[_builder__T]: ...
    _collect_0__R = typing.TypeVar('_collect_0__R')  # <R>
    @typing.overload
    def collect(self, supplier: typing.Union[java.util.function.Supplier[_collect_0__R], typing.Callable[[], _collect_0__R]], biConsumer: typing.Union[java.util.function.BiConsumer[_collect_0__R, _Stream__T], typing.Callable[[_collect_0__R], _Stream__T]], biConsumer2: typing.Union[java.util.function.BiConsumer[_collect_0__R, _collect_0__R], typing.Callable[[_collect_0__R], _collect_0__R]]) -> _collect_0__R: ...
    _collect_1__R = typing.TypeVar('_collect_1__R')  # <R>
    _collect_1__A = typing.TypeVar('_collect_1__A')  # <A>
    @typing.overload
    def collect(self, collector: Collector[_Stream__T, _collect_1__A, _collect_1__R]) -> _collect_1__R: ...
    _concat__T = typing.TypeVar('_concat__T')  # <T>
    @classmethod
    def concat(cls, stream: 'Stream'[_concat__T], stream2: 'Stream'[_concat__T]) -> 'Stream'[_concat__T]: ...
    def count(self) -> int: ...
    def distinct(self) -> 'Stream'[_Stream__T]: ...
    def dropWhile(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> 'Stream'[_Stream__T]: ...
    _empty__T = typing.TypeVar('_empty__T')  # <T>
    @classmethod
    def empty(cls) -> 'Stream'[_empty__T]: ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> 'Stream'[_Stream__T]: ...
    def findAny(self) -> java.util.Optional[_Stream__T]: ...
    def findFirst(self) -> java.util.Optional[_Stream__T]: ...
    _flatMap__R = typing.TypeVar('_flatMap__R')  # <R>
    def flatMap(self, function: typing.Union[java.util.function.Function[_Stream__T, 'Stream'[_flatMap__R]], typing.Callable[[_Stream__T], 'Stream'[_flatMap__R]]]) -> 'Stream'[_flatMap__R]: ...
    def flatMapToDouble(self, function: typing.Union[java.util.function.Function[_Stream__T, DoubleStream], typing.Callable[[_Stream__T], DoubleStream]]) -> DoubleStream: ...
    def flatMapToInt(self, function: typing.Union[java.util.function.Function[_Stream__T, IntStream], typing.Callable[[_Stream__T], IntStream]]) -> IntStream: ...
    def flatMapToLong(self, function: typing.Union[java.util.function.Function[_Stream__T, LongStream], typing.Callable[[_Stream__T], LongStream]]) -> LongStream: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Stream__T], typing.Callable[[], _Stream__T]]) -> None: ...
    def forEachOrdered(self, consumer: typing.Union[java.util.function.Consumer[_Stream__T], typing.Callable[[], _Stream__T]]) -> None: ...
    _generate__T = typing.TypeVar('_generate__T')  # <T>
    @classmethod
    def generate(cls, supplier: typing.Union[java.util.function.Supplier[_generate__T], typing.Callable[[], _generate__T]]) -> 'Stream'[_generate__T]: ...
    _iterate_0__T = typing.TypeVar('_iterate_0__T')  # <T>
    @classmethod
    @typing.overload
    def iterate(cls, t: _iterate_0__T, predicate: typing.Union[java.util.function.Predicate[_iterate_0__T], typing.Callable[[], _iterate_0__T]], unaryOperator: typing.Union[java.util.function.UnaryOperator[_iterate_0__T], typing.Callable[[], _iterate_0__T]]) -> 'Stream'[_iterate_0__T]: ...
    _iterate_1__T = typing.TypeVar('_iterate_1__T')  # <T>
    @classmethod
    @typing.overload
    def iterate(cls, t: _iterate_1__T, unaryOperator: typing.Union[java.util.function.UnaryOperator[_iterate_1__T], typing.Callable[[], _iterate_1__T]]) -> 'Stream'[_iterate_1__T]: ...
    def limit(self, long: int) -> 'Stream'[_Stream__T]: ...
    _map__R = typing.TypeVar('_map__R')  # <R>
    def map(self, function: typing.Union[java.util.function.Function[_Stream__T, _map__R], typing.Callable[[_Stream__T], _map__R]]) -> 'Stream'[_map__R]: ...
    def mapToDouble(self, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_Stream__T], typing.Callable[[], _Stream__T]]) -> DoubleStream: ...
    def mapToInt(self, toIntFunction: typing.Union[java.util.function.ToIntFunction[_Stream__T], typing.Callable[[], _Stream__T]]) -> IntStream: ...
    def mapToLong(self, toLongFunction: typing.Union[java.util.function.ToLongFunction[_Stream__T], typing.Callable[[], _Stream__T]]) -> LongStream: ...
    def max(self, comparator: typing.Union[java.util.Comparator[_Stream__T], typing.Callable[[], _Stream__T]]) -> java.util.Optional[_Stream__T]: ...
    def min(self, comparator: typing.Union[java.util.Comparator[_Stream__T], typing.Callable[[], _Stream__T]]) -> java.util.Optional[_Stream__T]: ...
    def noneMatch(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> bool: ...
    _of_0__T = typing.TypeVar('_of_0__T')  # <T>
    @classmethod
    @typing.overload
    def of(cls, t: _of_0__T) -> 'Stream'[_of_0__T]: ...
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    @classmethod
    @typing.overload
    def of(cls, tArray: typing.List[_of_1__T]) -> 'Stream'[_of_1__T]: ...
    _ofNullable__T = typing.TypeVar('_ofNullable__T')  # <T>
    @classmethod
    def ofNullable(cls, t: _ofNullable__T) -> 'Stream'[_ofNullable__T]: ...
    def peek(self, consumer: typing.Union[java.util.function.Consumer[_Stream__T], typing.Callable[[], _Stream__T]]) -> 'Stream'[_Stream__T]: ...
    _reduce_0__U = typing.TypeVar('_reduce_0__U')  # <U>
    @typing.overload
    def reduce(self, u: _reduce_0__U, biFunction: typing.Union[java.util.function.BiFunction[_reduce_0__U, _Stream__T, _reduce_0__U], typing.Callable[[_reduce_0__U, _Stream__T], _reduce_0__U]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_reduce_0__U], typing.Callable[[], _reduce_0__U]]) -> _reduce_0__U: ...
    @typing.overload
    def reduce(self, t: _Stream__T, binaryOperator: typing.Union[java.util.function.BinaryOperator[_Stream__T], typing.Callable[[], _Stream__T]]) -> _Stream__T: ...
    @typing.overload
    def reduce(self, binaryOperator: typing.Union[java.util.function.BinaryOperator[_Stream__T], typing.Callable[[], _Stream__T]]) -> java.util.Optional[_Stream__T]: ...
    def skip(self, long: int) -> 'Stream'[_Stream__T]: ...
    @typing.overload
    def sorted(self) -> 'Stream'[_Stream__T]: ...
    @typing.overload
    def sorted(self, comparator: typing.Union[java.util.Comparator[_Stream__T], typing.Callable[[], _Stream__T]]) -> 'Stream'[_Stream__T]: ...
    def takeWhile(self, predicate: typing.Union[java.util.function.Predicate[_Stream__T], typing.Callable[[], _Stream__T]]) -> 'Stream'[_Stream__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_1__A = typing.TypeVar('_toArray_1__A')  # <A>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_1__A]], typing.Callable[[], typing.List[_toArray_1__A]]]) -> typing.List[_toArray_1__A]: ...
    class Builder(java.util.function.Consumer[_Stream__Builder__T], typing.Generic[_Stream__Builder__T]):
        """
        Java class 'java.util.stream.Stream$Builder'
        
            Interfaces:
                java.util.function.Consumer
        
        """
        def accept(self, t: _Stream__Builder__T) -> None: ...
        def add(self, t: _Stream__Builder__T) -> 'Stream.Builder'[_Stream__Builder__T]: ...
        def build(self) -> 'Stream'[_Stream__Builder__T]: ...

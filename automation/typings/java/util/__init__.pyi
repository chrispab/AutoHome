import java
import java.io
import java.lang
import java.math
import java.nio
import java.nio.channels
import java.nio.charset
import java.nio.file
import java.security
import java.time
import java.util.function
import java.util.regex
import java.util.stream
import typing


class Arrays(java.lang.Object):
    """
    Java class 'java.util.Arrays'
    
        Extends:
            java.lang.Object
    
    """
    _asList__T = typing.TypeVar('_asList__T')  # <T>
    @classmethod
    def asList(cls, tArray: typing.List[_asList__T]) -> 'List'[_asList__T]: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, byteArray: typing.List[int], byte2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, byteArray: typing.List[int], int: int, int2: int, byte2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, charArray: typing.List[str], char2: str) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, charArray: typing.List[str], int: int, int2: int, char2: str) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, doubleArray: typing.List[float], double2: float) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, doubleArray: typing.List[float], int: int, int2: int, double2: float) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, floatArray: typing.List[float], float2: float) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, floatArray: typing.List[float], int: int, int2: int, float2: float) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, intArray: typing.List[int], int2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, intArray: typing.List[int], int2: int, int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, objectArray: typing.List[typing.Any], int: int, int2: int, object2: typing.Any) -> int: ...
    _binarySearch_11__T = typing.TypeVar('_binarySearch_11__T')  # <T>
    @classmethod
    @typing.overload
    def binarySearch(cls, tArray: typing.List[_binarySearch_11__T], int: int, int2: int, t2: _binarySearch_11__T, comparator: typing.Union['Comparator'[_binarySearch_11__T], typing.Callable[[], _binarySearch_11__T]]) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, objectArray: typing.List[typing.Any], object2: typing.Any) -> int: ...
    _binarySearch_13__T = typing.TypeVar('_binarySearch_13__T')  # <T>
    @classmethod
    @typing.overload
    def binarySearch(cls, tArray: typing.List[_binarySearch_13__T], t2: _binarySearch_13__T, comparator: typing.Union['Comparator'[_binarySearch_13__T], typing.Callable[[], _binarySearch_13__T]]) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, longArray: typing.List[int], int: int, int2: int, long2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, longArray: typing.List[int], long2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, shortArray: typing.List[int], int: int, int2: int, short2: int) -> int: ...
    @classmethod
    @typing.overload
    def binarySearch(cls, shortArray: typing.List[int], short2: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, booleanArray: typing.List[bool], booleanArray2: typing.List[bool]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, booleanArray: typing.List[bool], int: int, int2: int, booleanArray2: typing.List[bool], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, byteArray: typing.List[int], int: int, int2: int, byteArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, charArray: typing.List[str], charArray2: typing.List[str]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, charArray: typing.List[str], int: int, int2: int, charArray2: typing.List[str], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, doubleArray: typing.List[float], int: int, int2: int, doubleArray2: typing.List[float], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, floatArray: typing.List[float], floatArray2: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, floatArray: typing.List[float], int: int, int2: int, floatArray2: typing.List[float], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, intArray: typing.List[int], int2: int, int3: int, intArray2: typing.List[int], int5: int, int6: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, intArray: typing.List[int], intArray2: typing.List[int]) -> int: ...
    _compare_12__T = typing.TypeVar('_compare_12__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @typing.overload
    def compare(cls, tArray: typing.List[_compare_12__T], int: int, int2: int, tArray2: typing.List[_compare_12__T], int3: int, int4: int) -> int: ...
    _compare_13__T = typing.TypeVar('_compare_13__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @typing.overload
    def compare(cls, tArray: typing.List[_compare_13__T], tArray2: typing.List[_compare_13__T]) -> int: ...
    _compare_14__T = typing.TypeVar('_compare_14__T')  # <T>
    @classmethod
    @typing.overload
    def compare(cls, tArray: typing.List[_compare_14__T], int: int, int2: int, tArray2: typing.List[_compare_14__T], int3: int, int4: int, comparator: typing.Union['Comparator'[_compare_14__T], typing.Callable[[], _compare_14__T]]) -> int: ...
    _compare_15__T = typing.TypeVar('_compare_15__T')  # <T>
    @classmethod
    @typing.overload
    def compare(cls, tArray: typing.List[_compare_15__T], tArray2: typing.List[_compare_15__T], comparator: typing.Union['Comparator'[_compare_15__T], typing.Callable[[], _compare_15__T]]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, longArray: typing.List[int], int: int, int2: int, longArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, longArray: typing.List[int], longArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, shortArray: typing.List[int], int: int, int2: int, shortArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compare(cls, shortArray: typing.List[int], shortArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, byteArray: typing.List[int], int: int, int2: int, byteArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, intArray: typing.List[int], int2: int, int3: int, intArray2: typing.List[int], int5: int, int6: int) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, intArray: typing.List[int], intArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, longArray: typing.List[int], int: int, int2: int, longArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, longArray: typing.List[int], longArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, shortArray: typing.List[int], int: int, int2: int, shortArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def compareUnsigned(cls, shortArray: typing.List[int], shortArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def copyOf(cls, booleanArray: typing.List[bool], int: int) -> typing.List[bool]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, byteArray: typing.List[int], int: int) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, charArray: typing.List[str], int: int) -> typing.List[str]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, doubleArray: typing.List[float], int: int) -> typing.List[float]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, floatArray: typing.List[float], int: int) -> typing.List[float]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, intArray: typing.List[int], int2: int) -> typing.List[int]: ...
    _copyOf_6__T = typing.TypeVar('_copyOf_6__T')  # <T>
    @classmethod
    @typing.overload
    def copyOf(cls, tArray: typing.List[_copyOf_6__T], int: int) -> typing.List[_copyOf_6__T]: ...
    _copyOf_7__T = typing.TypeVar('_copyOf_7__T')  # <T>
    _copyOf_7__U = typing.TypeVar('_copyOf_7__U')  # <U>
    @classmethod
    @typing.overload
    def copyOf(cls, uArray: typing.List[_copyOf_7__U], int: int, class_: typing.Type[typing.List[_copyOf_7__T]]) -> typing.List[_copyOf_7__T]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, longArray: typing.List[int], int: int) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def copyOf(cls, shortArray: typing.List[int], int: int) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, booleanArray: typing.List[bool], int: int, int2: int) -> typing.List[bool]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, byteArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, charArray: typing.List[str], int: int, int2: int) -> typing.List[str]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, doubleArray: typing.List[float], int: int, int2: int) -> typing.List[float]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, floatArray: typing.List[float], int: int, int2: int) -> typing.List[float]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, intArray: typing.List[int], int2: int, int3: int) -> typing.List[int]: ...
    _copyOfRange_6__T = typing.TypeVar('_copyOfRange_6__T')  # <T>
    @classmethod
    @typing.overload
    def copyOfRange(cls, tArray: typing.List[_copyOfRange_6__T], int: int, int2: int) -> typing.List[_copyOfRange_6__T]: ...
    _copyOfRange_7__T = typing.TypeVar('_copyOfRange_7__T')  # <T>
    _copyOfRange_7__U = typing.TypeVar('_copyOfRange_7__U')  # <U>
    @classmethod
    @typing.overload
    def copyOfRange(cls, uArray: typing.List[_copyOfRange_7__U], int: int, int2: int, class_: typing.Type[typing.List[_copyOfRange_7__T]]) -> typing.List[_copyOfRange_7__T]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, longArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def copyOfRange(cls, shortArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @classmethod
    def deepEquals(cls, objectArray: typing.List[typing.Any], objectArray2: typing.List[typing.Any]) -> bool: ...
    @classmethod
    def deepHashCode(cls, objectArray: typing.List[typing.Any]) -> int: ...
    @classmethod
    def deepToString(cls, objectArray: typing.List[typing.Any]) -> java.lang.String: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, booleanArray: typing.List[bool], booleanArray2: typing.List[bool]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, booleanArray: typing.List[bool], int: int, int2: int, booleanArray2: typing.List[bool], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, byteArray: typing.List[int], byteArray2: typing.List[int]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, byteArray: typing.List[int], int: int, int2: int, byteArray2: typing.List[int], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, charArray: typing.List[str], charArray2: typing.List[str]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, charArray: typing.List[str], int: int, int2: int, charArray2: typing.List[str], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, doubleArray: typing.List[float], int: int, int2: int, doubleArray2: typing.List[float], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, floatArray: typing.List[float], floatArray2: typing.List[float]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, floatArray: typing.List[float], int: int, int2: int, floatArray2: typing.List[float], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, intArray: typing.List[int], int2: int, int3: int, intArray2: typing.List[int], int5: int, int6: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, intArray: typing.List[int], intArray2: typing.List[int]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, objectArray: typing.List[typing.Any], int: int, int2: int, objectArray2: typing.List[typing.Any], int3: int, int4: int) -> bool: ...
    _equals_14__T = typing.TypeVar('_equals_14__T')  # <T>
    @classmethod
    @typing.overload
    def equals(cls, tArray: typing.List[_equals_14__T], int: int, int2: int, tArray2: typing.List[_equals_14__T], int3: int, int4: int, comparator: typing.Union['Comparator'[_equals_14__T], typing.Callable[[], _equals_14__T]]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, objectArray: typing.List[typing.Any], objectArray2: typing.List[typing.Any]) -> bool: ...
    _equals_16__T = typing.TypeVar('_equals_16__T')  # <T>
    @classmethod
    @typing.overload
    def equals(cls, tArray: typing.List[_equals_16__T], tArray2: typing.List[_equals_16__T], comparator: typing.Union['Comparator'[_equals_16__T], typing.Callable[[], _equals_16__T]]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, longArray: typing.List[int], int: int, int2: int, longArray2: typing.List[int], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, longArray: typing.List[int], longArray2: typing.List[int]) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, shortArray: typing.List[int], int: int, int2: int, shortArray2: typing.List[int], int3: int, int4: int) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, shortArray: typing.List[int], shortArray2: typing.List[int]) -> bool: ...
    @classmethod
    @typing.overload
    def fill(cls, booleanArray: typing.List[bool], boolean2: bool) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, booleanArray: typing.List[bool], int: int, int2: int, boolean2: bool) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, byteArray: typing.List[int], byte2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, byteArray: typing.List[int], int: int, int2: int, byte2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, charArray: typing.List[str], char2: str) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, charArray: typing.List[str], int: int, int2: int, char2: str) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, doubleArray: typing.List[float], double2: float) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, doubleArray: typing.List[float], int: int, int2: int, double2: float) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, floatArray: typing.List[float], float2: float) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, floatArray: typing.List[float], int: int, int2: int, float2: float) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, intArray: typing.List[int], int2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, intArray: typing.List[int], int2: int, int3: int, int4: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, objectArray: typing.List[typing.Any], int: int, int2: int, object2: typing.Any) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, objectArray: typing.List[typing.Any], object2: typing.Any) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, longArray: typing.List[int], int: int, int2: int, long2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, longArray: typing.List[int], long2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, shortArray: typing.List[int], int: int, int2: int, short2: int) -> None: ...
    @classmethod
    @typing.overload
    def fill(cls, shortArray: typing.List[int], short2: int) -> None: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, booleanArray: typing.List[bool]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, byteArray: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, charArray: typing.List[str]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, doubleArray: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, floatArray: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, intArray: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, objectArray: typing.List[typing.Any]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, longArray: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, shortArray: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, booleanArray: typing.List[bool], booleanArray2: typing.List[bool]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, booleanArray: typing.List[bool], int: int, int2: int, booleanArray2: typing.List[bool], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, byteArray: typing.List[int], int: int, int2: int, byteArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, charArray: typing.List[str], charArray2: typing.List[str]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, charArray: typing.List[str], int: int, int2: int, charArray2: typing.List[str], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, doubleArray: typing.List[float], int: int, int2: int, doubleArray2: typing.List[float], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, floatArray: typing.List[float], floatArray2: typing.List[float]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, floatArray: typing.List[float], int: int, int2: int, floatArray2: typing.List[float], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, intArray: typing.List[int], int2: int, int3: int, intArray2: typing.List[int], int5: int, int6: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, intArray: typing.List[int], intArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, objectArray: typing.List[typing.Any], int: int, int2: int, objectArray2: typing.List[typing.Any], int3: int, int4: int) -> int: ...
    _mismatch_13__T = typing.TypeVar('_mismatch_13__T')  # <T>
    @classmethod
    @typing.overload
    def mismatch(cls, tArray: typing.List[_mismatch_13__T], int: int, int2: int, tArray2: typing.List[_mismatch_13__T], int3: int, int4: int, comparator: typing.Union['Comparator'[_mismatch_13__T], typing.Callable[[], _mismatch_13__T]]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, objectArray: typing.List[typing.Any], objectArray2: typing.List[typing.Any]) -> int: ...
    _mismatch_15__T = typing.TypeVar('_mismatch_15__T')  # <T>
    @classmethod
    @typing.overload
    def mismatch(cls, tArray: typing.List[_mismatch_15__T], tArray2: typing.List[_mismatch_15__T], comparator: typing.Union['Comparator'[_mismatch_15__T], typing.Callable[[], _mismatch_15__T]]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, longArray: typing.List[int], int: int, int2: int, longArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, longArray: typing.List[int], longArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, shortArray: typing.List[int], int: int, int2: int, shortArray2: typing.List[int], int3: int, int4: int) -> int: ...
    @classmethod
    @typing.overload
    def mismatch(cls, shortArray: typing.List[int], shortArray2: typing.List[int]) -> int: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, doubleArray: typing.List[float], int: int, int2: int, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, doubleArray: typing.List[float], doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, intArray: typing.List[int], int2: int, int3: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, intArray: typing.List[int], intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    _parallelPrefix_4__T = typing.TypeVar('_parallelPrefix_4__T')  # <T>
    @classmethod
    @typing.overload
    def parallelPrefix(cls, tArray: typing.List[_parallelPrefix_4__T], int: int, int2: int, binaryOperator: typing.Union[java.util.function.BinaryOperator[_parallelPrefix_4__T], typing.Callable[[], _parallelPrefix_4__T]]) -> None: ...
    _parallelPrefix_5__T = typing.TypeVar('_parallelPrefix_5__T')  # <T>
    @classmethod
    @typing.overload
    def parallelPrefix(cls, tArray: typing.List[_parallelPrefix_5__T], binaryOperator: typing.Union[java.util.function.BinaryOperator[_parallelPrefix_5__T], typing.Callable[[], _parallelPrefix_5__T]]) -> None: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, longArray: typing.List[int], int: int, int2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @typing.overload
    def parallelPrefix(cls, longArray: typing.List[int], longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @typing.overload
    def parallelSetAll(cls, doubleArray: typing.List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @typing.overload
    def parallelSetAll(cls, intArray: typing.List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _parallelSetAll_2__T = typing.TypeVar('_parallelSetAll_2__T')  # <T>
    @classmethod
    @typing.overload
    def parallelSetAll(cls, tArray: typing.List[_parallelSetAll_2__T], intFunction: typing.Union[java.util.function.IntFunction[_parallelSetAll_2__T], typing.Callable[[], _parallelSetAll_2__T]]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSetAll(cls, longArray: typing.List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, byteArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, charArray: typing.List[str]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, doubleArray: typing.List[float]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, doubleArray: typing.List[float], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, floatArray: typing.List[float]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, floatArray: typing.List[float], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, intArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, intArray: typing.List[int], int2: int, int3: int) -> None: ...
    _parallelSort_10__T = typing.TypeVar('_parallelSort_10__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @typing.overload
    def parallelSort(cls, tArray: typing.List[_parallelSort_10__T]) -> None: ...
    _parallelSort_11__T = typing.TypeVar('_parallelSort_11__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @typing.overload
    def parallelSort(cls, tArray: typing.List[_parallelSort_11__T], int: int, int2: int) -> None: ...
    _parallelSort_12__T = typing.TypeVar('_parallelSort_12__T')  # <T>
    @classmethod
    @typing.overload
    def parallelSort(cls, tArray: typing.List[_parallelSort_12__T], int: int, int2: int, comparator: typing.Union['Comparator'[_parallelSort_12__T], typing.Callable[[], _parallelSort_12__T]]) -> None: ...
    _parallelSort_13__T = typing.TypeVar('_parallelSort_13__T')  # <T>
    @classmethod
    @typing.overload
    def parallelSort(cls, tArray: typing.List[_parallelSort_13__T], comparator: typing.Union['Comparator'[_parallelSort_13__T], typing.Callable[[], _parallelSort_13__T]]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, longArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, longArray: typing.List[int], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, shortArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def parallelSort(cls, shortArray: typing.List[int], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def setAll(cls, doubleArray: typing.List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @typing.overload
    def setAll(cls, intArray: typing.List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _setAll_2__T = typing.TypeVar('_setAll_2__T')  # <T>
    @classmethod
    @typing.overload
    def setAll(cls, tArray: typing.List[_setAll_2__T], intFunction: typing.Union[java.util.function.IntFunction[_setAll_2__T], typing.Callable[[], _setAll_2__T]]) -> None: ...
    @classmethod
    @typing.overload
    def setAll(cls, longArray: typing.List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, byteArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, charArray: typing.List[str]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, charArray: typing.List[str], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, doubleArray: typing.List[float]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, doubleArray: typing.List[float], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, floatArray: typing.List[float]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, floatArray: typing.List[float], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, intArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, intArray: typing.List[int], int2: int, int3: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, objectArray: typing.List[typing.Any]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, objectArray: typing.List[typing.Any], int: int, int2: int) -> None: ...
    _sort_12__T = typing.TypeVar('_sort_12__T')  # <T>
    @classmethod
    @typing.overload
    def sort(cls, tArray: typing.List[_sort_12__T], int: int, int2: int, comparator: typing.Union['Comparator'[_sort_12__T], typing.Callable[[], _sort_12__T]]) -> None: ...
    _sort_13__T = typing.TypeVar('_sort_13__T')  # <T>
    @classmethod
    @typing.overload
    def sort(cls, tArray: typing.List[_sort_13__T], comparator: typing.Union['Comparator'[_sort_13__T], typing.Callable[[], _sort_13__T]]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, longArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, longArray: typing.List[int], int: int, int2: int) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, shortArray: typing.List[int]) -> None: ...
    @classmethod
    @typing.overload
    def sort(cls, shortArray: typing.List[int], int: int, int2: int) -> None: ...
    _spliterator_0__T = typing.TypeVar('_spliterator_0__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, tArray: typing.List[_spliterator_0__T]) -> 'Spliterator'[_spliterator_0__T]: ...
    _spliterator_1__T = typing.TypeVar('_spliterator_1__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, tArray: typing.List[_spliterator_1__T], int: int, int2: int) -> 'Spliterator'[_spliterator_1__T]: ...
    @classmethod
    @typing.overload
    def spliterator(cls, doubleArray: typing.List[float]) -> 'Spliterator.OfDouble': ...
    @classmethod
    @typing.overload
    def spliterator(cls, doubleArray: typing.List[float], int: int, int2: int) -> 'Spliterator.OfDouble': ...
    @classmethod
    @typing.overload
    def spliterator(cls, intArray: typing.List[int]) -> 'Spliterator.OfInt': ...
    @classmethod
    @typing.overload
    def spliterator(cls, intArray: typing.List[int], int2: int, int3: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @typing.overload
    def spliterator(cls, longArray: typing.List[int]) -> 'Spliterator.OfLong': ...
    @classmethod
    @typing.overload
    def spliterator(cls, longArray: typing.List[int], int: int, int2: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @typing.overload
    def stream(cls, doubleArray: typing.List[float]) -> java.util.stream.DoubleStream: ...
    @classmethod
    @typing.overload
    def stream(cls, doubleArray: typing.List[float], int: int, int2: int) -> java.util.stream.DoubleStream: ...
    @classmethod
    @typing.overload
    def stream(cls, intArray: typing.List[int]) -> java.util.stream.IntStream: ...
    @classmethod
    @typing.overload
    def stream(cls, intArray: typing.List[int], int2: int, int3: int) -> java.util.stream.IntStream: ...
    @classmethod
    @typing.overload
    def stream(cls, longArray: typing.List[int]) -> java.util.stream.LongStream: ...
    @classmethod
    @typing.overload
    def stream(cls, longArray: typing.List[int], int: int, int2: int) -> java.util.stream.LongStream: ...
    _stream_6__T = typing.TypeVar('_stream_6__T')  # <T>
    @classmethod
    @typing.overload
    def stream(cls, tArray: typing.List[_stream_6__T]) -> java.util.stream.Stream[_stream_6__T]: ...
    _stream_7__T = typing.TypeVar('_stream_7__T')  # <T>
    @classmethod
    @typing.overload
    def stream(cls, tArray: typing.List[_stream_7__T], int: int, int2: int) -> java.util.stream.Stream[_stream_7__T]: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, booleanArray: typing.List[bool]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, byteArray: typing.List[int]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, charArray: typing.List[str]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, doubleArray: typing.List[float]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, floatArray: typing.List[float]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, intArray: typing.List[int]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, objectArray: typing.List[typing.Any]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, longArray: typing.List[int]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, shortArray: typing.List[int]) -> java.lang.String: ...

class Base64(java.lang.Object):
    """
    Java class 'java.util.Base64'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def getDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    def getMimeDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    @typing.overload
    def getMimeEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    @typing.overload
    def getMimeEncoder(cls, int: int, byteArray: typing.List[int]) -> 'Base64.Encoder': ...
    @classmethod
    def getUrlDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getUrlEncoder(cls) -> 'Base64.Encoder': ...
    class Decoder(java.lang.Object):
        """
        Java class 'java.util.Base64$Decoder'
        
            Extends:
                java.lang.Object
        
        """
        @typing.overload
        def decode(self, byteArray: typing.List[int]) -> typing.List[int]: ...
        @typing.overload
        def decode(self, string: java.lang.String) -> typing.List[int]: ...
        @typing.overload
        def decode(self, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
        @typing.overload
        def decode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def wrap(self, inputStream: java.io.InputStream) -> java.io.InputStream: ...
    class Encoder(java.lang.Object):
        """
        Java class 'java.util.Base64$Encoder'
        
            Extends:
                java.lang.Object
        
        """
        @typing.overload
        def encode(self, byteArray: typing.List[int]) -> typing.List[int]: ...
        @typing.overload
        def encode(self, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
        @typing.overload
        def encode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def encodeToString(self, byteArray: typing.List[int]) -> java.lang.String: ...
        def withoutPadding(self) -> 'Base64.Encoder': ...
        def wrap(self, outputStream: java.io.OutputStream) -> java.io.OutputStream: ...

class BitSet(java.lang.Cloneable, java.io.Serializable):
    """
    Java class 'java.util.BitSet'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * BitSet(int)
        * BitSet()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def andNot(self, bitSet: 'BitSet') -> None: ...
    def cardinality(self) -> int: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, int: int) -> None: ...
    @typing.overload
    def clear(self, int: int, int2: int) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self, int: int) -> None: ...
    @typing.overload
    def flip(self, int: int, int2: int) -> None: ...
    @typing.overload
    def get(self, int: int) -> bool: ...
    @typing.overload
    def get(self, int: int, int2: int) -> 'BitSet': ...
    def hashCode(self) -> int: ...
    def intersects(self, bitSet: 'BitSet') -> bool: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def nextClearBit(self, int: int) -> int: ...
    def nextSetBit(self, int: int) -> int: ...
    def previousClearBit(self, int: int) -> int: ...
    def previousSetBit(self, int: int) -> int: ...
    @typing.overload
    def set(self, int: int) -> None: ...
    @typing.overload
    def set(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, boolean: bool) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toByteArray(self) -> typing.List[int]: ...
    def toLongArray(self) -> typing.List[int]: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def valueOf(cls, byteArray: typing.List[int]) -> 'BitSet': ...
    @classmethod
    @typing.overload
    def valueOf(cls, byteBuffer: java.nio.ByteBuffer) -> 'BitSet': ...
    @classmethod
    @typing.overload
    def valueOf(cls, longBuffer: java.nio.LongBuffer) -> 'BitSet': ...
    @classmethod
    @typing.overload
    def valueOf(cls, longArray: typing.List[int]) -> 'BitSet': ...
    def xor(self, bitSet: 'BitSet') -> None: ...

class Calendar(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable[java.util.Calendar]):
    """
    Java class 'java.util.Calendar'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Cloneable,
            java.lang.Comparable
    
      Attributes:
        ERA (int): final static field
        YEAR (int): final static field
        MONTH (int): final static field
        WEEK_OF_YEAR (int): final static field
        WEEK_OF_MONTH (int): final static field
        DATE (int): final static field
        DAY_OF_MONTH (int): final static field
        DAY_OF_YEAR (int): final static field
        DAY_OF_WEEK (int): final static field
        DAY_OF_WEEK_IN_MONTH (int): final static field
        AM_PM (int): final static field
        HOUR (int): final static field
        HOUR_OF_DAY (int): final static field
        MINUTE (int): final static field
        SECOND (int): final static field
        MILLISECOND (int): final static field
        ZONE_OFFSET (int): final static field
        DST_OFFSET (int): final static field
        FIELD_COUNT (int): final static field
        SUNDAY (int): final static field
        MONDAY (int): final static field
        TUESDAY (int): final static field
        WEDNESDAY (int): final static field
        THURSDAY (int): final static field
        FRIDAY (int): final static field
        SATURDAY (int): final static field
        JANUARY (int): final static field
        FEBRUARY (int): final static field
        MARCH (int): final static field
        APRIL (int): final static field
        MAY (int): final static field
        JUNE (int): final static field
        JULY (int): final static field
        AUGUST (int): final static field
        SEPTEMBER (int): final static field
        OCTOBER (int): final static field
        NOVEMBER (int): final static field
        DECEMBER (int): final static field
        UNDECIMBER (int): final static field
        AM (int): final static field
        PM (int): final static field
        ALL_STYLES (int): final static field
        SHORT (int): final static field
        LONG (int): final static field
        NARROW_FORMAT (int): final static field
        NARROW_STANDALONE (int): final static field
        SHORT_FORMAT (int): final static field
        LONG_FORMAT (int): final static field
        SHORT_STANDALONE (int): final static field
        LONG_STANDALONE (int): final static field
    
    """
    ERA: typing.ClassVar[int] = ...
    YEAR: typing.ClassVar[int] = ...
    MONTH: typing.ClassVar[int] = ...
    WEEK_OF_YEAR: typing.ClassVar[int] = ...
    WEEK_OF_MONTH: typing.ClassVar[int] = ...
    DATE: typing.ClassVar[int] = ...
    DAY_OF_MONTH: typing.ClassVar[int] = ...
    DAY_OF_YEAR: typing.ClassVar[int] = ...
    DAY_OF_WEEK: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: typing.ClassVar[int] = ...
    AM_PM: typing.ClassVar[int] = ...
    HOUR: typing.ClassVar[int] = ...
    HOUR_OF_DAY: typing.ClassVar[int] = ...
    MINUTE: typing.ClassVar[int] = ...
    SECOND: typing.ClassVar[int] = ...
    MILLISECOND: typing.ClassVar[int] = ...
    ZONE_OFFSET: typing.ClassVar[int] = ...
    DST_OFFSET: typing.ClassVar[int] = ...
    FIELD_COUNT: typing.ClassVar[int] = ...
    SUNDAY: typing.ClassVar[int] = ...
    MONDAY: typing.ClassVar[int] = ...
    TUESDAY: typing.ClassVar[int] = ...
    WEDNESDAY: typing.ClassVar[int] = ...
    THURSDAY: typing.ClassVar[int] = ...
    FRIDAY: typing.ClassVar[int] = ...
    SATURDAY: typing.ClassVar[int] = ...
    JANUARY: typing.ClassVar[int] = ...
    FEBRUARY: typing.ClassVar[int] = ...
    MARCH: typing.ClassVar[int] = ...
    APRIL: typing.ClassVar[int] = ...
    MAY: typing.ClassVar[int] = ...
    JUNE: typing.ClassVar[int] = ...
    JULY: typing.ClassVar[int] = ...
    AUGUST: typing.ClassVar[int] = ...
    SEPTEMBER: typing.ClassVar[int] = ...
    OCTOBER: typing.ClassVar[int] = ...
    NOVEMBER: typing.ClassVar[int] = ...
    DECEMBER: typing.ClassVar[int] = ...
    UNDECIMBER: typing.ClassVar[int] = ...
    AM: typing.ClassVar[int] = ...
    PM: typing.ClassVar[int] = ...
    ALL_STYLES: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    NARROW_FORMAT: typing.ClassVar[int] = ...
    NARROW_STANDALONE: typing.ClassVar[int] = ...
    SHORT_FORMAT: typing.ClassVar[int] = ...
    LONG_FORMAT: typing.ClassVar[int] = ...
    SHORT_STANDALONE: typing.ClassVar[int] = ...
    LONG_STANDALONE: typing.ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def after(self, object: typing.Any) -> bool: ...
    def before(self, object: typing.Any) -> bool: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, int: int) -> None: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, calendar: 'Calendar') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> int: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    @classmethod
    def getAvailableCalendarTypes(cls) -> 'Set'[java.lang.String]: ...
    @classmethod
    def getAvailableLocales(cls) -> typing.List['Locale']: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getDisplayName(self, int: int, int2: int, locale: 'Locale') -> java.lang.String: ...
    def getDisplayNames(self, int: int, int2: int, locale: 'Locale') -> 'Map'[java.lang.String, int]: ...
    def getFirstDayOfWeek(self) -> int: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    @classmethod
    @typing.overload
    def getInstance(cls) -> 'Calendar': ...
    @classmethod
    @typing.overload
    def getInstance(cls, locale: 'Locale') -> 'Calendar': ...
    @classmethod
    @typing.overload
    def getInstance(cls, timeZone: 'TimeZone') -> 'Calendar': ...
    @classmethod
    @typing.overload
    def getInstance(cls, timeZone: 'TimeZone', locale: 'Locale') -> 'Calendar': ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTime(self) -> 'Date': ...
    def getTimeInMillis(self) -> int: ...
    def getTimeZone(self) -> 'TimeZone': ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    def isSet(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def roll(self, int: int, int2: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int) -> None: ...
    def setFirstDayOfWeek(self, int: int) -> None: ...
    def setLenient(self, boolean: bool) -> None: ...
    def setMinimalDaysInFirstWeek(self, int: int) -> None: ...
    def setTime(self, date: 'Date') -> None: ...
    def setTimeInMillis(self, long: int) -> None: ...
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toInstant(self) -> java.time.Instant: ...
    def toString(self) -> java.lang.String: ...
    class Builder(java.lang.Object):
        """
        Java class 'java.util.Calendar$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'Calendar': ...
        def set(self, int: int, int2: int) -> 'Calendar.Builder': ...
        def setCalendarType(self, string: java.lang.String) -> 'Calendar.Builder': ...
        def setDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setFields(self, intArray: typing.List[int]) -> 'Calendar.Builder': ...
        @typing.overload
        def setInstant(self, date: 'Date') -> 'Calendar.Builder': ...
        @typing.overload
        def setInstant(self, long: int) -> 'Calendar.Builder': ...
        def setLenient(self, boolean: bool) -> 'Calendar.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Calendar.Builder': ...
        @typing.overload
        def setTimeOfDay(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        @typing.overload
        def setTimeOfDay(self, int: int, int2: int, int3: int, int4: int) -> 'Calendar.Builder': ...
        def setTimeZone(self, timeZone: 'TimeZone') -> 'Calendar.Builder': ...
        def setWeekDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setWeekDefinition(self, int: int, int2: int) -> 'Calendar.Builder': ...

_Collection__E = typing.TypeVar('_Collection__E')  # <E>
class Collection(java.lang.Iterable[_Collection__E], typing.Generic[_Collection__E]):
    """
    Java class 'java.util.Collection'
    
        Interfaces:
            java.lang.Iterable
    
    """
    def add(self, e: _Collection__E) -> bool: ...
    def addAll(self, collection: typing.Union['Collection'[_Collection__E], typing.Sequence[_Collection__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[_Collection__E]: ...
    def parallelStream(self) -> java.util.stream.Stream[_Collection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_Collection__E], typing.Callable[[], _Collection__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Collection__E]: ...
    def stream(self) -> java.util.stream.Stream[_Collection__E]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_2__T]], typing.Callable[[], typing.List[_toArray_2__T]]]) -> typing.List[_toArray_2__T]: ...

class Collections(java.lang.Object):
    """
    Java class 'java.util.Collections'
    
        Extends:
            java.lang.Object
    
      Attributes:
        EMPTY_SET (java.util.Set): final static field
        EMPTY_LIST (java.util.List): final static field
        EMPTY_MAP (java.util.Map): final static field
    
    """
    EMPTY_SET: typing.ClassVar['Set'] = ...
    EMPTY_LIST: typing.ClassVar['List'] = ...
    EMPTY_MAP: typing.ClassVar['Map'] = ...
    _addAll__T = typing.TypeVar('_addAll__T')  # <T>
    @classmethod
    def addAll(cls, collection: typing.Union[Collection[_addAll__T], typing.Sequence[_addAll__T]], tArray: typing.List[_addAll__T]) -> bool: ...
    _asLifoQueue__T = typing.TypeVar('_asLifoQueue__T')  # <T>
    @classmethod
    def asLifoQueue(cls, deque: 'Deque'[_asLifoQueue__T]) -> 'Queue'[_asLifoQueue__T]: ...
    _binarySearch_0__T = typing.TypeVar('_binarySearch_0__T')  # <T>
    @classmethod
    @typing.overload
    def binarySearch(cls, list: 'List'[java.lang.Comparable[_binarySearch_0__T]], t: _binarySearch_0__T) -> int: ...
    _binarySearch_1__T = typing.TypeVar('_binarySearch_1__T')  # <T>
    @classmethod
    @typing.overload
    def binarySearch(cls, list: 'List'[_binarySearch_1__T], t: _binarySearch_1__T, comparator: typing.Union['Comparator'[_binarySearch_1__T], typing.Callable[[], _binarySearch_1__T]]) -> int: ...
    _checkedCollection__E = typing.TypeVar('_checkedCollection__E')  # <E>
    @classmethod
    def checkedCollection(cls, collection: typing.Union[Collection[_checkedCollection__E], typing.Sequence[_checkedCollection__E]], class_: typing.Type[_checkedCollection__E]) -> Collection[_checkedCollection__E]: ...
    _checkedList__E = typing.TypeVar('_checkedList__E')  # <E>
    @classmethod
    def checkedList(cls, list: 'List'[_checkedList__E], class_: typing.Type[_checkedList__E]) -> 'List'[_checkedList__E]: ...
    _checkedMap__K = typing.TypeVar('_checkedMap__K')  # <K>
    _checkedMap__V = typing.TypeVar('_checkedMap__V')  # <V>
    @classmethod
    def checkedMap(cls, map: typing.Union['Map'[_checkedMap__K, _checkedMap__V], typing.Mapping[_checkedMap__K, _checkedMap__V]], class_: typing.Type[_checkedMap__K], class2: typing.Type[_checkedMap__V]) -> 'Map'[_checkedMap__K, _checkedMap__V]: ...
    _checkedNavigableMap__K = typing.TypeVar('_checkedNavigableMap__K')  # <K>
    _checkedNavigableMap__V = typing.TypeVar('_checkedNavigableMap__V')  # <V>
    @classmethod
    def checkedNavigableMap(cls, navigableMap: 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V], class_: typing.Type[_checkedNavigableMap__K], class2: typing.Type[_checkedNavigableMap__V]) -> 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V]: ...
    _checkedNavigableSet__E = typing.TypeVar('_checkedNavigableSet__E')  # <E>
    @classmethod
    def checkedNavigableSet(cls, navigableSet: 'NavigableSet'[_checkedNavigableSet__E], class_: typing.Type[_checkedNavigableSet__E]) -> 'NavigableSet'[_checkedNavigableSet__E]: ...
    _checkedQueue__E = typing.TypeVar('_checkedQueue__E')  # <E>
    @classmethod
    def checkedQueue(cls, queue: 'Queue'[_checkedQueue__E], class_: typing.Type[_checkedQueue__E]) -> 'Queue'[_checkedQueue__E]: ...
    _checkedSet__E = typing.TypeVar('_checkedSet__E')  # <E>
    @classmethod
    def checkedSet(cls, set: 'Set'[_checkedSet__E], class_: typing.Type[_checkedSet__E]) -> 'Set'[_checkedSet__E]: ...
    _checkedSortedMap__K = typing.TypeVar('_checkedSortedMap__K')  # <K>
    _checkedSortedMap__V = typing.TypeVar('_checkedSortedMap__V')  # <V>
    @classmethod
    def checkedSortedMap(cls, sortedMap: 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V], class_: typing.Type[_checkedSortedMap__K], class2: typing.Type[_checkedSortedMap__V]) -> 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V]: ...
    _checkedSortedSet__E = typing.TypeVar('_checkedSortedSet__E')  # <E>
    @classmethod
    def checkedSortedSet(cls, sortedSet: 'SortedSet'[_checkedSortedSet__E], class_: typing.Type[_checkedSortedSet__E]) -> 'SortedSet'[_checkedSortedSet__E]: ...
    _copy__T = typing.TypeVar('_copy__T')  # <T>
    @classmethod
    def copy(cls, list: 'List'[_copy__T], list2: 'List'[_copy__T]) -> None: ...
    @classmethod
    def disjoint(cls, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]], collection2: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _emptyEnumeration__T = typing.TypeVar('_emptyEnumeration__T')  # <T>
    @classmethod
    def emptyEnumeration(cls) -> 'Enumeration'[_emptyEnumeration__T]: ...
    _emptyIterator__T = typing.TypeVar('_emptyIterator__T')  # <T>
    @classmethod
    def emptyIterator(cls) -> 'Iterator'[_emptyIterator__T]: ...
    _emptyList__T = typing.TypeVar('_emptyList__T')  # <T>
    @classmethod
    def emptyList(cls) -> 'List'[_emptyList__T]: ...
    _emptyListIterator__T = typing.TypeVar('_emptyListIterator__T')  # <T>
    @classmethod
    def emptyListIterator(cls) -> 'ListIterator'[_emptyListIterator__T]: ...
    _emptyMap__K = typing.TypeVar('_emptyMap__K')  # <K>
    _emptyMap__V = typing.TypeVar('_emptyMap__V')  # <V>
    @classmethod
    def emptyMap(cls) -> 'Map'[_emptyMap__K, _emptyMap__V]: ...
    _emptyNavigableMap__K = typing.TypeVar('_emptyNavigableMap__K')  # <K>
    _emptyNavigableMap__V = typing.TypeVar('_emptyNavigableMap__V')  # <V>
    @classmethod
    def emptyNavigableMap(cls) -> 'NavigableMap'[_emptyNavigableMap__K, _emptyNavigableMap__V]: ...
    _emptyNavigableSet__E = typing.TypeVar('_emptyNavigableSet__E')  # <E>
    @classmethod
    def emptyNavigableSet(cls) -> 'NavigableSet'[_emptyNavigableSet__E]: ...
    _emptySet__T = typing.TypeVar('_emptySet__T')  # <T>
    @classmethod
    def emptySet(cls) -> 'Set'[_emptySet__T]: ...
    _emptySortedMap__K = typing.TypeVar('_emptySortedMap__K')  # <K>
    _emptySortedMap__V = typing.TypeVar('_emptySortedMap__V')  # <V>
    @classmethod
    def emptySortedMap(cls) -> 'SortedMap'[_emptySortedMap__K, _emptySortedMap__V]: ...
    _emptySortedSet__E = typing.TypeVar('_emptySortedSet__E')  # <E>
    @classmethod
    def emptySortedSet(cls) -> 'SortedSet'[_emptySortedSet__E]: ...
    _enumeration__T = typing.TypeVar('_enumeration__T')  # <T>
    @classmethod
    def enumeration(cls, collection: typing.Union[Collection[_enumeration__T], typing.Sequence[_enumeration__T]]) -> 'Enumeration'[_enumeration__T]: ...
    _fill__T = typing.TypeVar('_fill__T')  # <T>
    @classmethod
    def fill(cls, list: 'List'[_fill__T], t: _fill__T) -> None: ...
    @classmethod
    def frequency(cls, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]], object: typing.Any) -> int: ...
    @classmethod
    def indexOfSubList(cls, list: 'List'[typing.Any], list2: 'List'[typing.Any]) -> int: ...
    @classmethod
    def lastIndexOfSubList(cls, list: 'List'[typing.Any], list2: 'List'[typing.Any]) -> int: ...
    _list__T = typing.TypeVar('_list__T')  # <T>
    @classmethod
    def list(cls, enumeration: 'Enumeration'[_list__T]) -> 'ArrayList'[_list__T]: ...
    _max_0__T = typing.TypeVar('_max_0__T')  # <T>
    @classmethod
    @typing.overload
    def max(cls, collection: typing.Union[Collection[_max_0__T], typing.Sequence[_max_0__T]]) -> _max_0__T: ...
    _max_1__T = typing.TypeVar('_max_1__T')  # <T>
    @classmethod
    @typing.overload
    def max(cls, collection: typing.Union[Collection[_max_1__T], typing.Sequence[_max_1__T]], comparator: typing.Union['Comparator'[_max_1__T], typing.Callable[[], _max_1__T]]) -> _max_1__T: ...
    _min_0__T = typing.TypeVar('_min_0__T')  # <T>
    @classmethod
    @typing.overload
    def min(cls, collection: typing.Union[Collection[_min_0__T], typing.Sequence[_min_0__T]]) -> _min_0__T: ...
    _min_1__T = typing.TypeVar('_min_1__T')  # <T>
    @classmethod
    @typing.overload
    def min(cls, collection: typing.Union[Collection[_min_1__T], typing.Sequence[_min_1__T]], comparator: typing.Union['Comparator'[_min_1__T], typing.Callable[[], _min_1__T]]) -> _min_1__T: ...
    _nCopies__T = typing.TypeVar('_nCopies__T')  # <T>
    @classmethod
    def nCopies(cls, int: int, t: _nCopies__T) -> 'List'[_nCopies__T]: ...
    _newSetFromMap__E = typing.TypeVar('_newSetFromMap__E')  # <E>
    @classmethod
    def newSetFromMap(cls, map: typing.Union['Map'[_newSetFromMap__E, bool], typing.Mapping[_newSetFromMap__E, bool]]) -> 'Set'[_newSetFromMap__E]: ...
    _replaceAll__T = typing.TypeVar('_replaceAll__T')  # <T>
    @classmethod
    def replaceAll(cls, list: 'List'[_replaceAll__T], t: _replaceAll__T, t2: _replaceAll__T) -> bool: ...
    @classmethod
    def reverse(cls, list: 'List'[typing.Any]) -> None: ...
    _reverseOrder_0__T = typing.TypeVar('_reverseOrder_0__T')  # <T>
    @classmethod
    @typing.overload
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder_0__T]: ...
    _reverseOrder_1__T = typing.TypeVar('_reverseOrder_1__T')  # <T>
    @classmethod
    @typing.overload
    def reverseOrder(cls, comparator: typing.Union['Comparator'[_reverseOrder_1__T], typing.Callable[[], _reverseOrder_1__T]]) -> 'Comparator'[_reverseOrder_1__T]: ...
    @classmethod
    def rotate(cls, list: 'List'[typing.Any], int: int) -> None: ...
    @classmethod
    @typing.overload
    def shuffle(cls, list: 'List'[typing.Any]) -> None: ...
    @classmethod
    @typing.overload
    def shuffle(cls, list: 'List'[typing.Any], random: 'Random') -> None: ...
    _singleton__T = typing.TypeVar('_singleton__T')  # <T>
    @classmethod
    def singleton(cls, t: _singleton__T) -> 'Set'[_singleton__T]: ...
    _singletonList__T = typing.TypeVar('_singletonList__T')  # <T>
    @classmethod
    def singletonList(cls, t: _singletonList__T) -> 'List'[_singletonList__T]: ...
    _singletonMap__K = typing.TypeVar('_singletonMap__K')  # <K>
    _singletonMap__V = typing.TypeVar('_singletonMap__V')  # <V>
    @classmethod
    def singletonMap(cls, k: _singletonMap__K, v: _singletonMap__V) -> 'Map'[_singletonMap__K, _singletonMap__V]: ...
    _sort_0__T = typing.TypeVar('_sort_0__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @typing.overload
    def sort(cls, list: 'List'[_sort_0__T]) -> None: ...
    _sort_1__T = typing.TypeVar('_sort_1__T')  # <T>
    @classmethod
    @typing.overload
    def sort(cls, list: 'List'[_sort_1__T], comparator: typing.Union['Comparator'[_sort_1__T], typing.Callable[[], _sort_1__T]]) -> None: ...
    @classmethod
    def swap(cls, list: 'List'[typing.Any], int: int, int2: int) -> None: ...
    _synchronizedCollection__T = typing.TypeVar('_synchronizedCollection__T')  # <T>
    @classmethod
    def synchronizedCollection(cls, collection: typing.Union[Collection[_synchronizedCollection__T], typing.Sequence[_synchronizedCollection__T]]) -> Collection[_synchronizedCollection__T]: ...
    _synchronizedList__T = typing.TypeVar('_synchronizedList__T')  # <T>
    @classmethod
    def synchronizedList(cls, list: 'List'[_synchronizedList__T]) -> 'List'[_synchronizedList__T]: ...
    _synchronizedMap__K = typing.TypeVar('_synchronizedMap__K')  # <K>
    _synchronizedMap__V = typing.TypeVar('_synchronizedMap__V')  # <V>
    @classmethod
    def synchronizedMap(cls, map: typing.Union['Map'[_synchronizedMap__K, _synchronizedMap__V], typing.Mapping[_synchronizedMap__K, _synchronizedMap__V]]) -> 'Map'[_synchronizedMap__K, _synchronizedMap__V]: ...
    _synchronizedNavigableMap__K = typing.TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = typing.TypeVar('_synchronizedNavigableMap__V')  # <V>
    @classmethod
    def synchronizedNavigableMap(cls, navigableMap: 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]) -> 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _synchronizedNavigableSet__T = typing.TypeVar('_synchronizedNavigableSet__T')  # <T>
    @classmethod
    def synchronizedNavigableSet(cls, navigableSet: 'NavigableSet'[_synchronizedNavigableSet__T]) -> 'NavigableSet'[_synchronizedNavigableSet__T]: ...
    _synchronizedSet__T = typing.TypeVar('_synchronizedSet__T')  # <T>
    @classmethod
    def synchronizedSet(cls, set: 'Set'[_synchronizedSet__T]) -> 'Set'[_synchronizedSet__T]: ...
    _synchronizedSortedMap__K = typing.TypeVar('_synchronizedSortedMap__K')  # <K>
    _synchronizedSortedMap__V = typing.TypeVar('_synchronizedSortedMap__V')  # <V>
    @classmethod
    def synchronizedSortedMap(cls, sortedMap: 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]) -> 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]: ...
    _synchronizedSortedSet__T = typing.TypeVar('_synchronizedSortedSet__T')  # <T>
    @classmethod
    def synchronizedSortedSet(cls, sortedSet: 'SortedSet'[_synchronizedSortedSet__T]) -> 'SortedSet'[_synchronizedSortedSet__T]: ...
    _unmodifiableCollection__T = typing.TypeVar('_unmodifiableCollection__T')  # <T>
    @classmethod
    def unmodifiableCollection(cls, collection: typing.Union[Collection[_unmodifiableCollection__T], typing.Sequence[_unmodifiableCollection__T]]) -> Collection[_unmodifiableCollection__T]: ...
    _unmodifiableList__T = typing.TypeVar('_unmodifiableList__T')  # <T>
    @classmethod
    def unmodifiableList(cls, list: 'List'[_unmodifiableList__T]) -> 'List'[_unmodifiableList__T]: ...
    _unmodifiableMap__K = typing.TypeVar('_unmodifiableMap__K')  # <K>
    _unmodifiableMap__V = typing.TypeVar('_unmodifiableMap__V')  # <V>
    @classmethod
    def unmodifiableMap(cls, map: typing.Union['Map'[_unmodifiableMap__K, _unmodifiableMap__V], typing.Mapping[_unmodifiableMap__K, _unmodifiableMap__V]]) -> 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]: ...
    _unmodifiableNavigableMap__K = typing.TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = typing.TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @classmethod
    def unmodifiableNavigableMap(cls, navigableMap: 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]) -> 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    _unmodifiableNavigableSet__T = typing.TypeVar('_unmodifiableNavigableSet__T')  # <T>
    @classmethod
    def unmodifiableNavigableSet(cls, navigableSet: 'NavigableSet'[_unmodifiableNavigableSet__T]) -> 'NavigableSet'[_unmodifiableNavigableSet__T]: ...
    _unmodifiableSet__T = typing.TypeVar('_unmodifiableSet__T')  # <T>
    @classmethod
    def unmodifiableSet(cls, set: 'Set'[_unmodifiableSet__T]) -> 'Set'[_unmodifiableSet__T]: ...
    _unmodifiableSortedMap__K = typing.TypeVar('_unmodifiableSortedMap__K')  # <K>
    _unmodifiableSortedMap__V = typing.TypeVar('_unmodifiableSortedMap__V')  # <V>
    @classmethod
    def unmodifiableSortedMap(cls, sortedMap: 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]) -> 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]: ...
    _unmodifiableSortedSet__T = typing.TypeVar('_unmodifiableSortedSet__T')  # <T>
    @classmethod
    def unmodifiableSortedSet(cls, sortedSet: 'SortedSet'[_unmodifiableSortedSet__T]) -> 'SortedSet'[_unmodifiableSortedSet__T]: ...

_Comparator__T = typing.TypeVar('_Comparator__T')  # <T>
class Comparator(java.lang.Object, typing.Generic[_Comparator__T]):
    """
    :class:`~java.lang.FunctionalInterface` public interface Comparator<T>
    
        A comparison function, which imposes a *total ordering* on some collection of objects. Comparators can be passed to a
        sort method (such as :meth:`~java.util.Collections.sort` or :meth:`~java.util.Arrays.sort`) to allow precise control
        over the sort order. Comparators can also be used to control the order of certain data structures (such as
        :class:`~java.util.SortedSet` or :class:`~java.util.SortedMap`), or to provide an ordering for collections of objects
        that don't have a :class:`~java.lang.Comparable`.
    
        The ordering imposed by a comparator :code:`c` on a set of elements :code:`S` is said to be *consistent with equals* if
        and only if :code:`c.compare(e1, e2)==0` has the same boolean value as :code:`e1.equals(e2)` for every :code:`e1` and
        :code:`e2` in :code:`S`.
    
        Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a
        sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator :code:`c` is used with
        elements (or keys) drawn from a set :code:`S`. If the ordering imposed by :code:`c` on :code:`S` is inconsistent with
        equals, the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will
        violate the general contract for set (or map), which is defined in terms of :code:`equals`.
    
        For example, suppose one adds two elements :code:`a` and :code:`b` such that :code:`(a.equals(b) &&amp; c.compare(a, b)
        != 0)` to an empty :code:`TreeSet` with comparator :code:`c`. The second :code:`add` operation will return true (and the
        size of the tree set will increase) because :code:`a` and :code:`b` are not equivalent from the tree set's perspective,
        even though this is contrary to the specification of the :meth:`~java.util.Set.add` method.
    
        Note: It is generally a good idea for comparators to also implement :code:`java.io.Serializable`, as they may be used as
        ordering methods in serializable data structures (like :class:`~java.util.TreeSet`, :class:`~java.util.TreeMap`). In
        order for the data structure to serialize successfully, the comparator (if provided) must implement
        :code:`Serializable`.
    
        For the mathematically inclined, the *relation* that defines the *imposed ordering* that a given comparator :code:`c`
        imposes on a given set of objects :code:`S` is:
    
        .. code-block: java
        
               {(x, y) such that c.compare(x, y) <= 0}.
         
        The *quotient* for this total order is:
    
        .. code-block: java
        
               {(x, y) such that c.compare(x, y) == 0}.
         
        It follows immediately from the contract for :code:`compare` that the quotient is an *equivalence relation* on
        :code:`S`, and that the imposed ordering is a *total order* on :code:`S`. When we say that the ordering imposed by
        :code:`c` on :code:`S` is *consistent with equals*, we mean that the quotient for the ordering is the equivalence
        relation defined by the objects' :meth:`~java.lang.Object.equals` method(s):
    
        .. code-block: java
        
             {(x, y) such that x.equals(y)}. 
    
        Unlike :code:`Comparable`, a comparator may optionally permit comparison of null arguments, while maintaining the
        requirements for an equivalence relation.
    
        This interface is a member of the :meth:`~java.util.package`.
    
        Since:
            1.2
    
        Also see:
            :class:`~java.lang.Comparable`, :class:`~java.io.Serializable`
    
    
    """
    def compare(self, t: _Comparator__T, t2: _Comparator__T) -> int: ...
    _comparing_0__T = typing.TypeVar('_comparing_0__T')  # <T>
    _comparing_0__U = typing.TypeVar('_comparing_0__U', bound=java.lang.Comparable)  # <U>
    @classmethod
    @typing.overload
    def comparing(cls, function: typing.Union[java.util.function.Function[_comparing_0__T, _comparing_0__U], typing.Callable[[_comparing_0__T], _comparing_0__U]]) -> 'Comparator'[_comparing_0__T]: ...
    _comparing_1__T = typing.TypeVar('_comparing_1__T')  # <T>
    _comparing_1__U = typing.TypeVar('_comparing_1__U')  # <U>
    @classmethod
    @typing.overload
    def comparing(cls, function: typing.Union[java.util.function.Function[_comparing_1__T, _comparing_1__U], typing.Callable[[_comparing_1__T], _comparing_1__U]], comparator: typing.Union['Comparator'[_comparing_1__U], typing.Callable[[], _comparing_1__U]]) -> 'Comparator'[_comparing_1__T]: ...
    _comparingDouble__T = typing.TypeVar('_comparingDouble__T')  # <T>
    @classmethod
    def comparingDouble(cls, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_comparingDouble__T], typing.Callable[[], _comparingDouble__T]]) -> 'Comparator'[_comparingDouble__T]: ...
    _comparingInt__T = typing.TypeVar('_comparingInt__T')  # <T>
    @classmethod
    def comparingInt(cls, toIntFunction: typing.Union[java.util.function.ToIntFunction[_comparingInt__T], typing.Callable[[], _comparingInt__T]]) -> 'Comparator'[_comparingInt__T]: ...
    _comparingLong__T = typing.TypeVar('_comparingLong__T')  # <T>
    @classmethod
    def comparingLong(cls, toLongFunction: typing.Union[java.util.function.ToLongFunction[_comparingLong__T], typing.Callable[[], _comparingLong__T]]) -> 'Comparator'[_comparingLong__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    _naturalOrder__T = typing.TypeVar('_naturalOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def naturalOrder(cls) -> 'Comparator'[_naturalOrder__T]: ...
    _nullsFirst__T = typing.TypeVar('_nullsFirst__T')  # <T>
    @classmethod
    def nullsFirst(cls, comparator: typing.Union['Comparator'[_nullsFirst__T], typing.Callable[[], _nullsFirst__T]]) -> 'Comparator'[_nullsFirst__T]: ...
    _nullsLast__T = typing.TypeVar('_nullsLast__T')  # <T>
    @classmethod
    def nullsLast(cls, comparator: typing.Union['Comparator'[_nullsLast__T], typing.Callable[[], _nullsLast__T]]) -> 'Comparator'[_nullsLast__T]: ...
    _reverseOrder__T = typing.TypeVar('_reverseOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder__T]: ...
    def reversed(self) -> 'Comparator'[_Comparator__T]: ...
    @typing.overload
    def thenComparing(self, comparator: typing.Union['Comparator'[_Comparator__T], typing.Callable[[], _Comparator__T]]) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_1__U = typing.TypeVar('_thenComparing_1__U', bound=java.lang.Comparable)  # <U>
    @typing.overload
    def thenComparing(self, function: typing.Union[java.util.function.Function[_Comparator__T, _thenComparing_1__U], typing.Callable[[_Comparator__T], _thenComparing_1__U]]) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_2__U = typing.TypeVar('_thenComparing_2__U')  # <U>
    @typing.overload
    def thenComparing(self, function: typing.Union[java.util.function.Function[_Comparator__T, _thenComparing_2__U], typing.Callable[[_Comparator__T], _thenComparing_2__U]], comparator: typing.Union['Comparator'[_thenComparing_2__U], typing.Callable[[], _thenComparing_2__U]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingDouble(self, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_Comparator__T], typing.Callable[[], _Comparator__T]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingInt(self, toIntFunction: typing.Union[java.util.function.ToIntFunction[_Comparator__T], typing.Callable[[], _Comparator__T]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingLong(self, toLongFunction: typing.Union[java.util.function.ToLongFunction[_Comparator__T], typing.Callable[[], _Comparator__T]]) -> 'Comparator'[_Comparator__T]: ...

class ConcurrentModificationException(java.lang.RuntimeException):
    """
    Java class 'java.util.ConcurrentModificationException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ConcurrentModificationException(java.lang.String, java.lang.Throwable)
        * ConcurrentModificationException(java.lang.Throwable)
        * ConcurrentModificationException(java.lang.String)
        * ConcurrentModificationException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Currency(java.io.Serializable):
    """
    Java class 'java.util.Currency'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    @classmethod
    def getAvailableCurrencies(cls) -> 'Set'['Currency']: ...
    def getCurrencyCode(self) -> java.lang.String: ...
    def getDefaultFractionDigits(self) -> int: ...
    @typing.overload
    def getDisplayName(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self, locale: 'Locale') -> java.lang.String: ...
    @classmethod
    @typing.overload
    def getInstance(cls, string: java.lang.String) -> 'Currency': ...
    @classmethod
    @typing.overload
    def getInstance(cls, locale: 'Locale') -> 'Currency': ...
    def getNumericCode(self) -> int: ...
    def getNumericCodeAsString(self) -> java.lang.String: ...
    @typing.overload
    def getSymbol(self) -> java.lang.String: ...
    @typing.overload
    def getSymbol(self, locale: 'Locale') -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class Date(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable[java.util.Date]):
    """
    Java class 'java.util.Date'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Cloneable,
            java.lang.Comparable
    
      Constructors:
        * Date(int, int, int, int, int, int)
        * Date(java.lang.String)
        * Date()
        * Date(long)
        * Date(int, int, int)
        * Date(int, int, int, int, int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, long: int): ...
    @classmethod
    def UTC(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    def after(self, date: 'Date') -> bool: ...
    def before(self, date: 'Date') -> bool: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, date: 'Date') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDate(self) -> int: ...
    def getDay(self) -> int: ...
    def getHours(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getMonth(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getTime(self) -> int: ...
    def getTimezoneOffset(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def parse(cls, string: java.lang.String) -> int: ...
    def setDate(self, int: int) -> None: ...
    def setHours(self, int: int) -> None: ...
    def setMinutes(self, int: int) -> None: ...
    def setMonth(self, int: int) -> None: ...
    def setSeconds(self, int: int) -> None: ...
    def setTime(self, long: int) -> None: ...
    def setYear(self, int: int) -> None: ...
    def toGMTString(self) -> java.lang.String: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocaleString(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

_Dictionary__K = typing.TypeVar('_Dictionary__K')  # <K>
_Dictionary__V = typing.TypeVar('_Dictionary__V')  # <V>
class Dictionary(java.lang.Object, typing.Generic[_Dictionary__K, _Dictionary__V]):
    """
    Java class 'java.util.Dictionary'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Dictionary()
    
    """
    def __init__(self): ...
    def elements(self) -> 'Enumeration'[_Dictionary__V]: ...
    def get(self, object: typing.Any) -> _Dictionary__V: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> 'Enumeration'[_Dictionary__K]: ...
    def put(self, k: _Dictionary__K, v: _Dictionary__V) -> _Dictionary__V: ...
    def remove(self, object: typing.Any) -> _Dictionary__V: ...
    def size(self) -> int: ...

class DoubleSummaryStatistics(java.util.function.DoubleConsumer):
    """
    Java class 'java.util.DoubleSummaryStatistics'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.function.DoubleConsumer
    
      Constructors:
        * DoubleSummaryStatistics()
        * DoubleSummaryStatistics(long, double, double, double)
    
      Raises:
        java.lang.IllegalArgumentException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int, double: float, double2: float, double3: float): ...
    def accept(self, double: float) -> None: ...
    def combine(self, doubleSummaryStatistics: 'DoubleSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getSum(self) -> float: ...
    def toString(self) -> java.lang.String: ...

class EmptyStackException(java.lang.RuntimeException):
    """
    Java class 'java.util.EmptyStackException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * EmptyStackException()
    
    """
    def __init__(self): ...

_Enumeration__E = typing.TypeVar('_Enumeration__E')  # <E>
class Enumeration(java.lang.Object, typing.Generic[_Enumeration__E]):
    """
    public interface Enumeration<E>
    
        An object that implements the Enumeration interface generates a series of elements, one at a time. Successive calls to
        the :code:`nextElement` method return successive elements of the series.
    
        For example, to print all elements of a :code:`Vector<E>` *v*:
    
        .. code-block: java
        
           for (Enumeration<E> e = v.elements(); e.hasMoreElements();)
               System.out.println(e.nextElement());
    
        Methods are provided to enumerate through the elements of a vector, the keys of a hashtable, and the values in a
        hashtable. Enumerations are also used to specify the input streams to a :code:`SequenceInputStream`.
    
        API Note:
            The functionality of this interface is duplicated by the :class:`~java.util.Iterator` interface. In addition,
            :code:`Iterator` adds an optional remove operation, and has shorter method names. New implementations should consider
            using :code:`Iterator` in preference to :code:`Enumeration`. It is possible to adapt an :code:`Enumeration` to an
            :code:`Iterator` by using the :meth:`~java.util.Enumeration.asIterator` method.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.util.Iterator`, :class:`~java.io.SequenceInputStream`, :meth:`~java.util.Enumeration.nextElement`,
            :class:`~java.util.Hashtable`, :meth:`~java.util.Hashtable.elements`, :meth:`~java.util.Hashtable.keys`,
            :class:`~java.util.Vector`, :meth:`~java.util.Vector.elements`
    
    
    """
    def asIterator(self) -> 'Iterator'[_Enumeration__E]: ...
    def hasMoreElements(self) -> bool: ...
    def nextElement(self) -> _Enumeration__E: ...

class EventListener(java.lang.Object):
    """
    public interface EventListener
    
        A tagging interface that all event listener interfaces must extend.
    
        Since:
            1.1
    
    
    """

class EventObject(java.io.Serializable):
    """
    Java class 'java.util.EventObject'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * EventObject(java.lang.Object)
    
    """
    def __init__(self, object: typing.Any): ...
    def getSource(self) -> typing.Any: ...
    def toString(self) -> java.lang.String: ...

class Formattable(java.lang.Object):
    """
    public interface Formattable
    
        The :code:`Formattable` interface must be implemented by any class that needs to perform custom formatting using the
        :code:`'s'` conversion specifier of :class:`~java.util.Formatter`. This interface allows basic control for formatting
        arbitrary objects. For example, the following class prints out different representations of a stock's name depending on
        the flags and length constraints:
    
        .. code-block: java
        
         
           import java.nio.CharBuffer;
           import java.util.Formatter;
           import java.util.Formattable;
           import java.util.Locale;
           import static java.util.FormattableFlags.*;
        
           ...
        
           public class StockName implements Formattable {
               private String symbol, companyName, frenchCompanyName;
               public StockName(String symbol, String companyName,
                                String frenchCompanyName) {
                   ...
               }
        
               ...
        
               public void formatTo(Formatter fmt, int f, int width, int precision) {
                   StringBuilder sb = new StringBuilder();
        
                   // decide form of name
                   String name = companyName;
                   if (fmt.locale().equals(Locale.FRANCE))
                       name = frenchCompanyName;
                   boolean alternate = (f & ALTERNATE) == ALTERNATE;
                   boolean usesymbol = alternate || (precision != -1 &&amp; precision < 10);
                   String out = (usesymbol ? symbol : name);
        
                   // apply precision
                   if (precision == -1 || out.length() < precision) {
                       // write it all
                       sb.append(out);
                   } else {
                       sb.append(out.substring(0, precision - 1)).append('*');
                   }
        
                   // apply width and justification
                   int len = sb.length();
                   if (len < width)
                       for (int i = 0; i < width - len; i++)
                           if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY)
                               sb.append(' ');
                           else
                               sb.insert(0, ' ');
        
                   fmt.format(sb.toString());
               }
        
               public String toString() {
                   return String.format("%s - %s", symbol, companyName);
               }
           }
         
    
        When used in conjunction with the :class:`~java.util.Formatter`, the above class produces the following output for
        various format strings.
    
        .. code-block: java
        
         
           Formatter fmt = new Formatter();
           StockName sn = new StockName("HUGE", "Huge Fruit, Inc.",
                                        "Fruit Titanesque, Inc.");
           fmt.format("%s", sn);                   //   -> "Huge Fruit, Inc."
           fmt.format("%s", sn.toString());        //   -> "HUGE - Huge Fruit, Inc."
           fmt.format("%#s", sn);                  //   -> "HUGE"
           fmt.format("%-10.8s", sn);              //   -> "HUGE      "
           fmt.format("%.12s", sn);                //   -> "Huge Fruit,*"
           fmt.format(Locale.FRANCE, "%25s", sn);  //   -> "   Fruit Titanesque, Inc."
         
    
        Formattables are not necessarily safe for multithreaded access. Thread safety is optional and may be enforced by classes
        that extend and implement this interface.
    
        Unless otherwise specified, passing a :code:`null` argument to any method in this interface will cause a
        :class:`~java.lang.NullPointerException` to be thrown.
    
        Since:
            1.5
    
    
    """
    def formatTo(self, formatter: 'Formatter', int: int, int2: int, int3: int) -> None: ...

class FormattableFlags(java.lang.Object):
    """
    Java class 'java.util.FormattableFlags'
    
        Extends:
            java.lang.Object
    
      Attributes:
        LEFT_JUSTIFY (int): final static field
        UPPERCASE (int): final static field
        ALTERNATE (int): final static field
    
    """
    LEFT_JUSTIFY: typing.ClassVar[int] = ...
    UPPERCASE: typing.ClassVar[int] = ...
    ALTERNATE: typing.ClassVar[int] = ...

class Formatter(java.io.Closeable, java.io.Flushable):
    """
    Java class 'java.util.Formatter'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable, java.io.Flushable
    
      Constructors:
        * Formatter(java.io.File, java.lang.String)
        * Formatter(java.io.File)
        * Formatter(java.lang.String, java.nio.charset.Charset, java.util.Locale)
        * Formatter(java.lang.String, java.lang.String, java.util.Locale)
        * Formatter(java.lang.String, java.lang.String)
        * Formatter(java.io.OutputStream, java.lang.String)
        * Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)
        * Formatter(java.io.PrintStream)
        * Formatter(java.io.File, java.nio.charset.Charset, java.util.Locale)
        * Formatter(java.io.File, java.lang.String, java.util.Locale)
        * Formatter()
        * Formatter(java.io.OutputStream, java.nio.charset.Charset, java.util.Locale)
        * Formatter(java.io.OutputStream)
        * Formatter(java.lang.String)
        * Formatter(java.lang.Appendable, java.util.Locale)
        * Formatter(java.util.Locale)
        * Formatter(java.lang.Appendable)
    
      Raises:
        java.io.UnsupportedEncodingException: from java
        java.io.IOException: from java
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, file: java.io.File): ...
    @typing.overload
    def __init__(self, file: java.io.File, string: java.lang.String): ...
    @typing.overload
    def __init__(self, file: java.io.File, string: java.lang.String, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, file: java.io.File, charset: java.nio.charset.Charset, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, string: java.lang.String): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, string: java.lang.String, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, charset: java.nio.charset.Charset, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, printStream: java.io.PrintStream): ...
    @typing.overload
    def __init__(self, appendable: java.lang.Appendable): ...
    @typing.overload
    def __init__(self, appendable: java.lang.Appendable, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, string: java.lang.String, charset: java.nio.charset.Charset, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, locale: 'Locale'): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def format(self, string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'Formatter': ...
    @typing.overload
    def format(self, locale: 'Locale', string: java.lang.String, objectArray: typing.List[typing.Any]) -> 'Formatter': ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> 'Locale': ...
    def out(self) -> java.lang.Appendable: ...
    def toString(self) -> java.lang.String: ...
    class BigDecimalLayoutForm(java.lang.Enum[java.util.Formatter.BigDecimalLayoutForm]):
        """
        Java class 'java.util.Formatter$BigDecimalLayoutForm'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            SCIENTIFIC (java.util.Formatter$BigDecimalLayoutForm): final static enum constant
            DECIMAL_FLOAT (java.util.Formatter$BigDecimalLayoutForm): final static enum constant
        
        """
        SCIENTIFIC: typing.ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        DECIMAL_FLOAT: typing.ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Formatter.BigDecimalLayoutForm': ...
        @classmethod
        def values(cls) -> typing.List['Formatter.BigDecimalLayoutForm']: ...

class FormatterClosedException(java.lang.IllegalStateException):
    """
    Java class 'java.util.FormatterClosedException'
    
        Extends:
            java.lang.IllegalStateException
    
      Constructors:
        * FormatterClosedException()
    
    """
    def __init__(self): ...

class IllegalFormatException(java.lang.IllegalArgumentException):
    """
    Java class 'java.util.IllegalFormatException'
    
        Extends:
            java.lang.IllegalArgumentException
    
    """

class IllformedLocaleException(java.lang.RuntimeException):
    """
    Java class 'java.util.IllformedLocaleException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * IllformedLocaleException(java.lang.String, int)
        * IllformedLocaleException(java.lang.String)
        * IllformedLocaleException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int): ...
    def getErrorIndex(self) -> int: ...

class IntSummaryStatistics(java.util.function.IntConsumer):
    """
    Java class 'java.util.IntSummaryStatistics'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.function.IntConsumer
    
      Constructors:
        * IntSummaryStatistics()
        * IntSummaryStatistics(long, int, int, long)
    
      Raises:
        java.lang.IllegalArgumentException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int, int: int, int2: int, long2: int): ...
    def accept(self, int: int) -> None: ...
    def combine(self, intSummaryStatistics: 'IntSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class InvalidPropertiesFormatException(java.io.IOException):
    """
    Java class 'java.util.InvalidPropertiesFormatException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * InvalidPropertiesFormatException(java.lang.Throwable)
        * InvalidPropertiesFormatException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

_Iterator__E = typing.TypeVar('_Iterator__E')  # <E>
class Iterator(java.lang.Object, typing.Generic[_Iterator__E]):
    """
    public interface Iterator<E>
    
        An iterator over a collection. :code:`Iterator` takes the place of :class:`~java.util.Enumeration` in the Java
        Collections Framework. Iterators differ from enumerations in two ways:
    
          - Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined
            semantics.
          - Method names have been improved.
    
    
        This interface is a member of the :meth:`~java.util.package`.
    
        API Note:
            An :class:`~java.util.Enumeration` can be converted into an :code:`Iterator` by using the
            :meth:`~java.util.Enumeration.asIterator` method.
    
        Since:
            1.2
    
        Also see:
            :class:`~java.util.Collection`, :class:`~java.util.ListIterator`, :class:`~java.lang.Iterable`
    
    
    """
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Iterator__E], typing.Callable[[], _Iterator__E]]) -> None: ...
    def hasNext(self) -> bool: ...
    def next(self) -> _Iterator__E: ...
    def remove(self) -> None: ...

class Locale(java.lang.Cloneable, java.io.Serializable):
    """
    Java class 'java.util.Locale'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * Locale(java.lang.String)
        * Locale(java.lang.String, java.lang.String)
        * Locale(java.lang.String, java.lang.String, java.lang.String)
    
      Attributes:
        ENGLISH (java.util.Locale): final static field
        FRENCH (java.util.Locale): final static field
        GERMAN (java.util.Locale): final static field
        ITALIAN (java.util.Locale): final static field
        JAPANESE (java.util.Locale): final static field
        KOREAN (java.util.Locale): final static field
        CHINESE (java.util.Locale): final static field
        SIMPLIFIED_CHINESE (java.util.Locale): final static field
        TRADITIONAL_CHINESE (java.util.Locale): final static field
        FRANCE (java.util.Locale): final static field
        GERMANY (java.util.Locale): final static field
        ITALY (java.util.Locale): final static field
        JAPAN (java.util.Locale): final static field
        KOREA (java.util.Locale): final static field
        CHINA (java.util.Locale): final static field
        PRC (java.util.Locale): final static field
        TAIWAN (java.util.Locale): final static field
        UK (java.util.Locale): final static field
        US (java.util.Locale): final static field
        CANADA (java.util.Locale): final static field
        CANADA_FRENCH (java.util.Locale): final static field
        ROOT (java.util.Locale): final static field
        PRIVATE_USE_EXTENSION (char): final static field
        UNICODE_LOCALE_EXTENSION (char): final static field
    
    """
    ENGLISH: typing.ClassVar['Locale'] = ...
    FRENCH: typing.ClassVar['Locale'] = ...
    GERMAN: typing.ClassVar['Locale'] = ...
    ITALIAN: typing.ClassVar['Locale'] = ...
    JAPANESE: typing.ClassVar['Locale'] = ...
    KOREAN: typing.ClassVar['Locale'] = ...
    CHINESE: typing.ClassVar['Locale'] = ...
    SIMPLIFIED_CHINESE: typing.ClassVar['Locale'] = ...
    TRADITIONAL_CHINESE: typing.ClassVar['Locale'] = ...
    FRANCE: typing.ClassVar['Locale'] = ...
    GERMANY: typing.ClassVar['Locale'] = ...
    ITALY: typing.ClassVar['Locale'] = ...
    JAPAN: typing.ClassVar['Locale'] = ...
    KOREA: typing.ClassVar['Locale'] = ...
    CHINA: typing.ClassVar['Locale'] = ...
    PRC: typing.ClassVar['Locale'] = ...
    TAIWAN: typing.ClassVar['Locale'] = ...
    UK: typing.ClassVar['Locale'] = ...
    US: typing.ClassVar['Locale'] = ...
    CANADA: typing.ClassVar['Locale'] = ...
    CANADA_FRENCH: typing.ClassVar['Locale'] = ...
    ROOT: typing.ClassVar['Locale'] = ...
    PRIVATE_USE_EXTENSION: typing.ClassVar[str] = ...
    UNICODE_LOCALE_EXTENSION: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    @typing.overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale']]) -> 'List'['Locale']: ...
    @classmethod
    @typing.overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale']], filteringMode: 'Locale.FilteringMode') -> 'List'['Locale']: ...
    @classmethod
    @typing.overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> 'List'[java.lang.String]: ...
    @classmethod
    @typing.overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[java.lang.String], typing.Sequence[java.lang.String]], filteringMode: 'Locale.FilteringMode') -> 'List'[java.lang.String]: ...
    @classmethod
    def forLanguageTag(cls, string: java.lang.String) -> 'Locale': ...
    @classmethod
    def getAvailableLocales(cls) -> typing.List['Locale']: ...
    def getCountry(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def getDefault(cls) -> 'Locale': ...
    @classmethod
    @typing.overload
    def getDefault(cls, category: 'Locale.Category') -> 'Locale': ...
    @typing.overload
    def getDisplayCountry(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayCountry(self, locale: 'Locale') -> java.lang.String: ...
    @typing.overload
    def getDisplayLanguage(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayLanguage(self, locale: 'Locale') -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self, locale: 'Locale') -> java.lang.String: ...
    @typing.overload
    def getDisplayScript(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayScript(self, locale: 'Locale') -> java.lang.String: ...
    @typing.overload
    def getDisplayVariant(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayVariant(self, locale: 'Locale') -> java.lang.String: ...
    def getExtension(self, char: str) -> java.lang.String: ...
    def getExtensionKeys(self) -> 'Set'[str]: ...
    def getISO3Country(self) -> java.lang.String: ...
    def getISO3Language(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def getISOCountries(cls) -> typing.List[java.lang.String]: ...
    @classmethod
    @typing.overload
    def getISOCountries(cls, isoCountryCode: 'Locale.IsoCountryCode') -> 'Set'[java.lang.String]: ...
    @classmethod
    def getISOLanguages(cls) -> typing.List[java.lang.String]: ...
    def getLanguage(self) -> java.lang.String: ...
    def getScript(self) -> java.lang.String: ...
    def getUnicodeLocaleAttributes(self) -> 'Set'[java.lang.String]: ...
    def getUnicodeLocaleKeys(self) -> 'Set'[java.lang.String]: ...
    def getUnicodeLocaleType(self, string: java.lang.String) -> java.lang.String: ...
    def getVariant(self) -> java.lang.String: ...
    def hasExtensions(self) -> bool: ...
    def hashCode(self) -> int: ...
    @classmethod
    def lookup(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale']]) -> 'Locale': ...
    @classmethod
    def lookupTag(cls, list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[java.lang.String], typing.Sequence[java.lang.String]]) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def setDefault(cls, category: 'Locale.Category', locale: 'Locale') -> None: ...
    @classmethod
    @typing.overload
    def setDefault(cls, locale: 'Locale') -> None: ...
    def stripExtensions(self) -> 'Locale': ...
    def toLanguageTag(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    class Builder(java.lang.Object):
        """
        Java class 'java.util.Locale$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def addUnicodeLocaleAttribute(self, string: java.lang.String) -> 'Locale.Builder': ...
        def build(self) -> 'Locale': ...
        def clear(self) -> 'Locale.Builder': ...
        def clearExtensions(self) -> 'Locale.Builder': ...
        def removeUnicodeLocaleAttribute(self, string: java.lang.String) -> 'Locale.Builder': ...
        def setExtension(self, char: str, string: java.lang.String) -> 'Locale.Builder': ...
        def setLanguage(self, string: java.lang.String) -> 'Locale.Builder': ...
        def setLanguageTag(self, string: java.lang.String) -> 'Locale.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Locale.Builder': ...
        def setRegion(self, string: java.lang.String) -> 'Locale.Builder': ...
        def setScript(self, string: java.lang.String) -> 'Locale.Builder': ...
        def setUnicodeLocaleKeyword(self, string: java.lang.String, string2: java.lang.String) -> 'Locale.Builder': ...
        def setVariant(self, string: java.lang.String) -> 'Locale.Builder': ...
    class Category(java.lang.Enum[java.util.Locale.Category]):
        """
        Java class 'java.util.Locale$Category'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            DISPLAY (java.util.Locale$Category): final static enum constant
            FORMAT (java.util.Locale$Category): final static enum constant
        
        """
        DISPLAY: typing.ClassVar['Locale.Category'] = ...
        FORMAT: typing.ClassVar['Locale.Category'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Locale.Category': ...
        @classmethod
        def values(cls) -> typing.List['Locale.Category']: ...
    class FilteringMode(java.lang.Enum[java.util.Locale.FilteringMode]):
        """
        Java class 'java.util.Locale$FilteringMode'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            AUTOSELECT_FILTERING (java.util.Locale$FilteringMode): final static enum constant
            EXTENDED_FILTERING (java.util.Locale$FilteringMode): final static enum constant
            IGNORE_EXTENDED_RANGES (java.util.Locale$FilteringMode): final static enum constant
            MAP_EXTENDED_RANGES (java.util.Locale$FilteringMode): final static enum constant
            REJECT_EXTENDED_RANGES (java.util.Locale$FilteringMode): final static enum constant
        
        """
        AUTOSELECT_FILTERING: typing.ClassVar['Locale.FilteringMode'] = ...
        EXTENDED_FILTERING: typing.ClassVar['Locale.FilteringMode'] = ...
        IGNORE_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        MAP_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        REJECT_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Locale.FilteringMode': ...
        @classmethod
        def values(cls) -> typing.List['Locale.FilteringMode']: ...
    class IsoCountryCode(java.lang.Enum[java.util.Locale.IsoCountryCode]):
        """
        Java class 'java.util.Locale$IsoCountryCode'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            PART1_ALPHA2 (java.util.Locale$IsoCountryCode): final static enum constant
            PART1_ALPHA3 (java.util.Locale$IsoCountryCode): final static enum constant
            PART3 (java.util.Locale$IsoCountryCode): final static enum constant
        
        """
        PART1_ALPHA2: typing.ClassVar['Locale.IsoCountryCode'] = ...
        PART1_ALPHA3: typing.ClassVar['Locale.IsoCountryCode'] = ...
        PART3: typing.ClassVar['Locale.IsoCountryCode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Locale.IsoCountryCode': ...
        @classmethod
        def values(cls) -> typing.List['Locale.IsoCountryCode']: ...
    class LanguageRange(java.lang.Object):
        """
        Java class 'java.util.Locale$LanguageRange'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * LanguageRange(java.lang.String)
            * LanguageRange(java.lang.String, double)
        
          Attributes:
            MAX_WEIGHT (double): final static field
            MIN_WEIGHT (double): final static field
        
        """
        MAX_WEIGHT: typing.ClassVar[float] = ...
        MIN_WEIGHT: typing.ClassVar[float] = ...
        @typing.overload
        def __init__(self, string: java.lang.String): ...
        @typing.overload
        def __init__(self, string: java.lang.String, double: float): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getRange(self) -> java.lang.String: ...
        def getWeight(self) -> float: ...
        def hashCode(self) -> int: ...
        @classmethod
        def mapEquivalents(cls, list: 'List'['Locale.LanguageRange'], map: typing.Union['Map'[java.lang.String, 'List'[java.lang.String]], typing.Mapping[java.lang.String, 'List'[java.lang.String]]]) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @typing.overload
        def parse(cls, string: java.lang.String) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @typing.overload
        def parse(cls, string: java.lang.String, map: typing.Union['Map'[java.lang.String, 'List'[java.lang.String]], typing.Mapping[java.lang.String, 'List'[java.lang.String]]]) -> 'List'['Locale.LanguageRange']: ...
        def toString(self) -> java.lang.String: ...

class LongSummaryStatistics(java.util.function.LongConsumer, java.util.function.IntConsumer):
    """
    Java class 'java.util.LongSummaryStatistics'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.function.LongConsumer,
            java.util.function.IntConsumer
    
      Constructors:
        * LongSummaryStatistics()
        * LongSummaryStatistics(long, long, long, long)
    
      Raises:
        java.lang.IllegalArgumentException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int, long2: int, long3: int, long4: int): ...
    @typing.overload
    def accept(self, int: int) -> None: ...
    @typing.overload
    def accept(self, long: int) -> None: ...
    def combine(self, longSummaryStatistics: 'LongSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> java.lang.String: ...

_Map__Entry__K = typing.TypeVar('_Map__Entry__K')  # <K>
_Map__Entry__V = typing.TypeVar('_Map__Entry__V')  # <V>
_Map__K = typing.TypeVar('_Map__K')  # <K>
_Map__V = typing.TypeVar('_Map__V')  # <V>
class Map(java.lang.Object, typing.Generic[_Map__K, _Map__V]):
    """
    public interface Map<K,​V>
    
        An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.
    
        This interface takes the place of the :code:`Dictionary` class, which was a totally abstract class rather than an
        interface.
    
        The :code:`Map` interface provides three *collection views*, which allow a map's contents to be viewed as a set of keys,
        collection of values, or set of key-value mappings. The *order* of a map is defined as the order in which the iterators
        on the map's collection views return their elements. Some map implementations, like the :code:`TreeMap` class, make
        specific guarantees as to their order; others, like the :code:`HashMap` class, do not.
    
        Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if
        the value of an object is changed in a manner that affects :code:`equals` comparisons while the object is a key in the
        map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is
        permissible for a map to contain itself as a value, extreme caution is advised: the :code:`equals` and :code:`hashCode`
        methods are no longer well defined on such a map.
    
        All general-purpose map implementation classes should provide two "standard" constructors: a void (no arguments)
        constructor which creates an empty map, and a constructor with a single argument of type :code:`Map`, which creates a
        new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any
        map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces
        cannot contain constructors) but all of the general-purpose map implementations in the JDK comply.
    
        The "destructive" methods contained in this interface, that is, the methods that modify the map on which they operate,
        are specified to throw :code:`UnsupportedOperationException` if this map does not support the operation. If this is the
        case, these methods may, but are not required to, throw an :code:`UnsupportedOperationException` if the invocation would
        have no effect on the map. For example, invoking the :meth:`~java.util.Map.putAll` method on an unmodifiable map may,
        but is not required to, throw the exception if the map whose mappings are to be "superimposed" is empty.
    
        Some map implementations have restrictions on the keys and values they may contain. For example, some implementations
        prohibit null keys and values, and some have restrictions on the types of their keys. Attempting to insert an ineligible
        key or value throws an unchecked exception, typically :code:`NullPointerException` or :code:`ClassCastException`.
        Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false;
        some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an
        operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into
        the map may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as
        "optional" in the specification for this interface.
    
        Many methods in Collections Framework interfaces are defined in terms of the :meth:`~java.lang.Object.equals` method.
        For example, the specification for the :meth:`~java.util.Map.containsKey` method says: "returns :code:`true` if and only
        if this map contains a mapping for a key :code:`k` such that :code:`(key==null ? k==null : key.equals(k))`." This
        specification should *not* be construed to imply that invoking :code:`Map.containsKey` with a non-null argument
        :code:`key` will cause :code:`key.equals(k)` to be invoked for any key :code:`k`. Implementations are free to implement
        optimizations whereby the :code:`equals` invocation is avoided, for example, by first comparing the hash codes of the
        two keys. (The :meth:`~java.lang.Object.hashCode` specification guarantees that two objects with unequal hash codes
        cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take
        advantage of the specified behavior of underlying :class:`~java.lang.Object` methods wherever the implementor deems it
        appropriate.
    
        Some map operations which perform recursive traversal of the map may fail with an exception for self-referential
        instances where the map directly or indirectly contains itself. This includes the :code:`clone()`, :code:`equals()`,
        :code:`hashCode()` and :code:`toString()` methods. Implementations may optionally handle the self-referential scenario,
        however most current implementations do not do so.
    
        :class:`~java.util`
    -------------------
    
    
        The :meth:`~java.util.Map.of`, :meth:`~java.util.Map.ofEntries`, and :meth:`~java.util.Map.copyOf` static factory
        methods provide a convenient way to create unmodifiable maps. The :code:`Map` instances created by these methods have
        the following characteristics:
    
          - They are :meth:`~java.util.Collection.unmodifiable`. Keys and values cannot be added, removed, or updated. Calling any
            mutator method on the Map will always cause :code:`UnsupportedOperationException` to be thrown. However, if the
            contained keys or values are themselves mutable, this may cause the Map to behave inconsistently or its contents to
            appear to change.
          - They disallow :code:`null` keys and values. Attempts to create them with :code:`null` keys or values result in
            :code:`NullPointerException`.
          - They are serializable if all keys and values are serializable.
          - They reject duplicate keys at creation time. Duplicate keys passed to a static factory method result in
            :code:`IllegalArgumentException`.
          - The iteration order of mappings is unspecified and is subject to change.
          - They are :class:`~java.lang.doc`. Callers should make no assumptions about the identity of the returned instances.
            Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these
            instances (reference equality (:code:`==`), identity hash code, and synchronization) are unreliable and should be
            avoided.
          - They are serialized as specified on the Serialized Form page.
    
    
        This interface is a member of the :meth:`~java.util.package`.
    
        Since:
            1.2
    
        Also see:
            :class:`~java.util.HashMap`, :class:`~java.util.TreeMap`, :class:`~java.util.Hashtable`, :class:`~java.util.SortedMap`,
            :class:`~java.util.Collection`, :class:`~java.util.Set`
    
    
    """
    def clear(self) -> None: ...
    def compute(self, k: _Map__K, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> _Map__V: ...
    def computeIfAbsent(self, k: _Map__K, function: typing.Union[java.util.function.Function[_Map__K, _Map__V], typing.Callable[[_Map__K], _Map__V]]) -> _Map__V: ...
    def computeIfPresent(self, k: _Map__K, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> _Map__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _copyOf__K = typing.TypeVar('_copyOf__K')  # <K>
    _copyOf__V = typing.TypeVar('_copyOf__V')  # <V>
    @classmethod
    def copyOf(cls, map: typing.Union['Map'[_copyOf__K, _copyOf__V], typing.Mapping[_copyOf__K, _copyOf__V]]) -> 'Map'[_copyOf__K, _copyOf__V]: ...
    _entry__K = typing.TypeVar('_entry__K')  # <K>
    _entry__V = typing.TypeVar('_entry__V')  # <V>
    @classmethod
    def entry(cls, k: _entry__K, v: _entry__V) -> 'Map.Entry'[_entry__K, _entry__V]: ...
    def entrySet(self) -> 'Set'['Map.Entry'[_Map__K, _Map__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_Map__K, _Map__V], typing.Callable[[_Map__K], _Map__V]]) -> None: ...
    def get(self, object: typing.Any) -> _Map__V: ...
    def getOrDefault(self, object: typing.Any, v: _Map__V) -> _Map__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Map__K]: ...
    def merge(self, k: _Map__K, v: _Map__V, biFunction: typing.Union[java.util.function.BiFunction[_Map__V, _Map__V, _Map__V], typing.Callable[[_Map__V, _Map__V], _Map__V]]) -> _Map__V: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls) -> 'Map'[_of_0__K, _of_0__V]: ...
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_1__K, v: _of_1__V) -> 'Map'[_of_1__K, _of_1__V]: ...
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> 'Map'[_of_2__K, _of_2__V]: ...
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> 'Map'[_of_3__K, _of_3__V]: ...
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> 'Map'[_of_4__K, _of_4__V]: ...
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> 'Map'[_of_5__K, _of_5__V]: ...
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_6__K, v: _of_6__V, k2: _of_6__K, v2: _of_6__V, k3: _of_6__K, v3: _of_6__V, k4: _of_6__K, v4: _of_6__V, k5: _of_6__K, v5: _of_6__V, k6: _of_6__K, v6: _of_6__V) -> 'Map'[_of_6__K, _of_6__V]: ...
    _of_7__K = typing.TypeVar('_of_7__K')  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_7__K, v: _of_7__V, k2: _of_7__K, v2: _of_7__V, k3: _of_7__K, v3: _of_7__V, k4: _of_7__K, v4: _of_7__V, k5: _of_7__K, v5: _of_7__V, k6: _of_7__K, v6: _of_7__V, k7: _of_7__K, v7: _of_7__V) -> 'Map'[_of_7__K, _of_7__V]: ...
    _of_8__K = typing.TypeVar('_of_8__K')  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_8__K, v: _of_8__V, k2: _of_8__K, v2: _of_8__V, k3: _of_8__K, v3: _of_8__V, k4: _of_8__K, v4: _of_8__V, k5: _of_8__K, v5: _of_8__V, k6: _of_8__K, v6: _of_8__V, k7: _of_8__K, v7: _of_8__V, k8: _of_8__K, v8: _of_8__V) -> 'Map'[_of_8__K, _of_8__V]: ...
    _of_9__K = typing.TypeVar('_of_9__K')  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_9__K, v: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V, k4: _of_9__K, v4: _of_9__V, k5: _of_9__K, v5: _of_9__V, k6: _of_9__K, v6: _of_9__V, k7: _of_9__K, v7: _of_9__V, k8: _of_9__K, v8: _of_9__V, k9: _of_9__K, v9: _of_9__V) -> 'Map'[_of_9__K, _of_9__V]: ...
    _of_10__K = typing.TypeVar('_of_10__K')  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    @classmethod
    @typing.overload
    def of(cls, k: _of_10__K, v: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V, k5: _of_10__K, v5: _of_10__V, k6: _of_10__K, v6: _of_10__V, k7: _of_10__K, v7: _of_10__V, k8: _of_10__K, v8: _of_10__V, k9: _of_10__K, v9: _of_10__V, k10: _of_10__K, v10: _of_10__V) -> 'Map'[_of_10__K, _of_10__V]: ...
    _ofEntries__K = typing.TypeVar('_ofEntries__K')  # <K>
    _ofEntries__V = typing.TypeVar('_ofEntries__V')  # <V>
    @classmethod
    def ofEntries(cls, entryArray: typing.List['Map.Entry'[_ofEntries__K, _ofEntries__V]]) -> 'Map'[_ofEntries__K, _ofEntries__V]: ...
    def put(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def putAll(self, map: typing.Union['Map'[_Map__K, _Map__V], typing.Mapping[_Map__K, _Map__V]]) -> None: ...
    def putIfAbsent(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _Map__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def replace(self, k: _Map__K, v: _Map__V, v2: _Map__V) -> bool: ...
    @typing.overload
    def replace(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_Map__V]: ...
    class Entry(java.lang.Object, typing.Generic[_Map__Entry__K, _Map__Entry__V]):
        """
        Java class 'java.util.Map$Entry'
        
        """
        _comparingByKey_0__K = typing.TypeVar('_comparingByKey_0__K', bound=java.lang.Comparable)  # <K>
        _comparingByKey_0__V = typing.TypeVar('_comparingByKey_0__V')  # <V>
        @classmethod
        @typing.overload
        def comparingByKey(cls) -> Comparator['Map.Entry'[_comparingByKey_0__K, _comparingByKey_0__V]]: ...
        _comparingByKey_1__K = typing.TypeVar('_comparingByKey_1__K')  # <K>
        _comparingByKey_1__V = typing.TypeVar('_comparingByKey_1__V')  # <V>
        @classmethod
        @typing.overload
        def comparingByKey(cls, comparator: typing.Union[Comparator[_comparingByKey_1__K], typing.Callable[[], _comparingByKey_1__K]]) -> Comparator['Map.Entry'[_comparingByKey_1__K, _comparingByKey_1__V]]: ...
        _comparingByValue_0__K = typing.TypeVar('_comparingByValue_0__K')  # <K>
        _comparingByValue_0__V = typing.TypeVar('_comparingByValue_0__V', bound=java.lang.Comparable)  # <V>
        @classmethod
        @typing.overload
        def comparingByValue(cls) -> Comparator['Map.Entry'[_comparingByValue_0__K, _comparingByValue_0__V]]: ...
        _comparingByValue_1__K = typing.TypeVar('_comparingByValue_1__K')  # <K>
        _comparingByValue_1__V = typing.TypeVar('_comparingByValue_1__V')  # <V>
        @classmethod
        @typing.overload
        def comparingByValue(cls, comparator: typing.Union[Comparator[_comparingByValue_1__V], typing.Callable[[], _comparingByValue_1__V]]) -> Comparator['Map.Entry'[_comparingByValue_1__K, _comparingByValue_1__V]]: ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _Map__Entry__K: ...
        def getValue(self) -> _Map__Entry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _Map__Entry__V) -> _Map__Entry__V: ...

class MissingResourceException(java.lang.RuntimeException):
    """
    Java class 'java.util.MissingResourceException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * MissingResourceException(java.lang.String, java.lang.String, java.lang.String)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String): ...
    def getClassName(self) -> java.lang.String: ...
    def getKey(self) -> java.lang.String: ...

class NoSuchElementException(java.lang.RuntimeException):
    """
    Java class 'java.util.NoSuchElementException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * NoSuchElementException()
        * NoSuchElementException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class Objects(java.lang.Object):
    """
    Java class 'java.util.Objects'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def checkFromIndexSize(cls, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    def checkFromToIndex(cls, int: int, int2: int, int3: int) -> int: ...
    @classmethod
    def checkIndex(cls, int: int, int2: int) -> int: ...
    _compare__T = typing.TypeVar('_compare__T')  # <T>
    @classmethod
    def compare(cls, t: _compare__T, t2: _compare__T, comparator: typing.Union[Comparator[_compare__T], typing.Callable[[], _compare__T]]) -> int: ...
    @classmethod
    def deepEquals(cls, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    @typing.overload
    def equals(cls, object: typing.Any, object2: typing.Any) -> bool: ...
    @classmethod
    def hash(cls, objectArray: typing.List[typing.Any]) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @classmethod
    @typing.overload
    def hashCode(cls, object: typing.Any) -> int: ...
    @classmethod
    def isNull(cls, object: typing.Any) -> bool: ...
    @classmethod
    def nonNull(cls, object: typing.Any) -> bool: ...
    _requireNonNull_0__T = typing.TypeVar('_requireNonNull_0__T')  # <T>
    @classmethod
    @typing.overload
    def requireNonNull(cls, t: _requireNonNull_0__T) -> _requireNonNull_0__T: ...
    _requireNonNull_1__T = typing.TypeVar('_requireNonNull_1__T')  # <T>
    @classmethod
    @typing.overload
    def requireNonNull(cls, t: _requireNonNull_1__T, string: java.lang.String) -> _requireNonNull_1__T: ...
    _requireNonNull_2__T = typing.TypeVar('_requireNonNull_2__T')  # <T>
    @classmethod
    @typing.overload
    def requireNonNull(cls, t: _requireNonNull_2__T, supplier: typing.Union[java.util.function.Supplier[java.lang.String], typing.Callable[[], java.lang.String]]) -> _requireNonNull_2__T: ...
    _requireNonNullElse__T = typing.TypeVar('_requireNonNullElse__T')  # <T>
    @classmethod
    def requireNonNullElse(cls, t: _requireNonNullElse__T, t2: _requireNonNullElse__T) -> _requireNonNullElse__T: ...
    _requireNonNullElseGet__T = typing.TypeVar('_requireNonNullElseGet__T')  # <T>
    @classmethod
    def requireNonNullElseGet(cls, t: _requireNonNullElseGet__T, supplier: typing.Union[java.util.function.Supplier[_requireNonNullElseGet__T], typing.Callable[[], _requireNonNullElseGet__T]]) -> _requireNonNullElseGet__T: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, object: typing.Any) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toString(cls, object: typing.Any, string: java.lang.String) -> java.lang.String: ...

class Observable(java.lang.Object):
    """
    Java class 'java.util.Observable'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Observable()
    
    """
    def __init__(self): ...
    def addObserver(self, observer: 'Observer') -> None: ...
    def countObservers(self) -> int: ...
    def deleteObserver(self, observer: 'Observer') -> None: ...
    def deleteObservers(self) -> None: ...
    def hasChanged(self) -> bool: ...
    @typing.overload
    def notifyObservers(self) -> None: ...
    @typing.overload
    def notifyObservers(self, object: typing.Any) -> None: ...

class Observer(java.lang.Object):
    """
    :class:`~java.lang.Deprecated`(:meth:`~java.lang.Deprecated.since`="9") public interface Observer
    
        Deprecated.
        This interface has been deprecated. See the :class:`~java.util.Observable` class for further information.
        A class can implement the :code:`Observer` interface when it wants to be informed of changes in observable objects.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.util.Observable`
    
    
    """
    def update(self, observable: Observable, object: typing.Any) -> None: ...

_Optional__T = typing.TypeVar('_Optional__T')  # <T>
class Optional(java.lang.Object, typing.Generic[_Optional__T]):
    """
    Java class 'java.util.Optional'
    
        Extends:
            java.lang.Object
    
    """
    _empty__T = typing.TypeVar('_empty__T')  # <T>
    @classmethod
    def empty(cls) -> 'Optional'[_empty__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[_Optional__T], typing.Callable[[], _Optional__T]]) -> 'Optional'[_Optional__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, function: typing.Union[java.util.function.Function[_Optional__T, 'Optional'[_flatMap__U]], typing.Callable[[_Optional__T], 'Optional'[_flatMap__U]]]) -> 'Optional'[_flatMap__U]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, consumer: typing.Union[java.util.function.Consumer[_Optional__T], typing.Callable[[], _Optional__T]]) -> None: ...
    def ifPresentOrElse(self, consumer: typing.Union[java.util.function.Consumer[_Optional__T], typing.Callable[[], _Optional__T]], runnable: java.lang.Runnable) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, function: typing.Union[java.util.function.Function[_Optional__T, _map__U], typing.Callable[[_Optional__T], _map__U]]) -> 'Optional'[_map__U]: ...
    _of__T = typing.TypeVar('_of__T')  # <T>
    @classmethod
    def of(cls, t: _of__T) -> 'Optional'[_of__T]: ...
    _ofNullable__T = typing.TypeVar('_ofNullable__T')  # <T>
    @classmethod
    def ofNullable(cls, t: _ofNullable__T) -> 'Optional'[_ofNullable__T]: ...
    def orElse(self, t: _Optional__T) -> _Optional__T: ...
    def orElseGet(self, supplier: typing.Union[java.util.function.Supplier[_Optional__T], typing.Callable[[], _Optional__T]]) -> _Optional__T: ...
    @typing.overload
    def orElseThrow(self) -> _Optional__T: ...
    _orElseThrow_1__X = typing.TypeVar('_orElseThrow_1__X', bound=java.lang.Throwable)  # <X>
    @typing.overload
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow_1__X], typing.Callable[[], _orElseThrow_1__X]]) -> _Optional__T: ...
    def stream(self) -> java.util.stream.Stream[_Optional__T]: ...
    def toString(self) -> java.lang.String: ...

class OptionalDouble(java.lang.Object):
    """
    Java class 'java.util.OptionalDouble'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def empty(cls) -> 'OptionalDouble': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsDouble(self) -> float: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
    def ifPresentOrElse(self, doubleConsumer: java.util.function.DoubleConsumer, runnable: java.lang.Runnable) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, double: float) -> 'OptionalDouble': ...
    def orElse(self, double: float) -> float: ...
    def orElseGet(self, doubleSupplier: java.util.function.DoubleSupplier) -> float: ...
    @typing.overload
    def orElseThrow(self) -> float: ...
    _orElseThrow_1__X = typing.TypeVar('_orElseThrow_1__X', bound=java.lang.Throwable)  # <X>
    @typing.overload
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow_1__X], typing.Callable[[], _orElseThrow_1__X]]) -> float: ...
    def stream(self) -> java.util.stream.DoubleStream: ...
    def toString(self) -> java.lang.String: ...

class OptionalInt(java.lang.Object):
    """
    Java class 'java.util.OptionalInt'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def empty(cls) -> 'OptionalInt': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsInt(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, intConsumer: java.util.function.IntConsumer) -> None: ...
    def ifPresentOrElse(self, intConsumer: java.util.function.IntConsumer, runnable: java.lang.Runnable) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, int: int) -> 'OptionalInt': ...
    def orElse(self, int: int) -> int: ...
    def orElseGet(self, intSupplier: java.util.function.IntSupplier) -> int: ...
    @typing.overload
    def orElseThrow(self) -> int: ...
    _orElseThrow_1__X = typing.TypeVar('_orElseThrow_1__X', bound=java.lang.Throwable)  # <X>
    @typing.overload
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow_1__X], typing.Callable[[], _orElseThrow_1__X]]) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toString(self) -> java.lang.String: ...

class OptionalLong(java.lang.Object):
    """
    Java class 'java.util.OptionalLong'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def empty(cls) -> 'OptionalLong': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsLong(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, longConsumer: java.util.function.LongConsumer) -> None: ...
    def ifPresentOrElse(self, longConsumer: java.util.function.LongConsumer, runnable: java.lang.Runnable) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, long: int) -> 'OptionalLong': ...
    def orElse(self, long: int) -> int: ...
    def orElseGet(self, longSupplier: java.util.function.LongSupplier) -> int: ...
    @typing.overload
    def orElseThrow(self) -> int: ...
    _orElseThrow_1__X = typing.TypeVar('_orElseThrow_1__X', bound=java.lang.Throwable)  # <X>
    @typing.overload
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow_1__X], typing.Callable[[], _orElseThrow_1__X]]) -> int: ...
    def stream(self) -> java.util.stream.LongStream: ...
    def toString(self) -> java.lang.String: ...

class PropertyPermission(java.security.BasicPermission):
    """
    Java class 'java.util.PropertyPermission'
    
        Extends:
            java.security.BasicPermission
    
      Constructors:
        * PropertyPermission(java.lang.String, java.lang.String)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class Random(java.io.Serializable):
    """
    Java class 'java.util.Random'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * Random()
        * Random(long)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, byteArray: typing.List[int]) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    def nextLong(self) -> int: ...
    def setSeed(self, long: int) -> None: ...

class RandomAccess(java.lang.Object):
    """
    public interface RandomAccess
    
        Marker interface used by :code:`List` implementations to indicate that they support fast (generally constant time)
        random access. The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide
        good performance when applied to either random or sequential access lists.
    
        The best algorithms for manipulating random access lists (such as :code:`ArrayList`) can produce quadratic behavior when
        applied to sequential access lists (such as :code:`LinkedList`). Generic list algorithms are encouraged to check whether
        the given list is an :code:`instanceof` this interface before applying an algorithm that would provide poor performance
        if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable
        performance.
    
        It is recognized that the distinction between random and sequential access is often fuzzy. For example, some
        :code:`List` implementations provide asymptotically linear access times if they get huge, but constant access times in
        practice. Such a :code:`List` implementation should generally implement this interface. As a rule of thumb, a
        :code:`List` implementation should implement this interface if, for typical instances of the class, this loop:
    
        .. code-block: java
        
             for (int i=0, n=list.size(); i < n; i++)
                 list.get(i);
         
        runs faster than this loop:
    
        .. code-block: java
        
             for (Iterator i=list.iterator(); i.hasNext(); )
                 i.next();
         
    
        This interface is a member of the :meth:`~java.util.package`.
    
        Since:
            1.4
    
    
    """

class ResourceBundle(java.lang.Object):
    """
    Java class 'java.util.ResourceBundle'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ResourceBundle()
    
    """
    def __init__(self): ...
    @classmethod
    @typing.overload
    def clearCache(cls) -> None: ...
    @classmethod
    @typing.overload
    def clearCache(cls, classLoader: java.lang.ClassLoader) -> None: ...
    def containsKey(self, string: java.lang.String) -> bool: ...
    def getBaseBundleName(self) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String) -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, locale: Locale) -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, locale: Locale, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, module: java.lang.Module) -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, locale: Locale, classLoader: java.lang.ClassLoader) -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, locale: Locale, classLoader: java.lang.ClassLoader, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @typing.overload
    def getBundle(cls, string: java.lang.String, locale: Locale, module: java.lang.Module) -> 'ResourceBundle': ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def getLocale(self) -> Locale: ...
    def getObject(self, string: java.lang.String) -> typing.Any: ...
    def getString(self, string: java.lang.String) -> java.lang.String: ...
    def getStringArray(self, string: java.lang.String) -> typing.List[java.lang.String]: ...
    def keySet(self) -> 'Set'[java.lang.String]: ...
    class Control(java.lang.Object):
        """
        Java class 'java.util.ResourceBundle$Control'
        
            Extends:
                java.lang.Object
        
          Attributes:
            FORMAT_DEFAULT (java.util.List): final static field
            FORMAT_CLASS (java.util.List): final static field
            FORMAT_PROPERTIES (java.util.List): final static field
            TTL_DONT_CACHE (long): final static field
            TTL_NO_EXPIRATION_CONTROL (long): final static field
        
        """
        FORMAT_DEFAULT: typing.ClassVar['List'] = ...
        FORMAT_CLASS: typing.ClassVar['List'] = ...
        FORMAT_PROPERTIES: typing.ClassVar['List'] = ...
        TTL_DONT_CACHE: typing.ClassVar[int] = ...
        TTL_NO_EXPIRATION_CONTROL: typing.ClassVar[int] = ...
        def getCandidateLocales(self, string: java.lang.String, locale: Locale) -> 'List'[Locale]: ...
        @classmethod
        def getControl(cls, list: 'List'[java.lang.String]) -> 'ResourceBundle.Control': ...
        def getFallbackLocale(self, string: java.lang.String, locale: Locale) -> Locale: ...
        def getFormats(self, string: java.lang.String) -> 'List'[java.lang.String]: ...
        @classmethod
        def getNoFallbackControl(cls, list: 'List'[java.lang.String]) -> 'ResourceBundle.Control': ...
        def getTimeToLive(self, string: java.lang.String, locale: Locale) -> int: ...
        def needsReload(self, string: java.lang.String, locale: Locale, string2: java.lang.String, classLoader: java.lang.ClassLoader, resourceBundle: 'ResourceBundle', long: int) -> bool: ...
        def newBundle(self, string: java.lang.String, locale: Locale, string2: java.lang.String, classLoader: java.lang.ClassLoader, boolean: bool) -> 'ResourceBundle': ...
        def toBundleName(self, string: java.lang.String, locale: Locale) -> java.lang.String: ...
        def toResourceName(self, string: java.lang.String, string2: java.lang.String) -> java.lang.String: ...

class ServiceConfigurationError(java.lang.Error):
    """
    Java class 'java.util.ServiceConfigurationError'
    
        Extends:
            java.lang.Error
    
      Constructors:
        * ServiceConfigurationError(java.lang.String)
        * ServiceConfigurationError(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...

_ServiceLoader__Provider__S = typing.TypeVar('_ServiceLoader__Provider__S')  # <S>
_ServiceLoader__S = typing.TypeVar('_ServiceLoader__S')  # <S>
class ServiceLoader(java.lang.Iterable[_ServiceLoader__S], typing.Generic[_ServiceLoader__S]):
    """
    Java class 'java.util.ServiceLoader'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Iterable
    
    """
    def findFirst(self) -> Optional[_ServiceLoader__S]: ...
    def iterator(self) -> Iterator[_ServiceLoader__S]: ...
    _load_0__S = typing.TypeVar('_load_0__S')  # <S>
    @classmethod
    @typing.overload
    def load(cls, class_: typing.Type[_load_0__S]) -> 'ServiceLoader'[_load_0__S]: ...
    _load_1__S = typing.TypeVar('_load_1__S')  # <S>
    @classmethod
    @typing.overload
    def load(cls, class_: typing.Type[_load_1__S], classLoader: java.lang.ClassLoader) -> 'ServiceLoader'[_load_1__S]: ...
    _load_2__S = typing.TypeVar('_load_2__S')  # <S>
    @classmethod
    @typing.overload
    def load(cls, moduleLayer: java.lang.ModuleLayer, class_: typing.Type[_load_2__S]) -> 'ServiceLoader'[_load_2__S]: ...
    _loadInstalled__S = typing.TypeVar('_loadInstalled__S')  # <S>
    @classmethod
    def loadInstalled(cls, class_: typing.Type[_loadInstalled__S]) -> 'ServiceLoader'[_loadInstalled__S]: ...
    def reload(self) -> None: ...
    def stream(self) -> java.util.stream.Stream['ServiceLoader.Provider'[_ServiceLoader__S]]: ...
    def toString(self) -> java.lang.String: ...
    class Provider(java.util.function.Supplier[_ServiceLoader__Provider__S], typing.Generic[_ServiceLoader__Provider__S]):
        """
        Java class 'java.util.ServiceLoader$Provider'
        
            Interfaces:
                java.util.function.Supplier
        
        """
        def get(self) -> _ServiceLoader__Provider__S: ...
        def type(self) -> typing.Type[_ServiceLoader__Provider__S]: ...

class SplittableRandom(java.lang.Object):
    """
    Java class 'java.util.SplittableRandom'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * SplittableRandom(long)
        * SplittableRandom()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def nextDouble(self) -> float: ...
    @typing.overload
    def nextDouble(self, double: float) -> float: ...
    @typing.overload
    def nextDouble(self, double: float, double2: float) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    @typing.overload
    def nextInt(self, int: int, int2: int) -> int: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, long: int) -> int: ...
    @typing.overload
    def nextLong(self, long: int, long2: int) -> int: ...
    def split(self) -> 'SplittableRandom': ...

class StringJoiner(java.lang.Object):
    """
    Java class 'java.util.StringJoiner'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * StringJoiner(java.lang.CharSequence)
        * StringJoiner(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence)
    
    """
    @typing.overload
    def __init__(self, charSequence: java.lang.CharSequence): ...
    @typing.overload
    def __init__(self, charSequence: java.lang.CharSequence, charSequence2: java.lang.CharSequence, charSequence3: java.lang.CharSequence): ...
    def add(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def length(self) -> int: ...
    def merge(self, stringJoiner: 'StringJoiner') -> 'StringJoiner': ...
    def setEmptyValue(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def toString(self) -> java.lang.String: ...

class TimeZone(java.io.Serializable, java.lang.Cloneable):
    """
    Java class 'java.util.TimeZone'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Cloneable
    
      Constructors:
        * TimeZone()
    
      Attributes:
        SHORT (int): final static field
        LONG (int): final static field
    
    """
    SHORT: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    def __init__(self): ...
    def clone(self) -> typing.Any: ...
    @classmethod
    @typing.overload
    def getAvailableIDs(cls) -> typing.List[java.lang.String]: ...
    @classmethod
    @typing.overload
    def getAvailableIDs(cls, int: int) -> typing.List[java.lang.String]: ...
    def getDSTSavings(self) -> int: ...
    @classmethod
    def getDefault(cls) -> 'TimeZone': ...
    @typing.overload
    def getDisplayName(self) -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self, boolean: bool, int: int) -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self, locale: Locale) -> java.lang.String: ...
    @typing.overload
    def getDisplayName(self, boolean: bool, int: int, locale: Locale) -> java.lang.String: ...
    def getID(self) -> java.lang.String: ...
    @typing.overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @typing.overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    @classmethod
    @typing.overload
    def getTimeZone(cls, zoneId: java.time.ZoneId) -> 'TimeZone': ...
    @classmethod
    @typing.overload
    def getTimeZone(cls, string: java.lang.String) -> 'TimeZone': ...
    def hasSameRules(self, timeZone: 'TimeZone') -> bool: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    @classmethod
    def setDefault(cls, timeZone: 'TimeZone') -> None: ...
    def setID(self, string: java.lang.String) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    def toZoneId(self) -> java.time.ZoneId: ...
    def useDaylightTime(self) -> bool: ...

class Timer(java.lang.Object):
    """
    Java class 'java.util.Timer'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Timer(java.lang.String)
        * Timer(boolean)
        * Timer()
        * Timer(java.lang.String, boolean)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, boolean: bool): ...
    def cancel(self) -> None: ...
    def purge(self) -> int: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', date: Date) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', long: int) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...

class TimerTask(java.lang.Runnable):
    """
    Java class 'java.util.TimerTask'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Runnable
    
    """
    def cancel(self) -> bool: ...
    def run(self) -> None: ...
    def scheduledExecutionTime(self) -> int: ...

class TooManyListenersException(java.lang.Exception):
    """
    Java class 'java.util.TooManyListenersException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * TooManyListenersException()
        * TooManyListenersException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class UUID(java.io.Serializable, java.lang.Comparable[java.util.UUID]):
    """
    Java class 'java.util.UUID'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable, java.lang.Comparable
    
      Constructors:
        * UUID(long, long)
    
    """
    def __init__(self, long: int, long2: int): ...
    def clockSequence(self) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, uUID: 'UUID') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def fromString(cls, string: java.lang.String) -> 'UUID': ...
    def getLeastSignificantBits(self) -> int: ...
    def getMostSignificantBits(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def nameUUIDFromBytes(cls, byteArray: typing.List[int]) -> 'UUID': ...
    def node(self) -> int: ...
    @classmethod
    def randomUUID(cls) -> 'UUID': ...
    def timestamp(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def variant(self) -> int: ...
    def version(self) -> int: ...

_AbstractCollection__E = typing.TypeVar('_AbstractCollection__E')  # <E>
class AbstractCollection(Collection[_AbstractCollection__E], typing.Generic[_AbstractCollection__E]):
    """
    Java class 'java.util.AbstractCollection'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Collection
    
    """
    def add(self, e: _AbstractCollection__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_AbstractCollection__E], typing.Sequence[_AbstractCollection__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_AbstractCollection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...

_AbstractMap__SimpleEntry__K = typing.TypeVar('_AbstractMap__SimpleEntry__K')  # <K>
_AbstractMap__SimpleEntry__V = typing.TypeVar('_AbstractMap__SimpleEntry__V')  # <V>
_AbstractMap__SimpleImmutableEntry__K = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__K')  # <K>
_AbstractMap__SimpleImmutableEntry__V = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__V')  # <V>
_AbstractMap__K = typing.TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = typing.TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(Map[_AbstractMap__K, _AbstractMap__V], typing.Generic[_AbstractMap__K, _AbstractMap__V]):
    """
    Java class 'java.util.AbstractMap'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Map
    
    """
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> 'Set'[Map.Entry[_AbstractMap__K, _AbstractMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _AbstractMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_AbstractMap__K]: ...
    def put(self, k: _AbstractMap__K, v: _AbstractMap__V) -> _AbstractMap__V: ...
    def putAll(self, map: typing.Union[Map[_AbstractMap__K, _AbstractMap__V], typing.Mapping[_AbstractMap__K, _AbstractMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _AbstractMap__V: ...
    def size(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def values(self) -> Collection[_AbstractMap__V]: ...
    class SimpleEntry(Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]):
        """
        Java class 'java.util.AbstractMap$SimpleEntry'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Map.Entry, java.io.Serializable
        
          Constructors:
            * SimpleEntry(java.lang.Object, java.lang.Object)
            * SimpleEntry(java.util.Map.Entry)
        
        """
        @typing.overload
        def __init__(self, k: _AbstractMap__SimpleEntry__K, v: _AbstractMap__SimpleEntry__V): ...
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleEntry__V) -> _AbstractMap__SimpleEntry__V: ...
        def toString(self) -> java.lang.String: ...
    class SimpleImmutableEntry(Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]):
        """
        Java class 'java.util.AbstractMap$SimpleImmutableEntry'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Map.Entry, java.io.Serializable
        
          Constructors:
            * SimpleImmutableEntry(java.lang.Object, java.lang.Object)
            * SimpleImmutableEntry(java.util.Map.Entry)
        
        """
        @typing.overload
        def __init__(self, k: _AbstractMap__SimpleImmutableEntry__K, v: _AbstractMap__SimpleImmutableEntry__V): ...
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleImmutableEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleImmutableEntry__V) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def toString(self) -> java.lang.String: ...

class DuplicateFormatFlagsException(IllegalFormatException):
    """
    Java class 'java.util.DuplicateFormatFlagsException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * DuplicateFormatFlagsException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getFlags(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

_EventListenerProxy__T = typing.TypeVar('_EventListenerProxy__T', bound=EventListener)  # <T>
class EventListenerProxy(EventListener, typing.Generic[_EventListenerProxy__T]):
    """
    Java class 'java.util.EventListenerProxy'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.EventListener
    
      Constructors:
        * EventListenerProxy(java.util.EventListener)
    
    """
    def __init__(self, t: _EventListenerProxy__T): ...
    def getListener(self) -> _EventListenerProxy__T: ...

class FormatFlagsConversionMismatchException(IllegalFormatException):
    """
    Java class 'java.util.FormatFlagsConversionMismatchException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * FormatFlagsConversionMismatchException(java.lang.String, char)
    
    """
    def __init__(self, string: java.lang.String, char: str): ...
    def getConversion(self) -> str: ...
    def getFlags(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

class GregorianCalendar(Calendar):
    """
    Java class 'java.util.GregorianCalendar'
    
        Extends:
            java.util.Calendar
    
      Constructors:
        * GregorianCalendar(int, int, int)
        * GregorianCalendar(int, int, int, int, int)
        * GregorianCalendar(int, int, int, int, int, int)
        * GregorianCalendar()
        * GregorianCalendar(java.util.TimeZone)
        * GregorianCalendar(java.util.Locale)
        * GregorianCalendar(java.util.TimeZone, java.util.Locale)
    
      Attributes:
        BC (int): final static field
        AD (int): final static field
    
    """
    BC: typing.ClassVar[int] = ...
    AD: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @typing.overload
    def __init__(self, locale: Locale): ...
    @typing.overload
    def __init__(self, timeZone: TimeZone): ...
    @typing.overload
    def __init__(self, timeZone: TimeZone, locale: Locale): ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getGregorianChange(self) -> Date: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def roll(self, int: int, int2: int) -> None: ...
    def setGregorianChange(self, date: Date) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...

_Hashtable__K = typing.TypeVar('_Hashtable__K')  # <K>
_Hashtable__V = typing.TypeVar('_Hashtable__V')  # <V>
class Hashtable(Dictionary[_Hashtable__K, _Hashtable__V], Map[_Hashtable__K, _Hashtable__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_Hashtable__K, _Hashtable__V]):
    """
    Java class 'java.util.Hashtable'
    
        Extends:
            java.util.Dictionary
    
        Interfaces:
            java.util.Map, java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * Hashtable(java.util.Map)
        * Hashtable()
        * Hashtable(int)
        * Hashtable(int, float)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_Hashtable__K, _Hashtable__V], typing.Mapping[_Hashtable__K, _Hashtable__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def compute(self, k: _Hashtable__K, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def computeIfAbsent(self, k: _Hashtable__K, function: typing.Union[java.util.function.Function[_Hashtable__K, _Hashtable__V], typing.Callable[[_Hashtable__K], _Hashtable__V]]) -> _Hashtable__V: ...
    def computeIfPresent(self, k: _Hashtable__K, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def elements(self) -> Enumeration[_Hashtable__V]: ...
    def entrySet(self) -> 'Set'[Map.Entry[_Hashtable__K, _Hashtable__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_Hashtable__K, _Hashtable__V], typing.Callable[[_Hashtable__K], _Hashtable__V]]) -> None: ...
    def get(self, object: typing.Any) -> _Hashtable__V: ...
    def getOrDefault(self, object: typing.Any, v: _Hashtable__V) -> _Hashtable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Hashtable__K]: ...
    def keys(self) -> Enumeration[_Hashtable__K]: ...
    def merge(self, k: _Hashtable__K, v: _Hashtable__V, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__V, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__V, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def put(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def putAll(self, map: typing.Union[Map[_Hashtable__K, _Hashtable__V], typing.Mapping[_Hashtable__K, _Hashtable__V]]) -> None: ...
    def putIfAbsent(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _Hashtable__V: ...
    @typing.overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V, v2: _Hashtable__V) -> bool: ...
    @typing.overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def values(self) -> Collection[_Hashtable__V]: ...

class IllegalFormatCodePointException(IllegalFormatException):
    """
    Java class 'java.util.IllegalFormatCodePointException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * IllegalFormatCodePointException(int)
    
    """
    def __init__(self, int: int): ...
    def getCodePoint(self) -> int: ...
    def getMessage(self) -> java.lang.String: ...

class IllegalFormatConversionException(IllegalFormatException):
    """
    Java class 'java.util.IllegalFormatConversionException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * IllegalFormatConversionException(char, java.lang.Class)
    
    """
    def __init__(self, char: str, class_: typing.Type[typing.Any]): ...
    def getArgumentClass(self) -> typing.Type[typing.Any]: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> java.lang.String: ...

class IllegalFormatFlagsException(IllegalFormatException):
    """
    Java class 'java.util.IllegalFormatFlagsException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * IllegalFormatFlagsException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getFlags(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

class IllegalFormatPrecisionException(IllegalFormatException):
    """
    Java class 'java.util.IllegalFormatPrecisionException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * IllegalFormatPrecisionException(int)
    
    """
    def __init__(self, int: int): ...
    def getMessage(self) -> java.lang.String: ...
    def getPrecision(self) -> int: ...

class IllegalFormatWidthException(IllegalFormatException):
    """
    Java class 'java.util.IllegalFormatWidthException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * IllegalFormatWidthException(int)
    
    """
    def __init__(self, int: int): ...
    def getMessage(self) -> java.lang.String: ...
    def getWidth(self) -> int: ...

class InputMismatchException(NoSuchElementException):
    """
    Java class 'java.util.InputMismatchException'
    
        Extends:
            java.util.NoSuchElementException
    
      Constructors:
        * InputMismatchException()
        * InputMismatchException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

_List__E = typing.TypeVar('_List__E')  # <E>
class List(Collection[_List__E], typing.Generic[_List__E]):
    """
    Java class 'java.util.List'
    
        Interfaces:
            java.util.Collection
    
    """
    @typing.overload
    def add(self, e: _List__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _List__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_List__E], typing.Sequence[_List__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_List__E], typing.Sequence[_List__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _copyOf__E = typing.TypeVar('_copyOf__E')  # <E>
    @classmethod
    def copyOf(cls, collection: typing.Union[Collection[_copyOf__E], typing.Sequence[_copyOf__E]]) -> 'List'[_copyOf__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _List__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_List__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> 'ListIterator'[_List__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> 'ListIterator'[_List__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls) -> 'List'[_of_0__E]: ...
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_1__E) -> 'List'[_of_1__E]: ...
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_2__E, e2: _of_2__E) -> 'List'[_of_2__E]: ...
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> 'List'[_of_3__E]: ...
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> 'List'[_of_4__E]: ...
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'List'[_of_5__E]: ...
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E) -> 'List'[_of_6__E]: ...
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_7__E, e2: _of_7__E, e3: _of_7__E, e4: _of_7__E, e5: _of_7__E, e6: _of_7__E, e7: _of_7__E) -> 'List'[_of_7__E]: ...
    _of_8__E = typing.TypeVar('_of_8__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_8__E, e2: _of_8__E, e3: _of_8__E, e4: _of_8__E, e5: _of_8__E, e6: _of_8__E, e7: _of_8__E, e8: _of_8__E) -> 'List'[_of_8__E]: ...
    _of_9__E = typing.TypeVar('_of_9__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_9__E, e2: _of_9__E, e3: _of_9__E, e4: _of_9__E, e5: _of_9__E, e6: _of_9__E, e7: _of_9__E, e8: _of_9__E, e9: _of_9__E) -> 'List'[_of_9__E]: ...
    _of_10__E = typing.TypeVar('_of_10__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_10__E, e2: _of_10__E, e3: _of_10__E, e4: _of_10__E, e5: _of_10__E, e6: _of_10__E, e7: _of_10__E, e8: _of_10__E, e9: _of_10__E, e10: _of_10__E) -> 'List'[_of_10__E]: ...
    _of_11__E = typing.TypeVar('_of_11__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, eArray: typing.List[_of_11__E]) -> 'List'[_of_11__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_List__E], typing.Callable[[], _List__E]]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _List__E) -> _List__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_List__E], typing.Callable[[], _List__E]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_List__E]: ...
    def subList(self, int: int, int2: int) -> 'List'[_List__E]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_2__T]], typing.Callable[[], typing.List[_toArray_2__T]]]) -> typing.List[_toArray_2__T]: ...

_ListIterator__E = typing.TypeVar('_ListIterator__E')  # <E>
class ListIterator(Iterator[_ListIterator__E], typing.Generic[_ListIterator__E]):
    """
    Java class 'java.util.ListIterator'
    
        Interfaces:
            java.util.Iterator
    
    """
    def add(self, e: _ListIterator__E) -> None: ...
    def hasNext(self) -> bool: ...
    def hasPrevious(self) -> bool: ...
    def next(self) -> _ListIterator__E: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ListIterator__E: ...
    def previousIndex(self) -> int: ...
    def remove(self) -> None: ...
    def set(self, e: _ListIterator__E) -> None: ...

class ListResourceBundle(ResourceBundle):
    """
    Java class 'java.util.ListResourceBundle'
    
        Extends:
            java.util.ResourceBundle
    
      Constructors:
        * ListResourceBundle()
    
    """
    def __init__(self): ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def handleGetObject(self, string: java.lang.String) -> typing.Any: ...

class MissingFormatArgumentException(IllegalFormatException):
    """
    Java class 'java.util.MissingFormatArgumentException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * MissingFormatArgumentException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getFormatSpecifier(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

class MissingFormatWidthException(IllegalFormatException):
    """
    Java class 'java.util.MissingFormatWidthException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * MissingFormatWidthException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getFormatSpecifier(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

class PropertyResourceBundle(ResourceBundle):
    """
    Java class 'java.util.PropertyResourceBundle'
    
        Extends:
            java.util.ResourceBundle
    
      Constructors:
        * PropertyResourceBundle(java.io.InputStream)
        * PropertyResourceBundle(java.io.Reader)
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader): ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def handleGetObject(self, string: java.lang.String) -> typing.Any: ...

_Queue__E = typing.TypeVar('_Queue__E')  # <E>
class Queue(Collection[_Queue__E], typing.Generic[_Queue__E]):
    """
    Java class 'java.util.Queue'
    
        Interfaces:
            java.util.Collection
    
    """
    def add(self, e: _Queue__E) -> bool: ...
    def element(self) -> _Queue__E: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def offer(self, e: _Queue__E) -> bool: ...
    def peek(self) -> _Queue__E: ...
    def poll(self) -> _Queue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _Queue__E: ...

class Scanner(Iterator[java.lang.String], java.io.Closeable):
    """
    Java class 'java.util.Scanner'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Iterator, java.io.Closeable
    
      Constructors:
        * Scanner(java.nio.file.Path, java.lang.String)
        * Scanner(java.io.InputStream, java.nio.charset.Charset)
        * Scanner(java.io.InputStream)
        * Scanner(java.io.InputStream, java.lang.String)
        * Scanner(java.io.File, java.lang.String)
        * Scanner(java.io.File)
        * Scanner(java.nio.file.Path)
        * Scanner(java.nio.channels.ReadableByteChannel)
        * Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)
        * Scanner(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset)
        * Scanner(java.io.File, java.nio.charset.Charset)
        * Scanner(java.lang.Readable)
        * Scanner(java.nio.file.Path, java.nio.charset.Charset)
        * Scanner(java.lang.String)
    
      Raises:
        java.io.IOException: from java
        java.io.FileNotFoundException: from java
    
    """
    @typing.overload
    def __init__(self, file: java.io.File): ...
    @typing.overload
    def __init__(self, file: java.io.File, string: java.lang.String): ...
    @typing.overload
    def __init__(self, file: java.io.File, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, string: java.lang.String): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, readable: java.lang.Readable): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel): ...
    @typing.overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel, string: java.lang.String): ...
    @typing.overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel, charset: java.nio.charset.Charset): ...
    @typing.overload
    def __init__(self, path: java.nio.file.Path): ...
    @typing.overload
    def __init__(self, path: java.nio.file.Path, string: java.lang.String): ...
    @typing.overload
    def __init__(self, path: java.nio.file.Path, charset: java.nio.charset.Charset): ...
    def close(self) -> None: ...
    def delimiter(self) -> java.util.regex.Pattern: ...
    @typing.overload
    def findAll(self, string: java.lang.String) -> java.util.stream.Stream[java.util.regex.MatchResult]: ...
    @typing.overload
    def findAll(self, pattern: java.util.regex.Pattern) -> java.util.stream.Stream[java.util.regex.MatchResult]: ...
    @typing.overload
    def findInLine(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def findInLine(self, pattern: java.util.regex.Pattern) -> java.lang.String: ...
    @typing.overload
    def findWithinHorizon(self, string: java.lang.String, int: int) -> java.lang.String: ...
    @typing.overload
    def findWithinHorizon(self, pattern: java.util.regex.Pattern, int: int) -> java.lang.String: ...
    @typing.overload
    def hasNext(self) -> bool: ...
    @typing.overload
    def hasNext(self, string: java.lang.String) -> bool: ...
    @typing.overload
    def hasNext(self, pattern: java.util.regex.Pattern) -> bool: ...
    def hasNextBigDecimal(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self, int: int) -> bool: ...
    def hasNextBoolean(self) -> bool: ...
    @typing.overload
    def hasNextByte(self) -> bool: ...
    @typing.overload
    def hasNextByte(self, int: int) -> bool: ...
    def hasNextDouble(self) -> bool: ...
    def hasNextFloat(self) -> bool: ...
    @typing.overload
    def hasNextInt(self) -> bool: ...
    @typing.overload
    def hasNextInt(self, int: int) -> bool: ...
    def hasNextLine(self) -> bool: ...
    @typing.overload
    def hasNextLong(self) -> bool: ...
    @typing.overload
    def hasNextLong(self, int: int) -> bool: ...
    @typing.overload
    def hasNextShort(self) -> bool: ...
    @typing.overload
    def hasNextShort(self, int: int) -> bool: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def match(self) -> java.util.regex.MatchResult: ...
    @typing.overload
    def next(self) -> typing.Any: ...
    @typing.overload
    def next(self) -> java.lang.String: ...
    @typing.overload
    def next(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def next(self, pattern: java.util.regex.Pattern) -> java.lang.String: ...
    def nextBigDecimal(self) -> java.math.BigDecimal: ...
    @typing.overload
    def nextBigInteger(self) -> java.math.BigInteger: ...
    @typing.overload
    def nextBigInteger(self, int: int) -> java.math.BigInteger: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextByte(self) -> int: ...
    @typing.overload
    def nextByte(self, int: int) -> int: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    def nextLine(self) -> java.lang.String: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, int: int) -> int: ...
    @typing.overload
    def nextShort(self) -> int: ...
    @typing.overload
    def nextShort(self, int: int) -> int: ...
    def radix(self) -> int: ...
    def remove(self) -> None: ...
    def reset(self) -> 'Scanner': ...
    @typing.overload
    def skip(self, string: java.lang.String) -> 'Scanner': ...
    @typing.overload
    def skip(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def toString(self) -> java.lang.String: ...
    def tokens(self) -> java.util.stream.Stream[java.lang.String]: ...
    @typing.overload
    def useDelimiter(self, string: java.lang.String) -> 'Scanner': ...
    @typing.overload
    def useDelimiter(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def useLocale(self, locale: Locale) -> 'Scanner': ...
    def useRadix(self, int: int) -> 'Scanner': ...

_Set__E = typing.TypeVar('_Set__E')  # <E>
class Set(Collection[_Set__E], typing.Generic[_Set__E]):
    """
    Java class 'java.util.Set'
    
        Interfaces:
            java.util.Collection
    
    """
    def add(self, e: _Set__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_Set__E], typing.Sequence[_Set__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _copyOf__E = typing.TypeVar('_copyOf__E')  # <E>
    @classmethod
    def copyOf(cls, collection: typing.Union[Collection[_copyOf__E], typing.Sequence[_copyOf__E]]) -> 'Set'[_copyOf__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Set__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls) -> 'Set'[_of_0__E]: ...
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_1__E) -> 'Set'[_of_1__E]: ...
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_2__E, e2: _of_2__E) -> 'Set'[_of_2__E]: ...
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> 'Set'[_of_3__E]: ...
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> 'Set'[_of_4__E]: ...
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'Set'[_of_5__E]: ...
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E) -> 'Set'[_of_6__E]: ...
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_7__E, e2: _of_7__E, e3: _of_7__E, e4: _of_7__E, e5: _of_7__E, e6: _of_7__E, e7: _of_7__E) -> 'Set'[_of_7__E]: ...
    _of_8__E = typing.TypeVar('_of_8__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_8__E, e2: _of_8__E, e3: _of_8__E, e4: _of_8__E, e5: _of_8__E, e6: _of_8__E, e7: _of_8__E, e8: _of_8__E) -> 'Set'[_of_8__E]: ...
    _of_9__E = typing.TypeVar('_of_9__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_9__E, e2: _of_9__E, e3: _of_9__E, e4: _of_9__E, e5: _of_9__E, e6: _of_9__E, e7: _of_9__E, e8: _of_9__E, e9: _of_9__E) -> 'Set'[_of_9__E]: ...
    _of_10__E = typing.TypeVar('_of_10__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_10__E, e2: _of_10__E, e3: _of_10__E, e4: _of_10__E, e5: _of_10__E, e6: _of_10__E, e7: _of_10__E, e8: _of_10__E, e9: _of_10__E, e10: _of_10__E) -> 'Set'[_of_10__E]: ...
    _of_11__E = typing.TypeVar('_of_11__E')  # <E>
    @classmethod
    @typing.overload
    def of(cls, eArray: typing.List[_of_11__E]) -> 'Set'[_of_11__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Set__E]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_2__T]], typing.Callable[[], typing.List[_toArray_2__T]]]) -> typing.List[_toArray_2__T]: ...

class SimpleTimeZone(TimeZone):
    """
    Java class 'java.util.SimpleTimeZone'
    
        Extends:
            java.util.TimeZone
    
      Constructors:
        * SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)
        * SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)
        * SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)
        * SimpleTimeZone(int, java.lang.String)
    
      Attributes:
        WALL_TIME (int): final static field
        STANDARD_TIME (int): final static field
        UTC_TIME (int): final static field
    
    """
    WALL_TIME: typing.ClassVar[int] = ...
    STANDARD_TIME: typing.ClassVar[int] = ...
    UTC_TIME: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int, string: java.lang.String): ...
    @typing.overload
    def __init__(self, int: int, string: java.lang.String, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int): ...
    @typing.overload
    def __init__(self, int: int, string: java.lang.String, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int): ...
    @typing.overload
    def __init__(self, int: int, string: java.lang.String, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int, int11: int, int12: int): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDSTSavings(self) -> int: ...
    @typing.overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @typing.overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    def hasSameRules(self, timeZone: TimeZone) -> bool: ...
    def hashCode(self) -> int: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    def setDSTSavings(self, int: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setStartYear(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...
    def useDaylightTime(self) -> bool: ...

_SortedMap__K = typing.TypeVar('_SortedMap__K')  # <K>
_SortedMap__V = typing.TypeVar('_SortedMap__V')  # <V>
class SortedMap(Map[_SortedMap__K, _SortedMap__V], typing.Generic[_SortedMap__K, _SortedMap__V]):
    """
    Java class 'java.util.SortedMap'
    
        Interfaces:
            java.util.Map
    
    """
    def comparator(self) -> Comparator[_SortedMap__K]: ...
    def entrySet(self) -> Set[Map.Entry[_SortedMap__K, _SortedMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstKey(self) -> _SortedMap__K: ...
    def hashCode(self) -> int: ...
    def headMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def keySet(self) -> Set[_SortedMap__K]: ...
    def lastKey(self) -> _SortedMap__K: ...
    def subMap(self, k: _SortedMap__K, k2: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def tailMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def values(self) -> Collection[_SortedMap__V]: ...

class StringTokenizer(Enumeration[typing.Any]):
    """
    Java class 'java.util.StringTokenizer'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Enumeration
    
      Constructors:
        * StringTokenizer(java.lang.String, java.lang.String)
        * StringTokenizer(java.lang.String, java.lang.String, boolean)
        * StringTokenizer(java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, boolean: bool): ...
    def countTokens(self) -> int: ...
    def hasMoreElements(self) -> bool: ...
    def hasMoreTokens(self) -> bool: ...
    def nextElement(self) -> typing.Any: ...
    @typing.overload
    def nextToken(self) -> java.lang.String: ...
    @typing.overload
    def nextToken(self, string: java.lang.String) -> java.lang.String: ...

class UnknownFormatConversionException(IllegalFormatException):
    """
    Java class 'java.util.UnknownFormatConversionException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * UnknownFormatConversionException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getConversion(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

class UnknownFormatFlagsException(IllegalFormatException):
    """
    Java class 'java.util.UnknownFormatFlagsException'
    
        Extends:
            java.util.IllegalFormatException
    
      Constructors:
        * UnknownFormatFlagsException(java.lang.String)
    
    """
    def __init__(self, string: java.lang.String): ...
    def getFlags(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...

_AbstractList__E = typing.TypeVar('_AbstractList__E')  # <E>
class AbstractList(AbstractCollection[_AbstractList__E], List[_AbstractList__E], typing.Generic[_AbstractList__E]):
    """
    Java class 'java.util.AbstractList'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.util.List
    
    """
    @typing.overload
    def add(self, e: _AbstractList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _AbstractList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_AbstractList__E], typing.Sequence[_AbstractList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_AbstractList__E], typing.Sequence[_AbstractList__E]]) -> bool: ...
    def clear(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _AbstractList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def iterator(self) -> Iterator[_AbstractList__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_AbstractList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_AbstractList__E]: ...
    def set(self, int: int, e: _AbstractList__E) -> _AbstractList__E: ...
    def subList(self, int: int, int2: int) -> List[_AbstractList__E]: ...

_AbstractQueue__E = typing.TypeVar('_AbstractQueue__E')  # <E>
class AbstractQueue(AbstractCollection[_AbstractQueue__E], Queue[_AbstractQueue__E], typing.Generic[_AbstractQueue__E]):
    """
    Java class 'java.util.AbstractQueue'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.util.Queue
    
    """
    def add(self, e: _AbstractQueue__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_AbstractQueue__E], typing.Sequence[_AbstractQueue__E]]) -> bool: ...
    def clear(self) -> None: ...
    def element(self) -> _AbstractQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _AbstractQueue__E: ...

_AbstractSet__E = typing.TypeVar('_AbstractSet__E')  # <E>
class AbstractSet(AbstractCollection[_AbstractSet__E], Set[_AbstractSet__E], typing.Generic[_AbstractSet__E]):
    """
    Java class 'java.util.AbstractSet'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.util.Set
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...

_Deque__E = typing.TypeVar('_Deque__E')  # <E>
class Deque(Queue[_Deque__E], typing.Generic[_Deque__E]):
    """
    Java class 'java.util.Deque'
    
        Interfaces:
            java.util.Queue
    
    """
    def add(self, e: _Deque__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_Deque__E], typing.Sequence[_Deque__E]]) -> bool: ...
    def addFirst(self, e: _Deque__E) -> None: ...
    def addLast(self, e: _Deque__E) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_Deque__E]: ...
    def element(self) -> _Deque__E: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getFirst(self) -> _Deque__E: ...
    def getLast(self) -> _Deque__E: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> Iterator[_Deque__E]: ...
    def offer(self, e: _Deque__E) -> bool: ...
    def offerFirst(self, e: _Deque__E) -> bool: ...
    def offerLast(self, e: _Deque__E) -> bool: ...
    def peek(self) -> _Deque__E: ...
    def peekFirst(self) -> _Deque__E: ...
    def peekLast(self) -> _Deque__E: ...
    def poll(self) -> _Deque__E: ...
    def pollFirst(self) -> _Deque__E: ...
    def pollLast(self) -> _Deque__E: ...
    def pop(self) -> _Deque__E: ...
    def push(self, e: _Deque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _Deque__E: ...
    def removeFirst(self) -> _Deque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _Deque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...

_EnumMap__K = typing.TypeVar('_EnumMap__K', bound=java.lang.Enum)  # <K>
_EnumMap__V = typing.TypeVar('_EnumMap__V')  # <V>
class EnumMap(AbstractMap[_EnumMap__K, _EnumMap__V], java.io.Serializable, java.lang.Cloneable, typing.Generic[_EnumMap__K, _EnumMap__V]):
    """
    Java class 'java.util.EnumMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.io.Serializable, java.lang.Cloneable
    
      Constructors:
        * EnumMap(java.lang.Class)
        * EnumMap(java.util.Map)
        * EnumMap(java.util.EnumMap)
    
    """
    @typing.overload
    def __init__(self, class_: typing.Type[_EnumMap__K]): ...
    @typing.overload
    def __init__(self, enumMap: 'EnumMap'[_EnumMap__K, _EnumMap__V]): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_EnumMap__K, _EnumMap__V], typing.Mapping[_EnumMap__K, _EnumMap__V]]): ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> 'EnumMap'[_EnumMap__K, _EnumMap__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_EnumMap__K, _EnumMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _EnumMap__V: ...
    def hashCode(self) -> int: ...
    def keySet(self) -> Set[_EnumMap__K]: ...
    @typing.overload
    def put(self, k: _EnumMap__K, v: _EnumMap__V) -> _EnumMap__V: ...
    @typing.overload
    def put(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def putAll(self, map: typing.Union[Map[_EnumMap__K, _EnumMap__V], typing.Mapping[_EnumMap__K, _EnumMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _EnumMap__V: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_EnumMap__V]: ...

_HashMap__K = typing.TypeVar('_HashMap__K')  # <K>
_HashMap__V = typing.TypeVar('_HashMap__V')  # <V>
class HashMap(AbstractMap[_HashMap__K, _HashMap__V], Map[_HashMap__K, _HashMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_HashMap__K, _HashMap__V]):
    """
    Java class 'java.util.HashMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.Map, java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * HashMap(int, float)
        * HashMap()
        * HashMap(java.util.Map)
        * HashMap(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_HashMap__K, _HashMap__V], typing.Mapping[_HashMap__K, _HashMap__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def compute(self, k: _HashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def computeIfAbsent(self, k: _HashMap__K, function: typing.Union[java.util.function.Function[_HashMap__K, _HashMap__V], typing.Callable[[_HashMap__K], _HashMap__V]]) -> _HashMap__V: ...
    def computeIfPresent(self, k: _HashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_HashMap__K, _HashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_HashMap__K, _HashMap__V], typing.Callable[[_HashMap__K], _HashMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _HashMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _HashMap__V) -> _HashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_HashMap__K]: ...
    def merge(self, k: _HashMap__K, v: _HashMap__V, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__V, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__V, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def put(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def putAll(self, map: typing.Union[Map[_HashMap__K, _HashMap__V], typing.Mapping[_HashMap__K, _HashMap__V]]) -> None: ...
    def putIfAbsent(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _HashMap__V: ...
    @typing.overload
    def replace(self, k: _HashMap__K, v: _HashMap__V, v2: _HashMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_HashMap__V]: ...

_IdentityHashMap__K = typing.TypeVar('_IdentityHashMap__K')  # <K>
_IdentityHashMap__V = typing.TypeVar('_IdentityHashMap__V')  # <V>
class IdentityHashMap(AbstractMap[_IdentityHashMap__K, _IdentityHashMap__V], Map[_IdentityHashMap__K, _IdentityHashMap__V], java.io.Serializable, java.lang.Cloneable, typing.Generic[_IdentityHashMap__K, _IdentityHashMap__V]):
    """
    Java class 'java.util.IdentityHashMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.Map, java.io.Serializable, java.lang.Cloneable
    
      Constructors:
        * IdentityHashMap(int)
        * IdentityHashMap()
        * IdentityHashMap(java.util.Map)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_IdentityHashMap__K, _IdentityHashMap__V], typing.Mapping[_IdentityHashMap__K, _IdentityHashMap__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_IdentityHashMap__K, _IdentityHashMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_IdentityHashMap__K, _IdentityHashMap__V], typing.Callable[[_IdentityHashMap__K], _IdentityHashMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _IdentityHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_IdentityHashMap__K]: ...
    def put(self, k: _IdentityHashMap__K, v: _IdentityHashMap__V) -> _IdentityHashMap__V: ...
    def putAll(self, map: typing.Union[Map[_IdentityHashMap__K, _IdentityHashMap__V], typing.Mapping[_IdentityHashMap__K, _IdentityHashMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _IdentityHashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_IdentityHashMap__K, _IdentityHashMap__V, _IdentityHashMap__V], typing.Callable[[_IdentityHashMap__K, _IdentityHashMap__V], _IdentityHashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_IdentityHashMap__V]: ...

_NavigableMap__K = typing.TypeVar('_NavigableMap__K')  # <K>
_NavigableMap__V = typing.TypeVar('_NavigableMap__V')  # <V>
class NavigableMap(SortedMap[_NavigableMap__K, _NavigableMap__V], typing.Generic[_NavigableMap__K, _NavigableMap__V]):
    """
    Java class 'java.util.NavigableMap'
    
        Interfaces:
            java.util.SortedMap
    
    """
    def ceilingEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def ceilingKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def descendingKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def descendingMap(self) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def headMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def headMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    def higherEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def higherKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def lastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def navigableKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _NavigableMap__K, boolean: bool, k2: _NavigableMap__K, boolean2: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _NavigableMap__K, k2: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...

class Properties(Hashtable[typing.Any, typing.Any]):
    """
    Java class 'java.util.Properties'
    
        Extends:
            java.util.Hashtable
    
      Constructors:
        * Properties(java.util.Properties)
        * Properties(int)
        * Properties()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, properties: 'Properties'): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def compute(self, object: typing.Any, biFunction: typing.Union[java.util.function.BiFunction[typing.Any, typing.Any, typing.Any], typing.Callable[[typing.Any, typing.Any], typing.Any]]) -> typing.Any: ...
    def computeIfAbsent(self, object: typing.Any, function: typing.Union[java.util.function.Function[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> typing.Any: ...
    def computeIfPresent(self, object: typing.Any, biFunction: typing.Union[java.util.function.BiFunction[typing.Any, typing.Any, typing.Any], typing.Callable[[typing.Any, typing.Any], typing.Any]]) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def elements(self) -> Enumeration[typing.Any]: ...
    def entrySet(self) -> Set[Map.Entry[typing.Any, typing.Any]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    def get(self, object: typing.Any) -> typing.Any: ...
    def getOrDefault(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @typing.overload
    def getProperty(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def getProperty(self, string: java.lang.String, string2: java.lang.String) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[typing.Any]: ...
    def keys(self) -> Enumeration[typing.Any]: ...
    @typing.overload
    def list(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def list(self, printWriter: java.io.PrintWriter) -> None: ...
    @typing.overload
    def load(self, inputStream: java.io.InputStream) -> None: ...
    @typing.overload
    def load(self, reader: java.io.Reader) -> None: ...
    def loadFromXML(self, inputStream: java.io.InputStream) -> None: ...
    def merge(self, object: typing.Any, object2: typing.Any, biFunction: typing.Union[java.util.function.BiFunction[typing.Any, typing.Any, typing.Any], typing.Callable[[typing.Any, typing.Any], typing.Any]]) -> typing.Any: ...
    def propertyNames(self) -> Enumeration[typing.Any]: ...
    def put(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def putAll(self, map: typing.Union[Map[typing.Any, typing.Any], typing.Mapping[typing.Any, typing.Any]]) -> None: ...
    def putIfAbsent(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> typing.Any: ...
    @typing.overload
    def replace(self, object: typing.Any, object2: typing.Any, object3: typing.Any) -> bool: ...
    @typing.overload
    def replace(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[typing.Any, typing.Any, typing.Any], typing.Callable[[typing.Any, typing.Any], typing.Any]]) -> None: ...
    def save(self, outputStream: java.io.OutputStream, string: java.lang.String) -> None: ...
    def setProperty(self, string: java.lang.String, string2: java.lang.String) -> typing.Any: ...
    def size(self) -> int: ...
    @typing.overload
    def store(self, outputStream: java.io.OutputStream, string: java.lang.String) -> None: ...
    @typing.overload
    def store(self, writer: java.io.Writer, string: java.lang.String) -> None: ...
    @typing.overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: java.lang.String) -> None: ...
    @typing.overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: java.lang.String, string2: java.lang.String) -> None: ...
    @typing.overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: java.lang.String, charset: java.nio.charset.Charset) -> None: ...
    def stringPropertyNames(self) -> Set[java.lang.String]: ...
    def toString(self) -> java.lang.String: ...
    def values(self) -> Collection[typing.Any]: ...

_SortedSet__E = typing.TypeVar('_SortedSet__E')  # <E>
class SortedSet(Set[_SortedSet__E], typing.Generic[_SortedSet__E]):
    """
    Java class 'java.util.SortedSet'
    
        Interfaces:
            java.util.Set
    
    """
    def comparator(self) -> Comparator[_SortedSet__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def first(self) -> _SortedSet__E: ...
    def hashCode(self) -> int: ...
    def headSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def last(self) -> _SortedSet__E: ...
    def spliterator(self) -> 'Spliterator'[_SortedSet__E]: ...
    def subSet(self, e: _SortedSet__E, e2: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def tailSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...

_WeakHashMap__K = typing.TypeVar('_WeakHashMap__K')  # <K>
_WeakHashMap__V = typing.TypeVar('_WeakHashMap__V')  # <V>
class WeakHashMap(AbstractMap[_WeakHashMap__K, _WeakHashMap__V], Map[_WeakHashMap__K, _WeakHashMap__V], typing.Generic[_WeakHashMap__K, _WeakHashMap__V]):
    """
    Java class 'java.util.WeakHashMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.Map
    
      Constructors:
        * WeakHashMap(java.util.Map)
        * WeakHashMap(int)
        * WeakHashMap(int, float)
        * WeakHashMap()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_WeakHashMap__K, _WeakHashMap__V], typing.Mapping[_WeakHashMap__K, _WeakHashMap__V]]): ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_WeakHashMap__K, _WeakHashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_WeakHashMap__K, _WeakHashMap__V], typing.Callable[[_WeakHashMap__K], _WeakHashMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _WeakHashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_WeakHashMap__K]: ...
    def put(self, k: _WeakHashMap__K, v: _WeakHashMap__V) -> _WeakHashMap__V: ...
    def putAll(self, map: typing.Union[Map[_WeakHashMap__K, _WeakHashMap__V], typing.Mapping[_WeakHashMap__K, _WeakHashMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _WeakHashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_WeakHashMap__K, _WeakHashMap__V, _WeakHashMap__V], typing.Callable[[_WeakHashMap__K, _WeakHashMap__V], _WeakHashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_WeakHashMap__V]: ...

_AbstractSequentialList__E = typing.TypeVar('_AbstractSequentialList__E')  # <E>
class AbstractSequentialList(AbstractList[_AbstractSequentialList__E], typing.Generic[_AbstractSequentialList__E]):
    """
    Java class 'java.util.AbstractSequentialList'
    
        Extends:
            java.util.AbstractList
    
    """
    @typing.overload
    def add(self, e: _AbstractSequentialList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _AbstractSequentialList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_AbstractSequentialList__E], typing.Sequence[_AbstractSequentialList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_AbstractSequentialList__E], typing.Sequence[_AbstractSequentialList__E]]) -> bool: ...
    def get(self, int: int) -> _AbstractSequentialList__E: ...
    def iterator(self) -> Iterator[_AbstractSequentialList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_AbstractSequentialList__E]: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_AbstractSequentialList__E]: ...
    def set(self, int: int, e: _AbstractSequentialList__E) -> _AbstractSequentialList__E: ...

_ArrayDeque__E = typing.TypeVar('_ArrayDeque__E')  # <E>
class ArrayDeque(AbstractCollection[_ArrayDeque__E], Deque[_ArrayDeque__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_ArrayDeque__E]):
    """
    Java class 'java.util.ArrayDeque'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.util.Deque, java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * ArrayDeque(int)
        * ArrayDeque(java.util.Collection)
        * ArrayDeque()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_ArrayDeque__E], typing.Sequence[_ArrayDeque__E]]): ...
    def add(self, e: _ArrayDeque__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_ArrayDeque__E], typing.Sequence[_ArrayDeque__E]]) -> bool: ...
    def addFirst(self, e: _ArrayDeque__E) -> None: ...
    def addLast(self, e: _ArrayDeque__E) -> None: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> 'ArrayDeque'[_ArrayDeque__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_ArrayDeque__E]: ...
    def element(self) -> _ArrayDeque__E: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ArrayDeque__E], typing.Callable[[], _ArrayDeque__E]]) -> None: ...
    def getFirst(self) -> _ArrayDeque__E: ...
    def getLast(self) -> _ArrayDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayDeque__E]: ...
    def offer(self, e: _ArrayDeque__E) -> bool: ...
    def offerFirst(self, e: _ArrayDeque__E) -> bool: ...
    def offerLast(self, e: _ArrayDeque__E) -> bool: ...
    def peek(self) -> _ArrayDeque__E: ...
    def peekFirst(self) -> _ArrayDeque__E: ...
    def peekLast(self) -> _ArrayDeque__E: ...
    def poll(self) -> _ArrayDeque__E: ...
    def pollFirst(self) -> _ArrayDeque__E: ...
    def pollLast(self) -> _ArrayDeque__E: ...
    def pop(self) -> _ArrayDeque__E: ...
    def push(self, e: _ArrayDeque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ArrayDeque__E: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeFirst(self) -> _ArrayDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ArrayDeque__E], typing.Callable[[], _ArrayDeque__E]]) -> bool: ...
    def removeLast(self) -> _ArrayDeque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_ArrayDeque__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_ArrayList__E = typing.TypeVar('_ArrayList__E')  # <E>
class ArrayList(AbstractList[_ArrayList__E], List[_ArrayList__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, typing.Generic[_ArrayList__E]):
    """
    Java class 'java.util.ArrayList'
    
        Extends:
            java.util.AbstractList
    
        Interfaces:
            java.util.List, java.util.RandomAccess, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * ArrayList(java.util.Collection)
        * ArrayList()
        * ArrayList(int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E]]): ...
    @typing.overload
    def add(self, e: _ArrayList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _ArrayList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E]]) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def ensureCapacity(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ArrayList__E], typing.Callable[[], _ArrayList__E]]) -> None: ...
    def get(self, int: int) -> _ArrayList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayList__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_ArrayList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_ArrayList__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ArrayList__E], typing.Callable[[], _ArrayList__E]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_ArrayList__E], typing.Callable[[], _ArrayList__E]]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _ArrayList__E) -> _ArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_ArrayList__E], typing.Callable[[], _ArrayList__E]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_ArrayList__E]: ...
    def subList(self, int: int, int2: int) -> List[_ArrayList__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def trimToSize(self) -> None: ...

_EnumSet__E = typing.TypeVar('_EnumSet__E', bound=java.lang.Enum)  # <E>
class EnumSet(AbstractSet[_EnumSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_EnumSet__E]):
    """
    Java class 'java.util.EnumSet'
    
        Extends:
            java.util.AbstractSet
    
        Interfaces:
            java.lang.Cloneable, java.io.Serializable
    
    """
    _allOf__E = typing.TypeVar('_allOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def allOf(cls, class_: typing.Type[_allOf__E]) -> 'EnumSet'[_allOf__E]: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> 'EnumSet'[_EnumSet__E]: ...
    _complementOf__E = typing.TypeVar('_complementOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def complementOf(cls, enumSet: 'EnumSet'[_complementOf__E]) -> 'EnumSet'[_complementOf__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def copyOf(cls, collection: typing.Union[Collection[_copyOf_0__E], typing.Sequence[_copyOf_0__E]]) -> 'EnumSet'[_copyOf_0__E]: ...
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def copyOf(cls, enumSet: 'EnumSet'[_copyOf_1__E]) -> 'EnumSet'[_copyOf_1__E]: ...
    _noneOf__E = typing.TypeVar('_noneOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def noneOf(cls, class_: typing.Type[_noneOf__E]) -> 'EnumSet'[_noneOf__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_0__E) -> 'EnumSet'[_of_0__E]: ...
    _of_1__E = typing.TypeVar('_of_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_1__E, e2: _of_1__E) -> 'EnumSet'[_of_1__E]: ...
    _of_2__E = typing.TypeVar('_of_2__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_2__E, e2: _of_2__E, e3: _of_2__E) -> 'EnumSet'[_of_2__E]: ...
    _of_3__E = typing.TypeVar('_of_3__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_3__E, e2: _of_3__E, e3: _of_3__E, e4: _of_3__E) -> 'EnumSet'[_of_3__E]: ...
    _of_4__E = typing.TypeVar('_of_4__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E, e5: _of_4__E) -> 'EnumSet'[_of_4__E]: ...
    _of_5__E = typing.TypeVar('_of_5__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @typing.overload
    def of(cls, e: _of_5__E, eArray: typing.List[_of_5__E]) -> 'EnumSet'[_of_5__E]: ...
    _range__E = typing.TypeVar('_range__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def range(cls, e: _range__E, e2: _range__E) -> 'EnumSet'[_range__E]: ...

_HashSet__E = typing.TypeVar('_HashSet__E')  # <E>
class HashSet(AbstractSet[_HashSet__E], Set[_HashSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_HashSet__E]):
    """
    Java class 'java.util.HashSet'
    
        Extends:
            java.util.AbstractSet
    
        Interfaces:
            java.util.Set, java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * HashSet(int)
        * HashSet(int, float)
        * HashSet(java.util.Collection)
        * HashSet()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_HashSet__E], typing.Sequence[_HashSet__E]]): ...
    def add(self, e: _HashSet__E) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_HashSet__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_HashSet__E]: ...

_LinkedHashMap__K = typing.TypeVar('_LinkedHashMap__K')  # <K>
_LinkedHashMap__V = typing.TypeVar('_LinkedHashMap__V')  # <V>
class LinkedHashMap(HashMap[_LinkedHashMap__K, _LinkedHashMap__V], Map[_LinkedHashMap__K, _LinkedHashMap__V], typing.Generic[_LinkedHashMap__K, _LinkedHashMap__V]):
    """
    Java class 'java.util.LinkedHashMap'
    
        Extends:
            java.util.HashMap
    
        Interfaces:
            java.util.Map
    
      Constructors:
        * LinkedHashMap()
        * LinkedHashMap(int)
        * LinkedHashMap(int, float)
        * LinkedHashMap(java.util.Map)
        * LinkedHashMap(int, float, boolean)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, int: int, float: float, boolean: bool): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_LinkedHashMap__K, _LinkedHashMap__V], typing.Mapping[_LinkedHashMap__K, _LinkedHashMap__V]]): ...
    def clear(self) -> None: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_LinkedHashMap__K, _LinkedHashMap__V], typing.Callable[[_LinkedHashMap__K], _LinkedHashMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _LinkedHashMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _LinkedHashMap__V) -> _LinkedHashMap__V: ...
    def keySet(self) -> Set[_LinkedHashMap__K]: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_LinkedHashMap__K, _LinkedHashMap__V, _LinkedHashMap__V], typing.Callable[[_LinkedHashMap__K, _LinkedHashMap__V], _LinkedHashMap__V]]) -> None: ...
    def values(self) -> Collection[_LinkedHashMap__V]: ...

_NavigableSet__E = typing.TypeVar('_NavigableSet__E')  # <E>
class NavigableSet(SortedSet[_NavigableSet__E], typing.Generic[_NavigableSet__E]):
    """
    Java class 'java.util.NavigableSet'
    
        Interfaces:
            java.util.SortedSet
    
    """
    def ceiling(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def descendingIterator(self) -> Iterator[_NavigableSet__E]: ...
    def descendingSet(self) -> 'NavigableSet'[_NavigableSet__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floor(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def headSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def headSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    def higher(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def iterator(self) -> Iterator[_NavigableSet__E]: ...
    def lower(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def pollFirst(self) -> _NavigableSet__E: ...
    def pollLast(self) -> _NavigableSet__E: ...
    @typing.overload
    def subSet(self, e: _NavigableSet__E, boolean: bool, e2: _NavigableSet__E, boolean2: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def subSet(self, e: _NavigableSet__E, e2: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...

_PriorityQueue__E = typing.TypeVar('_PriorityQueue__E')  # <E>
class PriorityQueue(AbstractQueue[_PriorityQueue__E], java.io.Serializable, typing.Generic[_PriorityQueue__E]):
    """
    Java class 'java.util.PriorityQueue'
    
        Extends:
            java.util.AbstractQueue
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * PriorityQueue(int, java.util.Comparator)
        * PriorityQueue(java.util.Collection)
        * PriorityQueue(java.util.PriorityQueue)
        * PriorityQueue(java.util.SortedSet)
        * PriorityQueue()
        * PriorityQueue(int)
        * PriorityQueue(java.util.Comparator)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, comparator: typing.Union[Comparator[_PriorityQueue__E], typing.Callable[[], _PriorityQueue__E]]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_PriorityQueue__E], typing.Sequence[_PriorityQueue__E]]): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_PriorityQueue__E], typing.Callable[[], _PriorityQueue__E]]): ...
    @typing.overload
    def __init__(self, priorityQueue: 'PriorityQueue'[_PriorityQueue__E]): ...
    @typing.overload
    def __init__(self, sortedSet: SortedSet[_PriorityQueue__E]): ...
    def add(self, e: _PriorityQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> Comparator[_PriorityQueue__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_PriorityQueue__E], typing.Callable[[], _PriorityQueue__E]]) -> None: ...
    def iterator(self) -> Iterator[_PriorityQueue__E]: ...
    def offer(self, e: _PriorityQueue__E) -> bool: ...
    def peek(self) -> _PriorityQueue__E: ...
    def poll(self) -> _PriorityQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _PriorityQueue__E: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_PriorityQueue__E], typing.Callable[[], _PriorityQueue__E]]) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_PriorityQueue__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_TreeMap__K = typing.TypeVar('_TreeMap__K')  # <K>
_TreeMap__V = typing.TypeVar('_TreeMap__V')  # <V>
class TreeMap(AbstractMap[_TreeMap__K, _TreeMap__V], NavigableMap[_TreeMap__K, _TreeMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_TreeMap__K, _TreeMap__V]):
    """
    Java class 'java.util.TreeMap'
    
        Extends:
            java.util.AbstractMap
    
        Interfaces:
            java.util.NavigableMap, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * TreeMap(java.util.SortedMap)
        * TreeMap(java.util.Map)
        * TreeMap(java.util.Comparator)
        * TreeMap()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_TreeMap__K], typing.Callable[[], _TreeMap__K]]): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_TreeMap__K, _TreeMap__V], typing.Mapping[_TreeMap__K, _TreeMap__V]]): ...
    @typing.overload
    def __init__(self, sortedMap: SortedMap[_TreeMap__K, _TreeMap__V]): ...
    def ceilingEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def ceilingKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def comparator(self) -> Comparator[_TreeMap__K]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def descendingKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def descendingMap(self) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def entrySet(self) -> Set[Map.Entry[_TreeMap__K, _TreeMap__V]]: ...
    def firstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def firstKey(self) -> _TreeMap__K: ...
    def floorEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def floorKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_TreeMap__K, _TreeMap__V], typing.Callable[[_TreeMap__K], _TreeMap__V]]) -> None: ...
    def get(self, object: typing.Any) -> _TreeMap__V: ...
    @typing.overload
    def headMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def headMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def higherEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def higherKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def keySet(self) -> Set[_TreeMap__K]: ...
    def lastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lastKey(self) -> _TreeMap__K: ...
    def lowerEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lowerKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def navigableKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def put(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def putAll(self, map: typing.Union[Map[_TreeMap__K, _TreeMap__V], typing.Mapping[_TreeMap__K, _TreeMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _TreeMap__V: ...
    @typing.overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V, v2: _TreeMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V], typing.Callable[[_TreeMap__K, _TreeMap__V], _TreeMap__V]]) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, k: _TreeMap__K, boolean: bool, k2: _TreeMap__K, boolean2: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def subMap(self, k: _TreeMap__K, k2: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def values(self) -> Collection[_TreeMap__V]: ...

_Vector__E = typing.TypeVar('_Vector__E')  # <E>
class Vector(AbstractList[_Vector__E], List[_Vector__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, typing.Generic[_Vector__E]):
    """
    Java class 'java.util.Vector'
    
        Extends:
            java.util.AbstractList
    
        Interfaces:
            java.util.List, java.util.RandomAccess, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * Vector(java.util.Collection)
        * Vector()
        * Vector(int)
        * Vector(int, int)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E]]): ...
    @typing.overload
    def add(self, e: _Vector__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _Vector__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E]]) -> bool: ...
    def addElement(self, e: _Vector__E) -> None: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def copyInto(self, objectArray: typing.List[typing.Any]) -> None: ...
    def elementAt(self, int: int) -> _Vector__E: ...
    def elements(self) -> Enumeration[_Vector__E]: ...
    def ensureCapacity(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstElement(self) -> _Vector__E: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Vector__E], typing.Callable[[], _Vector__E]]) -> None: ...
    def get(self, int: int) -> _Vector__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def indexOf(self, object: typing.Any, int: int) -> int: ...
    def insertElementAt(self, e: _Vector__E, int: int) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Vector__E]: ...
    def lastElement(self) -> _Vector__E: ...
    @typing.overload
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def lastIndexOf(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_Vector__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_Vector__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeAllElements(self) -> None: ...
    def removeElement(self, object: typing.Any) -> bool: ...
    def removeElementAt(self, int: int) -> None: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_Vector__E], typing.Callable[[], _Vector__E]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_Vector__E], typing.Callable[[], _Vector__E]]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _Vector__E) -> _Vector__E: ...
    def setElementAt(self, e: _Vector__E, int: int) -> None: ...
    def setSize(self, int: int) -> None: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_Vector__E], typing.Callable[[], _Vector__E]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_Vector__E]: ...
    def subList(self, int: int, int2: int) -> List[_Vector__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    def toString(self) -> java.lang.String: ...
    def trimToSize(self) -> None: ...

_LinkedHashSet__E = typing.TypeVar('_LinkedHashSet__E')  # <E>
class LinkedHashSet(HashSet[_LinkedHashSet__E], Set[_LinkedHashSet__E], typing.Generic[_LinkedHashSet__E]):
    """
    Java class 'java.util.LinkedHashSet'
    
        Extends:
            java.util.HashSet
    
        Interfaces:
            java.util.Set, java.lang.Cloneable, java.io.Serializable
    
      Constructors:
        * LinkedHashSet(java.util.Collection)
        * LinkedHashSet()
        * LinkedHashSet(int)
        * LinkedHashSet(int, float)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_LinkedHashSet__E], typing.Sequence[_LinkedHashSet__E]]): ...
    def spliterator(self) -> 'Spliterator'[_LinkedHashSet__E]: ...

_LinkedList__E = typing.TypeVar('_LinkedList__E')  # <E>
class LinkedList(AbstractSequentialList[_LinkedList__E], List[_LinkedList__E], Deque[_LinkedList__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_LinkedList__E]):
    """
    Java class 'java.util.LinkedList'
    
        Extends:
            java.util.AbstractSequentialList
    
        Interfaces:
            java.util.List, java.util.Deque, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * LinkedList()
        * LinkedList(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E]]): ...
    @typing.overload
    def add(self, e: _LinkedList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _LinkedList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E]]) -> bool: ...
    def addFirst(self, e: _LinkedList__E) -> None: ...
    def addLast(self, e: _LinkedList__E) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_LinkedList__E]: ...
    def element(self) -> _LinkedList__E: ...
    def get(self, int: int) -> _LinkedList__E: ...
    def getFirst(self) -> _LinkedList__E: ...
    def getLast(self) -> _LinkedList__E: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_LinkedList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_LinkedList__E]: ...
    def offer(self, e: _LinkedList__E) -> bool: ...
    def offerFirst(self, e: _LinkedList__E) -> bool: ...
    def offerLast(self, e: _LinkedList__E) -> bool: ...
    def peek(self) -> _LinkedList__E: ...
    def peekFirst(self) -> _LinkedList__E: ...
    def peekLast(self) -> _LinkedList__E: ...
    def poll(self) -> _LinkedList__E: ...
    def pollFirst(self) -> _LinkedList__E: ...
    def pollLast(self) -> _LinkedList__E: ...
    def pop(self) -> _LinkedList__E: ...
    def push(self, e: _LinkedList__E) -> None: ...
    def removeFirst(self) -> _LinkedList__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _LinkedList__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def set(self, int: int, e: _LinkedList__E) -> _LinkedList__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_LinkedList__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_Stack__E = typing.TypeVar('_Stack__E')  # <E>
class Stack(Vector[_Stack__E], typing.Generic[_Stack__E]):
    """
    Java class 'java.util.Stack'
    
        Extends:
            java.util.Vector
    
      Constructors:
        * Stack()
    
    """
    def __init__(self): ...
    def empty(self) -> bool: ...
    def peek(self) -> _Stack__E: ...
    def pop(self) -> _Stack__E: ...
    def push(self, e: _Stack__E) -> _Stack__E: ...
    def search(self, object: typing.Any) -> int: ...

_TreeSet__E = typing.TypeVar('_TreeSet__E')  # <E>
class TreeSet(AbstractSet[_TreeSet__E], NavigableSet[_TreeSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_TreeSet__E]):
    """
    Java class 'java.util.TreeSet'
    
        Extends:
            java.util.AbstractSet
    
        Interfaces:
            java.util.NavigableSet, java.lang.Cloneable,
            java.io.Serializable
    
      Constructors:
        * TreeSet(java.util.SortedSet)
        * TreeSet(java.util.Collection)
        * TreeSet(java.util.Comparator)
        * TreeSet()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_TreeSet__E], typing.Sequence[_TreeSet__E]]): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_TreeSet__E], typing.Callable[[], _TreeSet__E]]): ...
    @typing.overload
    def __init__(self, sortedSet: SortedSet[_TreeSet__E]): ...
    def add(self, e: _TreeSet__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_TreeSet__E], typing.Sequence[_TreeSet__E]]) -> bool: ...
    def ceiling(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def comparator(self) -> Comparator[_TreeSet__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_TreeSet__E]: ...
    def descendingSet(self) -> NavigableSet[_TreeSet__E]: ...
    def first(self) -> _TreeSet__E: ...
    def floor(self, e: _TreeSet__E) -> _TreeSet__E: ...
    @typing.overload
    def headSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def headSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    def higher(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_TreeSet__E]: ...
    def last(self) -> _TreeSet__E: ...
    def lower(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def pollFirst(self) -> _TreeSet__E: ...
    def pollLast(self) -> _TreeSet__E: ...
    def remove(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, e: _TreeSet__E, boolean: bool, e2: _TreeSet__E, boolean2: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, e: _TreeSet__E, e2: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...

_PrimitiveIterator__T = typing.TypeVar('_PrimitiveIterator__T')  # <T>
_PrimitiveIterator__T_CONS = typing.TypeVar('_PrimitiveIterator__T_CONS')  # <T_CONS>
class PrimitiveIterator(Iterator[_PrimitiveIterator__T], typing.Generic[_PrimitiveIterator__T, _PrimitiveIterator__T_CONS]):
    """
    Java class 'java.util.PrimitiveIterator'
    
        Interfaces:
            java.util.Iterator
    
    """
    @typing.overload
    def forEachRemaining(self, t_CONS: _PrimitiveIterator__T_CONS) -> None: ...
    @typing.overload
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[typing.Any], typing.Callable[[], typing.Any]]) -> None: ...
    class OfDouble(java.util.PrimitiveIterator[float, java.util.function.DoubleConsumer]):
        """
        Java class 'java.util.PrimitiveIterator$OfDouble'
        
            Interfaces:
                java.util.PrimitiveIterator
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[], float]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @typing.overload
        def next(self) -> float: ...
        @typing.overload
        def next(self) -> typing.Any: ...
        def nextDouble(self) -> float: ...
    class OfInt(java.util.PrimitiveIterator[int, java.util.function.IntConsumer]):
        """
        Java class 'java.util.PrimitiveIterator$OfInt'
        
            Interfaces:
                java.util.PrimitiveIterator
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @typing.overload
        def next(self) -> int: ...
        @typing.overload
        def next(self) -> typing.Any: ...
        def nextInt(self) -> int: ...
    class OfLong(java.util.PrimitiveIterator[int, java.util.function.LongConsumer]):
        """
        Java class 'java.util.PrimitiveIterator$OfLong'
        
            Interfaces:
                java.util.PrimitiveIterator
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @typing.overload
        def next(self) -> int: ...
        @typing.overload
        def next(self) -> typing.Any: ...
        def nextLong(self) -> int: ...

_Spliterator__OfPrimitive__T = typing.TypeVar('_Spliterator__OfPrimitive__T')  # <T>
_Spliterator__OfPrimitive__T_CONS = typing.TypeVar('_Spliterator__OfPrimitive__T_CONS')  # <T_CONS>
_Spliterator__OfPrimitive__T_SPLITR = typing.TypeVar('_Spliterator__OfPrimitive__T_SPLITR', bound='Spliterator.OfPrimitive')  # <T_SPLITR>
_Spliterator__T = typing.TypeVar('_Spliterator__T')  # <T>
class Spliterator(java.lang.Object, typing.Generic[_Spliterator__T]):
    """
    public interface Spliterator<T>
    
        An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could
        be, for example, an array, a :class:`~java.util.Collection`, an IO channel, or a generator function.
    
        A Spliterator may traverse elements individually (:meth:`~java.util.Spliterator.tryAdvance`) or sequentially in bulk
        (:meth:`~java.util.Spliterator.forEachRemaining`).
    
        A Spliterator may also partition off some of its elements (using :meth:`~java.util.Spliterator.trySplit`) as another
        Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in
        a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust
        elements; each Spliterator is useful for only a single bulk computation.
    
        A Spliterator also reports a set of :meth:`~java.util.Spliterator.characteristics` of its structure, source, and
        elements from among :meth:`~java.util.Spliterator.ORDERED`, :meth:`~java.util.Spliterator.DISTINCT`,
        :meth:`~java.util.Spliterator.SORTED`, :meth:`~java.util.Spliterator.SIZED`, :meth:`~java.util.Spliterator.NONNULL`,
        :meth:`~java.util.Spliterator.IMMUTABLE`, :meth:`~java.util.Spliterator.CONCURRENT`, and
        :meth:`~java.util.Spliterator.SUBSIZED`. These may be employed by Spliterator clients to control, specialize or simplify
        computation. For example, a Spliterator for a :class:`~java.util.Collection` would report :code:`SIZED`, a Spliterator
        for a :class:`~java.util.Set` would report :code:`DISTINCT`, and a Spliterator for a :class:`~java.util.SortedSet` would
        also report :code:`SORTED`. Characteristics are reported as a simple unioned bit set. Some characteristics additionally
        constrain method behavior; for example if :code:`ORDERED`, traversal methods must conform to their documented ordering.
        New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values.
    
        :class:`~java.util` A *late-binding* Spliterator binds to the source of elements at the point of first traversal, first
        split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not
        *late-binding* binds to the source of elements at the point of construction or first invocation of any method.
        Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a
        Spliterator should, on a best-effort basis, throw :class:`~java.util.ConcurrentModificationException` if structural
        interference is detected. Spliterators that do this are called *fail-fast*. The bulk traversal method
        (:meth:`~java.util.Spliterator.forEachRemaining`) of a Spliterator may optimize traversal and check for structural
        interference after all elements have been traversed, rather than checking per-element and failing immediately.
    
        Spliterators can provide an estimate of the number of remaining elements via the
        :meth:`~java.util.Spliterator.estimateSize` method. Ideally, as reflected in characteristic
        :meth:`~java.util.Spliterator.SIZED`, this value corresponds exactly to the number of elements that would be encountered
        in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations
        being performed on the source, such as helping to determine whether it is preferable to split further or traverse the
        remaining elements sequentially.
    
        Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead,
        implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread
        at a time. This is generally easy to attain via *serial thread-confinement*, which often is a natural consequence of
        typical parallel algorithms that work by recursive decomposition. A thread calling
        :meth:`~java.util.Spliterator.trySplit` may hand over the returned Spliterator to another thread, which in turn may
        traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads
        operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for
        processing, it is best if that handoff occurs before any elements are consumed with
        :meth:`~java.util.Spliterator.tryAdvance`, as certain guarantees (such as the accuracy of
        :meth:`~java.util.Spliterator.estimateSize` for :code:`SIZED` spliterators) are only valid before traversal has begun.
    
        Primitive subtype specializations of :code:`Spliterator` are provided for :class:`~java.util.Spliterator.OfInt`,
        :class:`~java.util.Spliterator.OfLong`, and :class:`~java.util.Spliterator.OfDouble` values. The subtype default
        implementations of :meth:`~java.util.Spliterator.tryAdvance` and :meth:`~java.util.Spliterator.forEachRemaining` box
        primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages
        gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be
        used. For example, :meth:`~java.util.Spliterator.OfPrimitive.tryAdvance` and
        :meth:`~java.util.Spliterator.OfPrimitive.forEachRemaining` should be used in preference to
        :meth:`~java.util.Spliterator.OfInt.tryAdvance` and :meth:`~java.util.Spliterator.OfInt.forEachRemaining`. Traversal of
        primitive values using boxing-based methods :meth:`~java.util.Spliterator.tryAdvance` and
        :meth:`~java.util.Spliterator.forEachRemaining` does not affect the order in which the values, transformed to boxed
        values, are encountered.
    
        API Note:
    
            Spliterators, like :code:`Iterator`s, are for traversing the elements of a source. The :code:`Spliterator` API was
            designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as
            well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to
            impose smaller per-element overhead than :code:`Iterator`, and to avoid the inherent race involved in having separate
            methods for :code:`hasNext()` and :code:`next()`.
    
            For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with
            (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of
            traversal. For example, such interference will produce arbitrary, non-deterministic results when using the
            :code:`java.util.stream` framework.
    
            Structural interference of a source can be managed in the following ways (in approximate order of decreasing
            desirability):
    
              - The source cannot be structurally interfered with.
    
    
    For example, an instance of :class:`~java.util.concurrent.CopyOnWriteArrayList` is an immutable source. A Spliterator
                created from the source reports a characteristic of :code:`IMMUTABLE`.
              - The source manages concurrent modifications.
    
    
    For example, a key set of a :class:`~java.util.concurrent.ConcurrentHashMap` is a concurrent source. A Spliterator
                created from the source reports a characteristic of :code:`CONCURRENT`.
              - The mutable source provides a late-binding and fail-fast Spliterator.
    
    
    Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a
                best-effort basis, that structural interference has occurred after traversal has commenced and throws
                :class:`~java.util.ConcurrentModificationException`. For example, :class:`~java.util.ArrayList`, and many other
                non-concurrent :code:`Collection` classes in the JDK, provide a late-binding, fail-fast spliterator.
              - The mutable source provides a non-late-binding but fail-fast Spliterator.
    
    
    The source increases the likelihood of throwing :code:`ConcurrentModificationException` since the window of potential
                interference is larger.
              - The mutable source provides a late-binding and non-fail-fast Spliterator.
    
    
                The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.
              - The mutable source provides a non-late-binding and non-fail-fast Spliterator.
    
    
    The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after
                construction.
    
    
            **Example.** Here is a class (not a very useful one, except for illustration) that maintains an array in which the
            actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the
            tags.
    
            .. code-block: java
            
             
             class TaggedArray<T> {
               private final Object[] elements; // immutable after construction
               TaggedArray(T[] data, Object[] tags) {
                 int size = data.length;
                 if (tags.length != size) throw new IllegalArgumentException();
                 this.elements = new Object[2 * size];
                 for (int i = 0, j = 0; i < size; ++i) {
                   elements[j++] = data[i];
                   elements[j++] = tags[i];
                 }
               }
            
               public Spliterator<T> spliterator() {
                 return new TaggedArraySpliterator<&gt;(elements, 0, elements.length);
               }
            
               static class TaggedArraySpliterator<T> implements Spliterator<T> {
                 private final Object[] array;
                 private int origin; // current index, advanced on split or traversal
                 private final int fence; // one past the greatest index
            
                 TaggedArraySpliterator(Object[] array, int origin, int fence) {
                   this.array = array; this.origin = origin; this.fence = fence;
                 }
            
                 public void forEachRemaining(Consumer<? super T> action) {
                   for (; origin < fence; origin += 2)
                     action.accept((T) array[origin]);
                 }
            
                 public boolean tryAdvance(Consumer<? super T> action) {
                   if (origin < fence) {
                     action.accept((T) array[origin]);
                     origin += 2;
                     return true;
                   }
                   else // cannot advance
                     return false;
                 }
            
                 public Spliterator<T> trySplit() {
                   int lo = origin; // divide range in half
                   int mid = ((lo + fence) >&gt;> 1) & ~1; // force midpoint to be even
                   if (lo < mid) { // split out left half
                     origin = mid; // reset this Spliterator's origin
                     return new TaggedArraySpliterator<&gt;(array, lo, mid);
                   }
                   else       // too small to split
                     return null;
                 }
            
                 public long estimateSize() {
                   return (long)((fence - origin) / 2);
                 }
            
                 public int characteristics() {
                   return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
                 }
               }
             }
    
            As an example how a parallel computation framework, such as the :code:`java.util.stream` package, would use Spliterator
            in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary
            usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here
            we assume that the order of processing across subtasks doesn't matter; different (forked) tasks may further split and
            process elements concurrently in undetermined order. This example uses a
            :class:`~java.util.concurrent.CountedCompleter`; similar usages apply to other parallel task constructions.
    
            .. code-block: java
            
             static <T> void parEach(TaggedArray<T> a, Consumer<T> action) {
               Spliterator<T> s = a.spliterator();
               long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
               new ParEach(null, s, action, targetBatchSize).invoke();
             }
            
             static class ParEach<T> extends CountedCompleter<Void> {
               final Spliterator<T> spliterator;
               final Consumer<T> action;
               final long targetBatchSize;
            
               ParEach(ParEach<T> parent, Spliterator<T> spliterator,
                       Consumer<T> action, long targetBatchSize) {
                 super(parent);
                 this.spliterator = spliterator; this.action = action;
                 this.targetBatchSize = targetBatchSize;
               }
            
               public void compute() {
                 Spliterator<T> sub;
                 while (spliterator.estimateSize() > targetBatchSize &&amp;
                        (sub = spliterator.trySplit()) != null) {
                   addToPendingCount(1);
                   new ParEach<&gt;(this, sub, action, targetBatchSize).fork();
                 }
                 spliterator.forEachRemaining(action);
                 propagateCompletion();
               }
             }
    
        Implementation Note:
            If the boolean system property :code:`org.openjdk.java.util.stream.tripwire` is set to :code:`true` then diagnostic
            warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.
    
        Since:
            1.8
    
        Also see:
            :class:`~java.util.Collection`
    
    
    """
    ORDERED: typing.ClassVar[int] = ...
    DISTINCT: typing.ClassVar[int] = ...
    SORTED: typing.ClassVar[int] = ...
    SIZED: typing.ClassVar[int] = ...
    NONNULL: typing.ClassVar[int] = ...
    IMMUTABLE: typing.ClassVar[int] = ...
    CONCURRENT: typing.ClassVar[int] = ...
    SUBSIZED: typing.ClassVar[int] = ...
    def characteristics(self) -> int: ...
    def estimateSize(self) -> int: ...
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__T], typing.Callable[[], _Spliterator__T]]) -> None: ...
    def getComparator(self) -> Comparator[_Spliterator__T]: ...
    def getExactSizeIfKnown(self) -> int: ...
    def hasCharacteristics(self, int: int) -> bool: ...
    def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__T], typing.Callable[[], _Spliterator__T]]) -> bool: ...
    def trySplit(self) -> 'Spliterator'[_Spliterator__T]: ...
    class OfDouble(java.util.Spliterator.OfPrimitive[float, java.util.function.DoubleConsumer, java.util.Spliterator.OfDouble]):
        """
        Java class 'java.util.Spliterator$OfDouble'
        
            Interfaces:
                java.util.Spliterator.OfPrimitive
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[], float]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @typing.overload
        def tryAdvance(self, doubleConsumer: java.util.function.DoubleConsumer) -> bool: ...
        @typing.overload
        def tryAdvance(self, object: typing.Any) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[], float]]) -> bool: ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfDouble': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfInt(java.util.Spliterator.OfPrimitive[int, java.util.function.IntConsumer, java.util.Spliterator.OfInt]):
        """
        Java class 'java.util.Spliterator$OfInt'
        
            Interfaces:
                java.util.Spliterator.OfPrimitive
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @typing.overload
        def tryAdvance(self, intConsumer: java.util.function.IntConsumer) -> bool: ...
        @typing.overload
        def tryAdvance(self, object: typing.Any) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> bool: ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfInt': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfLong(java.util.Spliterator.OfPrimitive[int, java.util.function.LongConsumer, java.util.Spliterator.OfLong]):
        """
        Java class 'java.util.Spliterator$OfLong'
        
            Interfaces:
                java.util.Spliterator.OfPrimitive
        
        """
        @typing.overload
        def forEachRemaining(self, object: typing.Any) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @typing.overload
        def tryAdvance(self, longConsumer: java.util.function.LongConsumer) -> bool: ...
        @typing.overload
        def tryAdvance(self, object: typing.Any) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[], int]]) -> bool: ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfLong': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator': ...
        @typing.overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfPrimitive(java.util.Spliterator[_Spliterator__OfPrimitive__T], typing.Generic[_Spliterator__OfPrimitive__T, _Spliterator__OfPrimitive__T_CONS, _Spliterator__OfPrimitive__T_SPLITR]):
        """
        Java class 'java.util.Spliterator$OfPrimitive'
        
            Interfaces:
                java.util.Spliterator
        
        """
        @typing.overload
        def forEachRemaining(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__OfPrimitive__T], typing.Callable[[], _Spliterator__OfPrimitive__T]]) -> None: ...
        @typing.overload
        def tryAdvance(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__OfPrimitive__T], typing.Callable[[], _Spliterator__OfPrimitive__T]]) -> bool: ...
        @typing.overload
        def trySplit(self) -> _Spliterator__OfPrimitive__T_SPLITR: ...
        @typing.overload
        def trySplit(self) -> 'Spliterator': ...

_Spliterators__AbstractSpliterator__T = typing.TypeVar('_Spliterators__AbstractSpliterator__T')  # <T>
class Spliterators(java.lang.Object):
    """
    Java class 'java.util.Spliterators'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    def emptyDoubleSpliterator(cls) -> Spliterator.OfDouble: ...
    @classmethod
    def emptyIntSpliterator(cls) -> Spliterator.OfInt: ...
    @classmethod
    def emptyLongSpliterator(cls) -> Spliterator.OfLong: ...
    _emptySpliterator__T = typing.TypeVar('_emptySpliterator__T')  # <T>
    @classmethod
    def emptySpliterator(cls) -> Spliterator[_emptySpliterator__T]: ...
    _iterator_0__T = typing.TypeVar('_iterator_0__T')  # <T>
    @classmethod
    @typing.overload
    def iterator(cls, spliterator: Spliterator[_iterator_0__T]) -> Iterator[_iterator_0__T]: ...
    @classmethod
    @typing.overload
    def iterator(cls, ofDouble: Spliterator.OfDouble) -> PrimitiveIterator.OfDouble: ...
    @classmethod
    @typing.overload
    def iterator(cls, ofInt: Spliterator.OfInt) -> PrimitiveIterator.OfInt: ...
    @classmethod
    @typing.overload
    def iterator(cls, ofLong: Spliterator.OfLong) -> PrimitiveIterator.OfLong: ...
    _spliterator_0__T = typing.TypeVar('_spliterator_0__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, objectArray: typing.List[typing.Any], int: int) -> Spliterator[_spliterator_0__T]: ...
    _spliterator_1__T = typing.TypeVar('_spliterator_1__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, objectArray: typing.List[typing.Any], int: int, int2: int, int3: int) -> Spliterator[_spliterator_1__T]: ...
    _spliterator_2__T = typing.TypeVar('_spliterator_2__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, collection: typing.Union[Collection[_spliterator_2__T], typing.Sequence[_spliterator_2__T]], int: int) -> Spliterator[_spliterator_2__T]: ...
    _spliterator_3__T = typing.TypeVar('_spliterator_3__T')  # <T>
    @classmethod
    @typing.overload
    def spliterator(cls, iterator: Iterator[_spliterator_3__T], long: int, int: int) -> Spliterator[_spliterator_3__T]: ...
    @classmethod
    @typing.overload
    def spliterator(cls, doubleArray: typing.List[float], int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @typing.overload
    def spliterator(cls, doubleArray: typing.List[float], int: int, int2: int, int3: int) -> Spliterator.OfDouble: ...
    @classmethod
    @typing.overload
    def spliterator(cls, ofDouble: PrimitiveIterator.OfDouble, long: int, int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @typing.overload
    def spliterator(cls, intArray: typing.List[int], int2: int) -> Spliterator.OfInt: ...
    @classmethod
    @typing.overload
    def spliterator(cls, intArray: typing.List[int], int2: int, int3: int, int4: int) -> Spliterator.OfInt: ...
    @classmethod
    @typing.overload
    def spliterator(cls, ofInt: PrimitiveIterator.OfInt, long: int, int: int) -> Spliterator.OfInt: ...
    @classmethod
    @typing.overload
    def spliterator(cls, ofLong: PrimitiveIterator.OfLong, long: int, int: int) -> Spliterator.OfLong: ...
    @classmethod
    @typing.overload
    def spliterator(cls, longArray: typing.List[int], int: int) -> Spliterator.OfLong: ...
    @classmethod
    @typing.overload
    def spliterator(cls, longArray: typing.List[int], int: int, int2: int, int3: int) -> Spliterator.OfLong: ...
    _spliteratorUnknownSize_0__T = typing.TypeVar('_spliteratorUnknownSize_0__T')  # <T>
    @classmethod
    @typing.overload
    def spliteratorUnknownSize(cls, iterator: Iterator[_spliteratorUnknownSize_0__T], int: int) -> Spliterator[_spliteratorUnknownSize_0__T]: ...
    @classmethod
    @typing.overload
    def spliteratorUnknownSize(cls, ofDouble: PrimitiveIterator.OfDouble, int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @typing.overload
    def spliteratorUnknownSize(cls, ofInt: PrimitiveIterator.OfInt, int: int) -> Spliterator.OfInt: ...
    @classmethod
    @typing.overload
    def spliteratorUnknownSize(cls, ofLong: PrimitiveIterator.OfLong, int: int) -> Spliterator.OfLong: ...
    class AbstractDoubleSpliterator(Spliterator.OfDouble):
        """
        Java class 'java.util.Spliterators$AbstractDoubleSpliterator'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Spliterator.OfDouble
        
        """
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @typing.overload
        def trySplit(self) -> Spliterator: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfDouble: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractIntSpliterator(Spliterator.OfInt):
        """
        Java class 'java.util.Spliterators$AbstractIntSpliterator'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Spliterator.OfInt
        
        """
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @typing.overload
        def trySplit(self) -> Spliterator: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfInt: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractLongSpliterator(Spliterator.OfLong):
        """
        Java class 'java.util.Spliterators$AbstractLongSpliterator'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Spliterator.OfLong
        
        """
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @typing.overload
        def trySplit(self) -> Spliterator: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfLong: ...
        @typing.overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractSpliterator(Spliterator[_Spliterators__AbstractSpliterator__T], typing.Generic[_Spliterators__AbstractSpliterator__T]):
        """
        Java class 'java.util.Spliterators$AbstractSpliterator'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.util.Spliterator
        
        """
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator[_Spliterators__AbstractSpliterator__T]: ...

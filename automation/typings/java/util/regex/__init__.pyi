import java.io
import java.lang
import java.util.function
import java.util.stream
import typing


class MatchResult(java.lang.Object):
    """
    public interface MatchResult
    
        The result of a match operation.
    
        This interface contains query methods used to determine the results of a match against a regular expression. The match
        boundaries, groups and group boundaries can be seen but not modified through a :code:`MatchResult`.
    
        Since:
            1.5
    
        Also see:
            :class:`~java.util.regex.Matcher`
    
    
    """
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, int: int) -> int: ...
    @typing.overload
    def group(self) -> java.lang.String: ...
    @typing.overload
    def group(self, int: int) -> java.lang.String: ...
    def groupCount(self) -> int: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, int: int) -> int: ...

class Pattern(java.io.Serializable):
    """
    Java class 'java.util.regex.Pattern'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        UNIX_LINES (int): final static field
        CASE_INSENSITIVE (int): final static field
        COMMENTS (int): final static field
        MULTILINE (int): final static field
        LITERAL (int): final static field
        DOTALL (int): final static field
        UNICODE_CASE (int): final static field
        CANON_EQ (int): final static field
        UNICODE_CHARACTER_CLASS (int): final static field
    
    """
    UNIX_LINES: typing.ClassVar[int] = ...
    CASE_INSENSITIVE: typing.ClassVar[int] = ...
    COMMENTS: typing.ClassVar[int] = ...
    MULTILINE: typing.ClassVar[int] = ...
    LITERAL: typing.ClassVar[int] = ...
    DOTALL: typing.ClassVar[int] = ...
    UNICODE_CASE: typing.ClassVar[int] = ...
    CANON_EQ: typing.ClassVar[int] = ...
    UNICODE_CHARACTER_CLASS: typing.ClassVar[int] = ...
    def asMatchPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    def asPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    @classmethod
    @typing.overload
    def compile(cls, string: java.lang.String) -> 'Pattern': ...
    @classmethod
    @typing.overload
    def compile(cls, string: java.lang.String, int: int) -> 'Pattern': ...
    def flags(self) -> int: ...
    def matcher(self, charSequence: java.lang.CharSequence) -> 'Matcher': ...
    @classmethod
    def matches(cls, string: java.lang.String, charSequence: java.lang.CharSequence) -> bool: ...
    def pattern(self) -> java.lang.String: ...
    @classmethod
    def quote(cls, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def split(self, charSequence: java.lang.CharSequence) -> typing.List[java.lang.String]: ...
    @typing.overload
    def split(self, charSequence: java.lang.CharSequence, int: int) -> typing.List[java.lang.String]: ...
    def splitAsStream(self, charSequence: java.lang.CharSequence) -> java.util.stream.Stream[java.lang.String]: ...
    def toString(self) -> java.lang.String: ...

class PatternSyntaxException(java.lang.IllegalArgumentException):
    """
    Java class 'java.util.regex.PatternSyntaxException'
    
        Extends:
            java.lang.IllegalArgumentException
    
      Constructors:
        * PatternSyntaxException(java.lang.String, java.lang.String, int)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String, int: int): ...
    def getDescription(self) -> java.lang.String: ...
    def getIndex(self) -> int: ...
    def getMessage(self) -> java.lang.String: ...
    def getPattern(self) -> java.lang.String: ...

class Matcher(MatchResult):
    """
    Java class 'java.util.regex.Matcher'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.regex.MatchResult
    
    """
    @typing.overload
    def appendReplacement(self, stringBuffer: java.lang.StringBuffer, string2: java.lang.String) -> 'Matcher': ...
    @typing.overload
    def appendReplacement(self, stringBuilder: java.lang.StringBuilder, string2: java.lang.String) -> 'Matcher': ...
    @typing.overload
    def appendTail(self, stringBuffer: java.lang.StringBuffer) -> java.lang.StringBuffer: ...
    @typing.overload
    def appendTail(self, stringBuilder: java.lang.StringBuilder) -> java.lang.StringBuilder: ...
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, int: int) -> int: ...
    @typing.overload
    def end(self, string: java.lang.String) -> int: ...
    @typing.overload
    def find(self) -> bool: ...
    @typing.overload
    def find(self, int: int) -> bool: ...
    @typing.overload
    def group(self) -> java.lang.String: ...
    @typing.overload
    def group(self, int: int) -> java.lang.String: ...
    @typing.overload
    def group(self, string: java.lang.String) -> java.lang.String: ...
    def groupCount(self) -> int: ...
    def hasAnchoringBounds(self) -> bool: ...
    def hasTransparentBounds(self) -> bool: ...
    def hitEnd(self) -> bool: ...
    def lookingAt(self) -> bool: ...
    def matches(self) -> bool: ...
    def pattern(self) -> Pattern: ...
    @classmethod
    def quoteReplacement(cls, string: java.lang.String) -> java.lang.String: ...
    def region(self, int: int, int2: int) -> 'Matcher': ...
    def regionEnd(self) -> int: ...
    def regionStart(self) -> int: ...
    @typing.overload
    def replaceAll(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def replaceAll(self, function: typing.Union[java.util.function.Function[MatchResult, java.lang.String], typing.Callable[[MatchResult], java.lang.String]]) -> java.lang.String: ...
    @typing.overload
    def replaceFirst(self, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def replaceFirst(self, function: typing.Union[java.util.function.Function[MatchResult, java.lang.String], typing.Callable[[MatchResult], java.lang.String]]) -> java.lang.String: ...
    def requireEnd(self) -> bool: ...
    @typing.overload
    def reset(self) -> 'Matcher': ...
    @typing.overload
    def reset(self, charSequence: java.lang.CharSequence) -> 'Matcher': ...
    def results(self) -> java.util.stream.Stream[MatchResult]: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, int: int) -> int: ...
    @typing.overload
    def start(self, string: java.lang.String) -> int: ...
    def toMatchResult(self) -> MatchResult: ...
    def toString(self) -> java.lang.String: ...
    def useAnchoringBounds(self, boolean: bool) -> 'Matcher': ...
    def usePattern(self, pattern: Pattern) -> 'Matcher': ...
    def useTransparentBounds(self, boolean: bool) -> 'Matcher': ...

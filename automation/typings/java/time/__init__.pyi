import java
import java.io
import java.lang
import java.time.chrono
import java.time.format
import java.time.temporal
import java.time.zone
import java.util
import java.util.stream
import typing


class Clock(java.lang.Object):
    """
    Java class 'java.time.Clock'
    
        Extends:
            java.lang.Object
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def fixed(cls, instant: 'Instant', zoneId: 'ZoneId') -> 'Clock': ...
    def getZone(self) -> 'ZoneId': ...
    def hashCode(self) -> int: ...
    def instant(self) -> 'Instant': ...
    def millis(self) -> int: ...
    @classmethod
    def offset(cls, clock: 'Clock', duration: 'Duration') -> 'Clock': ...
    @classmethod
    def system(cls, zoneId: 'ZoneId') -> 'Clock': ...
    @classmethod
    def systemDefaultZone(cls) -> 'Clock': ...
    @classmethod
    def systemUTC(cls) -> 'Clock': ...
    @classmethod
    def tick(cls, clock: 'Clock', duration: 'Duration') -> 'Clock': ...
    @classmethod
    def tickMillis(cls, zoneId: 'ZoneId') -> 'Clock': ...
    @classmethod
    def tickMinutes(cls, zoneId: 'ZoneId') -> 'Clock': ...
    @classmethod
    def tickSeconds(cls, zoneId: 'ZoneId') -> 'Clock': ...
    def withZone(self, zoneId: 'ZoneId') -> 'Clock': ...

class DateTimeException(java.lang.RuntimeException):
    """
    Java class 'java.time.DateTimeException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * DateTimeException(java.lang.String)
        * DateTimeException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...

class DayOfWeek(java.lang.Enum[java.time.DayOfWeek], java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    """
    Java class 'java.time.DayOfWeek'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.temporal.TemporalAccessor,
            java.time.temporal.TemporalAdjuster
    
      Attributes:
        MONDAY (java.time.DayOfWeek): final static enum constant
        TUESDAY (java.time.DayOfWeek): final static enum constant
        WEDNESDAY (java.time.DayOfWeek): final static enum constant
        THURSDAY (java.time.DayOfWeek): final static enum constant
        FRIDAY (java.time.DayOfWeek): final static enum constant
        SATURDAY (java.time.DayOfWeek): final static enum constant
        SUNDAY (java.time.DayOfWeek): final static enum constant
    
    """
    MONDAY: typing.ClassVar['DayOfWeek'] = ...
    TUESDAY: typing.ClassVar['DayOfWeek'] = ...
    WEDNESDAY: typing.ClassVar['DayOfWeek'] = ...
    THURSDAY: typing.ClassVar['DayOfWeek'] = ...
    FRIDAY: typing.ClassVar['DayOfWeek'] = ...
    SATURDAY: typing.ClassVar['DayOfWeek'] = ...
    SUNDAY: typing.ClassVar['DayOfWeek'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    def minus(self, long: int) -> 'DayOfWeek': ...
    @classmethod
    def of(cls, int: int) -> 'DayOfWeek': ...
    def plus(self, long: int) -> 'DayOfWeek': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'DayOfWeek': ...
    @classmethod
    def values(cls) -> typing.List['DayOfWeek']: ...

class Duration(java.time.temporal.TemporalAmount, java.lang.Comparable[java.time.Duration], java.io.Serializable):
    """
    Java class 'java.time.Duration'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.TemporalAmount, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        ZERO (java.time.Duration): final static field
    
    """
    ZERO: typing.ClassVar['Duration'] = ...
    def abs(self) -> 'Duration': ...
    def addTo(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    @classmethod
    def between(cls, temporal: java.time.temporal.Temporal, temporal2: java.time.temporal.Temporal) -> 'Duration': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, duration: 'Duration') -> int: ...
    @typing.overload
    def dividedBy(self, long: int) -> 'Duration': ...
    @typing.overload
    def dividedBy(self, duration: 'Duration') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def getNano(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def minus(self, duration: 'Duration') -> 'Duration': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Duration': ...
    def minusDays(self, long: int) -> 'Duration': ...
    def minusHours(self, long: int) -> 'Duration': ...
    def minusMillis(self, long: int) -> 'Duration': ...
    def minusMinutes(self, long: int) -> 'Duration': ...
    def minusNanos(self, long: int) -> 'Duration': ...
    def minusSeconds(self, long: int) -> 'Duration': ...
    def multipliedBy(self, long: int) -> 'Duration': ...
    def negated(self) -> 'Duration': ...
    @classmethod
    def of(cls, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Duration': ...
    @classmethod
    def ofDays(cls, long: int) -> 'Duration': ...
    @classmethod
    def ofHours(cls, long: int) -> 'Duration': ...
    @classmethod
    def ofMillis(cls, long: int) -> 'Duration': ...
    @classmethod
    def ofMinutes(cls, long: int) -> 'Duration': ...
    @classmethod
    def ofNanos(cls, long: int) -> 'Duration': ...
    @classmethod
    @typing.overload
    def ofSeconds(cls, long: int) -> 'Duration': ...
    @classmethod
    @typing.overload
    def ofSeconds(cls, long: int, long2: int) -> 'Duration': ...
    @classmethod
    def parse(cls, charSequence: java.lang.CharSequence) -> 'Duration': ...
    @typing.overload
    def plus(self, duration: 'Duration') -> 'Duration': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Duration': ...
    def plusDays(self, long: int) -> 'Duration': ...
    def plusHours(self, long: int) -> 'Duration': ...
    def plusMillis(self, long: int) -> 'Duration': ...
    def plusMinutes(self, long: int) -> 'Duration': ...
    def plusNanos(self, long: int) -> 'Duration': ...
    def plusSeconds(self, long: int) -> 'Duration': ...
    def subtractFrom(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def toDays(self) -> int: ...
    def toDaysPart(self) -> int: ...
    def toHours(self) -> int: ...
    def toHoursPart(self) -> int: ...
    def toMillis(self) -> int: ...
    def toMillisPart(self) -> int: ...
    def toMinutes(self) -> int: ...
    def toMinutesPart(self) -> int: ...
    def toNanos(self) -> int: ...
    def toNanosPart(self) -> int: ...
    def toSeconds(self) -> int: ...
    def toSecondsPart(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'Duration': ...
    def withNanos(self, int: int) -> 'Duration': ...
    def withSeconds(self, long: int) -> 'Duration': ...

class Instant(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.Instant], java.io.Serializable):
    """
    Java class 'java.time.Instant'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        EPOCH (java.time.Instant): final static field
        MIN (java.time.Instant): final static field
        MAX (java.time.Instant): final static field
    
    """
    EPOCH: typing.ClassVar['Instant'] = ...
    MIN: typing.ClassVar['Instant'] = ...
    MAX: typing.ClassVar['Instant'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atOffset(self, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    def atZone(self, zoneId: 'ZoneId') -> 'ZonedDateTime': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, instant: 'Instant') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getEpochSecond(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getNano(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, instant: 'Instant') -> bool: ...
    def isBefore(self, instant: 'Instant') -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Instant': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Instant': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusMillis(self, long: int) -> 'Instant': ...
    def minusNanos(self, long: int) -> 'Instant': ...
    def minusSeconds(self, long: int) -> 'Instant': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'Instant': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'Instant': ...
    @classmethod
    def ofEpochMilli(cls, long: int) -> 'Instant': ...
    @classmethod
    @typing.overload
    def ofEpochSecond(cls, long: int) -> 'Instant': ...
    @classmethod
    @typing.overload
    def ofEpochSecond(cls, long: int, long2: int) -> 'Instant': ...
    @classmethod
    def parse(cls, charSequence: java.lang.CharSequence) -> 'Instant': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Instant': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Instant': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusMillis(self, long: int) -> 'Instant': ...
    def plusNanos(self, long: int) -> 'Instant': ...
    def plusSeconds(self, long: int) -> 'Instant': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochMilli(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'Instant': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

class LocalDate(java.time.chrono.ChronoLocalDate, java.io.Serializable):
    """
    Java class 'java.time.LocalDate'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster,
            java.time.chrono.ChronoLocalDate, java.io.Serializable
    
      Attributes:
        MIN (java.time.LocalDate): final static field
        MAX (java.time.LocalDate): final static field
        EPOCH (java.time.LocalDate): final static field
    
    """
    MIN: typing.ClassVar['LocalDate'] = ...
    MAX: typing.ClassVar['LocalDate'] = ...
    EPOCH: typing.ClassVar['LocalDate'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    @typing.overload
    def atStartOfDay(self) -> 'LocalDateTime': ...
    @typing.overload
    def atStartOfDay(self, zoneId: 'ZoneId') -> 'ZonedDateTime': ...
    @typing.overload
    def atTime(self, int: int, int2: int) -> 'LocalDateTime': ...
    @typing.overload
    def atTime(self, int: int, int2: int, int3: int) -> 'LocalDateTime': ...
    @typing.overload
    def atTime(self, int: int, int2: int, int3: int, int4: int) -> 'LocalDateTime': ...
    @typing.overload
    def atTime(self, localTime: 'LocalTime') -> 'LocalDateTime': ...
    @typing.overload
    def atTime(self, offsetTime: 'OffsetTime') -> 'OffsetDateTime': ...
    @typing.overload
    def atTime(self, localTime: 'LocalTime') -> java.time.chrono.ChronoLocalDateTime: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> int: ...
    @typing.overload
    def datesUntil(self, localDate: 'LocalDate') -> java.util.stream.Stream['LocalDate']: ...
    @typing.overload
    def datesUntil(self, localDate: 'LocalDate', period: 'Period') -> java.util.stream.Stream['LocalDate']: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    @typing.overload
    def getChronology(self) -> java.time.chrono.Chronology: ...
    @typing.overload
    def getChronology(self) -> java.time.chrono.IsoChronology: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    @typing.overload
    def getEra(self) -> java.time.chrono.Era: ...
    @typing.overload
    def getEra(self) -> java.time.chrono.IsoEra: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMonth(self) -> 'Month': ...
    def getMonthValue(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> bool: ...
    def isBefore(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> bool: ...
    def isEqual(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoLocalDate: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoLocalDate: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusDays(self, long: int) -> 'LocalDate': ...
    def minusMonths(self, long: int) -> 'LocalDate': ...
    def minusWeeks(self, long: int) -> 'LocalDate': ...
    def minusYears(self, long: int) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, month: 'Month', int2: int) -> 'LocalDate': ...
    @classmethod
    def ofEpochDay(cls, long: int) -> 'LocalDate': ...
    @classmethod
    def ofInstant(cls, instant: Instant, zoneId: 'ZoneId') -> 'LocalDate': ...
    @classmethod
    def ofYearDay(cls, int: int, int2: int) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'LocalDate': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'LocalDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoLocalDate: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoLocalDate: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusDays(self, long: int) -> 'LocalDate': ...
    def plusMonths(self, long: int) -> 'LocalDate': ...
    def plusWeeks(self, long: int) -> 'LocalDate': ...
    def plusYears(self, long: int) -> 'LocalDate': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toEpochSecond(self, localTime: 'LocalTime', zoneOffset: 'ZoneOffset') -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> 'Period': ...
    @typing.overload
    def until(self, chronoLocalDate: java.time.chrono.ChronoLocalDate) -> java.time.chrono.ChronoPeriod: ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withDayOfMonth(self, int: int) -> 'LocalDate': ...
    def withDayOfYear(self, int: int) -> 'LocalDate': ...
    def withMonth(self, int: int) -> 'LocalDate': ...
    def withYear(self, int: int) -> 'LocalDate': ...

class LocalDateTime(java.time.chrono.ChronoLocalDateTime[LocalDate], java.io.Serializable):
    """
    Java class 'java.time.LocalDateTime'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster,
            java.time.chrono.ChronoLocalDateTime, java.io.Serializable
    
      Attributes:
        MIN (java.time.LocalDateTime): final static field
        MAX (java.time.LocalDateTime): final static field
    
    """
    MIN: typing.ClassVar['LocalDateTime'] = ...
    MAX: typing.ClassVar['LocalDateTime'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atOffset(self, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    @typing.overload
    def atZone(self, zoneId: 'ZoneId') -> 'ZonedDateTime': ...
    @typing.overload
    def atZone(self, zoneId: 'ZoneId') -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronoLocalDateTime: java.time.chrono.ChronoLocalDateTime[typing.Any]) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> 'Month': ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, chronoLocalDateTime: java.time.chrono.ChronoLocalDateTime[typing.Any]) -> bool: ...
    def isBefore(self, chronoLocalDateTime: java.time.chrono.ChronoLocalDateTime[typing.Any]) -> bool: ...
    def isEqual(self, chronoLocalDateTime: java.time.chrono.ChronoLocalDateTime[typing.Any]) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalDateTime': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalDateTime': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoLocalDateTime: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoLocalDateTime: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusDays(self, long: int) -> 'LocalDateTime': ...
    def minusHours(self, long: int) -> 'LocalDateTime': ...
    def minusMinutes(self, long: int) -> 'LocalDateTime': ...
    def minusMonths(self, long: int) -> 'LocalDateTime': ...
    def minusNanos(self, long: int) -> 'LocalDateTime': ...
    def minusSeconds(self, long: int) -> 'LocalDateTime': ...
    def minusWeeks(self, long: int) -> 'LocalDateTime': ...
    def minusYears(self, long: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, int5: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, month: 'Month', int2: int, int3: int, int4: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, month: 'Month', int2: int, int3: int, int4: int, int5: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, month: 'Month', int2: int, int3: int, int4: int, int5: int, int6: int) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, localDate: LocalDate, localTime: 'LocalTime') -> 'LocalDateTime': ...
    @classmethod
    def ofEpochSecond(cls, long: int, int: int, zoneOffset: 'ZoneOffset') -> 'LocalDateTime': ...
    @classmethod
    def ofInstant(cls, instant: Instant, zoneId: 'ZoneId') -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'LocalDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'LocalDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalDateTime': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoLocalDateTime: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoLocalDateTime: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusDays(self, long: int) -> 'LocalDateTime': ...
    def plusHours(self, long: int) -> 'LocalDateTime': ...
    def plusMinutes(self, long: int) -> 'LocalDateTime': ...
    def plusMonths(self, long: int) -> 'LocalDateTime': ...
    def plusNanos(self, long: int) -> 'LocalDateTime': ...
    def plusSeconds(self, long: int) -> 'LocalDateTime': ...
    def plusWeeks(self, long: int) -> 'LocalDateTime': ...
    def plusYears(self, long: int) -> 'LocalDateTime': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def toLocalDate(self) -> LocalDate: ...
    @typing.overload
    def toLocalDate(self) -> java.time.chrono.ChronoLocalDate: ...
    def toLocalTime(self) -> 'LocalTime': ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalDateTime': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withDayOfMonth(self, int: int) -> 'LocalDateTime': ...
    def withDayOfYear(self, int: int) -> 'LocalDateTime': ...
    def withHour(self, int: int) -> 'LocalDateTime': ...
    def withMinute(self, int: int) -> 'LocalDateTime': ...
    def withMonth(self, int: int) -> 'LocalDateTime': ...
    def withNano(self, int: int) -> 'LocalDateTime': ...
    def withSecond(self, int: int) -> 'LocalDateTime': ...
    def withYear(self, int: int) -> 'LocalDateTime': ...

class LocalTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.LocalTime], java.io.Serializable):
    """
    Java class 'java.time.LocalTime'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        MIN (java.time.LocalTime): final static field
        MAX (java.time.LocalTime): final static field
        MIDNIGHT (java.time.LocalTime): final static field
        NOON (java.time.LocalTime): final static field
    
    """
    MIN: typing.ClassVar['LocalTime'] = ...
    MAX: typing.ClassVar['LocalTime'] = ...
    MIDNIGHT: typing.ClassVar['LocalTime'] = ...
    NOON: typing.ClassVar['LocalTime'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atDate(self, localDate: LocalDate) -> LocalDateTime: ...
    def atOffset(self, zoneOffset: 'ZoneOffset') -> 'OffsetTime': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, localTime: 'LocalTime') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMinute(self) -> int: ...
    def getNano(self) -> int: ...
    def getSecond(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, localTime: 'LocalTime') -> bool: ...
    def isBefore(self, localTime: 'LocalTime') -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalTime': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalTime': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusHours(self, long: int) -> 'LocalTime': ...
    def minusMinutes(self, long: int) -> 'LocalTime': ...
    def minusNanos(self, long: int) -> 'LocalTime': ...
    def minusSeconds(self, long: int) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int) -> 'LocalTime': ...
    @classmethod
    def ofInstant(cls, instant: Instant, zoneId: 'ZoneId') -> 'LocalTime': ...
    @classmethod
    def ofNanoOfDay(cls, long: int) -> 'LocalTime': ...
    @classmethod
    def ofSecondOfDay(cls, long: int) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'LocalTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'LocalTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'LocalTime': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusHours(self, long: int) -> 'LocalTime': ...
    def plusMinutes(self, long: int) -> 'LocalTime': ...
    def plusNanos(self, long: int) -> 'LocalTime': ...
    def plusSeconds(self, long: int) -> 'LocalTime': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochSecond(self, localDate: LocalDate, zoneOffset: 'ZoneOffset') -> int: ...
    def toNanoOfDay(self) -> int: ...
    def toSecondOfDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'LocalTime': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withHour(self, int: int) -> 'LocalTime': ...
    def withMinute(self, int: int) -> 'LocalTime': ...
    def withNano(self, int: int) -> 'LocalTime': ...
    def withSecond(self, int: int) -> 'LocalTime': ...

class Month(java.lang.Enum[java.time.Month], java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    """
    Java class 'java.time.Month'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.temporal.TemporalAccessor,
            java.time.temporal.TemporalAdjuster
    
      Attributes:
        JANUARY (java.time.Month): final static enum constant
        FEBRUARY (java.time.Month): final static enum constant
        MARCH (java.time.Month): final static enum constant
        APRIL (java.time.Month): final static enum constant
        MAY (java.time.Month): final static enum constant
        JUNE (java.time.Month): final static enum constant
        JULY (java.time.Month): final static enum constant
        AUGUST (java.time.Month): final static enum constant
        SEPTEMBER (java.time.Month): final static enum constant
        OCTOBER (java.time.Month): final static enum constant
        NOVEMBER (java.time.Month): final static enum constant
        DECEMBER (java.time.Month): final static enum constant
    
    """
    JANUARY: typing.ClassVar['Month'] = ...
    FEBRUARY: typing.ClassVar['Month'] = ...
    MARCH: typing.ClassVar['Month'] = ...
    APRIL: typing.ClassVar['Month'] = ...
    MAY: typing.ClassVar['Month'] = ...
    JUNE: typing.ClassVar['Month'] = ...
    JULY: typing.ClassVar['Month'] = ...
    AUGUST: typing.ClassVar['Month'] = ...
    SEPTEMBER: typing.ClassVar['Month'] = ...
    OCTOBER: typing.ClassVar['Month'] = ...
    NOVEMBER: typing.ClassVar['Month'] = ...
    DECEMBER: typing.ClassVar['Month'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def firstDayOfYear(self, boolean: bool) -> int: ...
    def firstMonthOfQuarter(self) -> 'Month': ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    def length(self, boolean: bool) -> int: ...
    def maxLength(self) -> int: ...
    def minLength(self) -> int: ...
    def minus(self, long: int) -> 'Month': ...
    @classmethod
    def of(cls, int: int) -> 'Month': ...
    def plus(self, long: int) -> 'Month': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'Month': ...
    @classmethod
    def values(cls) -> typing.List['Month']: ...

class MonthDay(java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.MonthDay], java.io.Serializable):
    """
    Java class 'java.time.MonthDay'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.TemporalAccessor,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
    """
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atYear(self, int: int) -> LocalDate: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, monthDay: 'MonthDay') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, monthDay: 'MonthDay') -> bool: ...
    def isBefore(self, monthDay: 'MonthDay') -> bool: ...
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    def isValidYear(self, int: int) -> bool: ...
    @classmethod
    @typing.overload
    def now(cls) -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int) -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def of(cls, month: Month, int: int) -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'MonthDay': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'MonthDay': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toString(self) -> java.lang.String: ...
    def withDayOfMonth(self, int: int) -> 'MonthDay': ...
    def withMonth(self, int: int) -> 'MonthDay': ...

class OffsetDateTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.OffsetDateTime], java.io.Serializable):
    """
    Java class 'java.time.OffsetDateTime'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        MIN (java.time.OffsetDateTime): final static field
        MAX (java.time.OffsetDateTime): final static field
    
    """
    MIN: typing.ClassVar['OffsetDateTime'] = ...
    MAX: typing.ClassVar['OffsetDateTime'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atZoneSameInstant(self, zoneId: 'ZoneId') -> 'ZonedDateTime': ...
    def atZoneSimilarLocal(self, zoneId: 'ZoneId') -> 'ZonedDateTime': ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, offsetDateTime: 'OffsetDateTime') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> 'ZoneOffset': ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, offsetDateTime: 'OffsetDateTime') -> bool: ...
    def isBefore(self, offsetDateTime: 'OffsetDateTime') -> bool: ...
    def isEqual(self, offsetDateTime: 'OffsetDateTime') -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'OffsetDateTime': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetDateTime': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusDays(self, long: int) -> 'OffsetDateTime': ...
    def minusHours(self, long: int) -> 'OffsetDateTime': ...
    def minusMinutes(self, long: int) -> 'OffsetDateTime': ...
    def minusMonths(self, long: int) -> 'OffsetDateTime': ...
    def minusNanos(self, long: int) -> 'OffsetDateTime': ...
    def minusSeconds(self, long: int) -> 'OffsetDateTime': ...
    def minusWeeks(self, long: int) -> 'OffsetDateTime': ...
    def minusYears(self, long: int) -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, localDate: LocalDate, localTime: LocalTime, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, localDateTime: LocalDateTime, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    @classmethod
    def ofInstant(cls, instant: Instant, zoneId: 'ZoneId') -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'OffsetDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'OffsetDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'OffsetDateTime': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusDays(self, long: int) -> 'OffsetDateTime': ...
    def plusHours(self, long: int) -> 'OffsetDateTime': ...
    def plusMinutes(self, long: int) -> 'OffsetDateTime': ...
    def plusMonths(self, long: int) -> 'OffsetDateTime': ...
    def plusNanos(self, long: int) -> 'OffsetDateTime': ...
    def plusSeconds(self, long: int) -> 'OffsetDateTime': ...
    def plusWeeks(self, long: int) -> 'OffsetDateTime': ...
    def plusYears(self, long: int) -> 'OffsetDateTime': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    @classmethod
    def timeLineOrder(cls) -> java.util.Comparator['OffsetDateTime']: ...
    def toEpochSecond(self) -> int: ...
    def toInstant(self) -> Instant: ...
    def toLocalDate(self) -> LocalDate: ...
    def toLocalDateTime(self) -> LocalDateTime: ...
    def toLocalTime(self) -> LocalTime: ...
    def toOffsetTime(self) -> 'OffsetTime': ...
    def toString(self) -> java.lang.String: ...
    def toZonedDateTime(self) -> 'ZonedDateTime': ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetDateTime': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withDayOfMonth(self, int: int) -> 'OffsetDateTime': ...
    def withDayOfYear(self, int: int) -> 'OffsetDateTime': ...
    def withHour(self, int: int) -> 'OffsetDateTime': ...
    def withMinute(self, int: int) -> 'OffsetDateTime': ...
    def withMonth(self, int: int) -> 'OffsetDateTime': ...
    def withNano(self, int: int) -> 'OffsetDateTime': ...
    def withOffsetSameInstant(self, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    def withOffsetSameLocal(self, zoneOffset: 'ZoneOffset') -> 'OffsetDateTime': ...
    def withSecond(self, int: int) -> 'OffsetDateTime': ...
    def withYear(self, int: int) -> 'OffsetDateTime': ...

class OffsetTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.OffsetTime], java.io.Serializable):
    """
    Java class 'java.time.OffsetTime'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        MIN (java.time.OffsetTime): final static field
        MAX (java.time.OffsetTime): final static field
    
    """
    MIN: typing.ClassVar['OffsetTime'] = ...
    MAX: typing.ClassVar['OffsetTime'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atDate(self, localDate: LocalDate) -> OffsetDateTime: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, offsetTime: 'OffsetTime') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMinute(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> 'ZoneOffset': ...
    def getSecond(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, offsetTime: 'OffsetTime') -> bool: ...
    def isBefore(self, offsetTime: 'OffsetTime') -> bool: ...
    def isEqual(self, offsetTime: 'OffsetTime') -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'OffsetTime': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetTime': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusHours(self, long: int) -> 'OffsetTime': ...
    def minusMinutes(self, long: int) -> 'OffsetTime': ...
    def minusNanos(self, long: int) -> 'OffsetTime': ...
    def minusSeconds(self, long: int) -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, zoneOffset: 'ZoneOffset') -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def of(cls, localTime: LocalTime, zoneOffset: 'ZoneOffset') -> 'OffsetTime': ...
    @classmethod
    def ofInstant(cls, instant: Instant, zoneId: 'ZoneId') -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'OffsetTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'OffsetTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'OffsetTime': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusHours(self, long: int) -> 'OffsetTime': ...
    def plusMinutes(self, long: int) -> 'OffsetTime': ...
    def plusNanos(self, long: int) -> 'OffsetTime': ...
    def plusSeconds(self, long: int) -> 'OffsetTime': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochSecond(self, localDate: LocalDate) -> int: ...
    def toLocalTime(self) -> LocalTime: ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'OffsetTime': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withHour(self, int: int) -> 'OffsetTime': ...
    def withMinute(self, int: int) -> 'OffsetTime': ...
    def withNano(self, int: int) -> 'OffsetTime': ...
    def withOffsetSameInstant(self, zoneOffset: 'ZoneOffset') -> 'OffsetTime': ...
    def withOffsetSameLocal(self, zoneOffset: 'ZoneOffset') -> 'OffsetTime': ...
    def withSecond(self, int: int) -> 'OffsetTime': ...

class Period(java.time.chrono.ChronoPeriod, java.io.Serializable):
    """
    Java class 'java.time.Period'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.chrono.ChronoPeriod, java.io.Serializable
    
      Attributes:
        ZERO (java.time.Period): final static field
    
    """
    ZERO: typing.ClassVar['Period'] = ...
    def addTo(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    @classmethod
    def between(cls, localDate: LocalDate, localDate2: LocalDate) -> 'Period': ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    @typing.overload
    def getChronology(self) -> java.time.chrono.Chronology: ...
    @typing.overload
    def getChronology(self) -> java.time.chrono.IsoChronology: ...
    def getDays(self) -> int: ...
    def getMonths(self) -> int: ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def getYears(self) -> int: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Period': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoPeriod: ...
    def minusDays(self, long: int) -> 'Period': ...
    def minusMonths(self, long: int) -> 'Period': ...
    def minusYears(self, long: int) -> 'Period': ...
    @typing.overload
    def multipliedBy(self, int: int) -> 'Period': ...
    @typing.overload
    def multipliedBy(self, int: int) -> java.time.chrono.ChronoPeriod: ...
    @typing.overload
    def negated(self) -> 'Period': ...
    @typing.overload
    def negated(self) -> java.time.chrono.ChronoPeriod: ...
    @typing.overload
    def normalized(self) -> 'Period': ...
    @typing.overload
    def normalized(self) -> java.time.chrono.ChronoPeriod: ...
    @classmethod
    def of(cls, int: int, int2: int, int3: int) -> 'Period': ...
    @classmethod
    def ofDays(cls, int: int) -> 'Period': ...
    @classmethod
    def ofMonths(cls, int: int) -> 'Period': ...
    @classmethod
    def ofWeeks(cls, int: int) -> 'Period': ...
    @classmethod
    def ofYears(cls, int: int) -> 'Period': ...
    @classmethod
    def parse(cls, charSequence: java.lang.CharSequence) -> 'Period': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Period': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoPeriod: ...
    def plusDays(self, long: int) -> 'Period': ...
    def plusMonths(self, long: int) -> 'Period': ...
    def plusYears(self, long: int) -> 'Period': ...
    def subtractFrom(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def toString(self) -> java.lang.String: ...
    def toTotalMonths(self) -> int: ...
    def withDays(self, int: int) -> 'Period': ...
    def withMonths(self, int: int) -> 'Period': ...
    def withYears(self, int: int) -> 'Period': ...

class Year(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.Year], java.io.Serializable):
    """
    Java class 'java.time.Year'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        MIN_VALUE (int): final static field
        MAX_VALUE (int): final static field
    
    """
    MIN_VALUE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atDay(self, int: int) -> LocalDate: ...
    @typing.overload
    def atMonth(self, int: int) -> 'YearMonth': ...
    @typing.overload
    def atMonth(self, month: Month) -> 'YearMonth': ...
    def atMonthDay(self, monthDay: MonthDay) -> LocalDate: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, year: 'Year') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getValue(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, year: 'Year') -> bool: ...
    def isBefore(self, year: 'Year') -> bool: ...
    @typing.overload
    def isLeap(self) -> bool: ...
    @classmethod
    @typing.overload
    def isLeap(cls, long: int) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    def isValidMonthDay(self, monthDay: MonthDay) -> bool: ...
    def length(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Year': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Year': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusYears(self, long: int) -> 'Year': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'Year': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'Year': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'Year': ...
    @classmethod
    def of(cls, int: int) -> 'Year': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'Year': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'Year': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'Year': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'Year': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusYears(self, long: int) -> 'Year': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toString(self) -> java.lang.String: ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

class YearMonth(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.YearMonth], java.io.Serializable):
    """
    Java class 'java.time.YearMonth'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
    """
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atDay(self, int: int) -> LocalDate: ...
    def atEndOfMonth(self) -> LocalDate: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, yearMonth: 'YearMonth') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, yearMonth: 'YearMonth') -> bool: ...
    def isBefore(self, yearMonth: 'YearMonth') -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    def isValidDay(self, int: int) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'YearMonth': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'YearMonth': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusMonths(self, long: int) -> 'YearMonth': ...
    def minusYears(self, long: int) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: 'ZoneId') -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, month: Month) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'YearMonth': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'YearMonth': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'YearMonth': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'YearMonth': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusMonths(self, long: int) -> 'YearMonth': ...
    def plusYears(self, long: int) -> 'YearMonth': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toString(self) -> java.lang.String: ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withMonth(self, int: int) -> 'YearMonth': ...
    def withYear(self, int: int) -> 'YearMonth': ...

class ZoneId(java.io.Serializable):
    """
    Java class 'java.time.ZoneId'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        SHORT_IDS (java.util.Map): final static field
    
    """
    SHORT_IDS: typing.ClassVar[java.util.Map] = ...
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def getAvailableZoneIds(cls) -> java.util.Set[java.lang.String]: ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def getRules(self) -> java.time.zone.ZoneRules: ...
    def hashCode(self) -> int: ...
    def normalized(self) -> 'ZoneId': ...
    @classmethod
    @typing.overload
    def of(cls, string: java.lang.String) -> 'ZoneId': ...
    @classmethod
    @typing.overload
    def of(cls, string: java.lang.String, map: typing.Union[java.util.Map[java.lang.String, java.lang.String], typing.Mapping[java.lang.String, java.lang.String]]) -> 'ZoneId': ...
    @classmethod
    def ofOffset(cls, string: java.lang.String, zoneOffset: 'ZoneOffset') -> 'ZoneId': ...
    @classmethod
    def systemDefault(cls) -> 'ZoneId': ...
    def toString(self) -> java.lang.String: ...

class ZonedDateTime(java.time.chrono.ChronoZonedDateTime[LocalDate], java.io.Serializable):
    """
    Java class 'java.time.ZonedDateTime'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.chrono.ChronoZonedDateTime, java.io.Serializable
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> 'ZoneOffset': ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def getZone(self) -> ZoneId: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ZonedDateTime': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ZonedDateTime': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def minusDays(self, long: int) -> 'ZonedDateTime': ...
    def minusHours(self, long: int) -> 'ZonedDateTime': ...
    def minusMinutes(self, long: int) -> 'ZonedDateTime': ...
    def minusMonths(self, long: int) -> 'ZonedDateTime': ...
    def minusNanos(self, long: int) -> 'ZonedDateTime': ...
    def minusSeconds(self, long: int) -> 'ZonedDateTime': ...
    def minusWeeks(self, long: int) -> 'ZonedDateTime': ...
    def minusYears(self, long: int) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def now(cls) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, clock: Clock) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, localDate: LocalDate, localTime: LocalTime, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def of(cls, localDateTime: LocalDateTime, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def ofInstant(cls, instant: Instant, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def ofInstant(cls, localDateTime: LocalDateTime, zoneOffset: 'ZoneOffset', zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    def ofLocal(cls, localDateTime: LocalDateTime, zoneId: ZoneId, zoneOffset: 'ZoneOffset') -> 'ZonedDateTime': ...
    @classmethod
    def ofStrict(cls, localDateTime: LocalDateTime, zoneOffset: 'ZoneOffset', zoneId: ZoneId) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence) -> 'ZonedDateTime': ...
    @classmethod
    @typing.overload
    def parse(cls, charSequence: java.lang.CharSequence, dateTimeFormatter: java.time.format.DateTimeFormatter) -> 'ZonedDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ZonedDateTime': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ZonedDateTime': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def plusDays(self, long: int) -> 'ZonedDateTime': ...
    def plusHours(self, long: int) -> 'ZonedDateTime': ...
    def plusMinutes(self, long: int) -> 'ZonedDateTime': ...
    def plusMonths(self, long: int) -> 'ZonedDateTime': ...
    def plusNanos(self, long: int) -> 'ZonedDateTime': ...
    def plusSeconds(self, long: int) -> 'ZonedDateTime': ...
    def plusWeeks(self, long: int) -> 'ZonedDateTime': ...
    def plusYears(self, long: int) -> 'ZonedDateTime': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def toLocalDate(self) -> LocalDate: ...
    @typing.overload
    def toLocalDate(self) -> java.time.chrono.ChronoLocalDate: ...
    @typing.overload
    def toLocalDateTime(self) -> LocalDateTime: ...
    @typing.overload
    def toLocalDateTime(self) -> java.time.chrono.ChronoLocalDateTime: ...
    def toLocalTime(self) -> LocalTime: ...
    def toOffsetDateTime(self) -> OffsetDateTime: ...
    def toString(self) -> java.lang.String: ...
    def truncatedTo(self, temporalUnit: java.time.temporal.TemporalUnit) -> 'ZonedDateTime': ...
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withDayOfMonth(self, int: int) -> 'ZonedDateTime': ...
    def withDayOfYear(self, int: int) -> 'ZonedDateTime': ...
    @typing.overload
    def withEarlierOffsetAtOverlap(self) -> 'ZonedDateTime': ...
    @typing.overload
    def withEarlierOffsetAtOverlap(self) -> java.time.chrono.ChronoZonedDateTime: ...
    def withFixedOffsetZone(self) -> 'ZonedDateTime': ...
    def withHour(self, int: int) -> 'ZonedDateTime': ...
    @typing.overload
    def withLaterOffsetAtOverlap(self) -> 'ZonedDateTime': ...
    @typing.overload
    def withLaterOffsetAtOverlap(self) -> java.time.chrono.ChronoZonedDateTime: ...
    def withMinute(self, int: int) -> 'ZonedDateTime': ...
    def withMonth(self, int: int) -> 'ZonedDateTime': ...
    def withNano(self, int: int) -> 'ZonedDateTime': ...
    def withSecond(self, int: int) -> 'ZonedDateTime': ...
    def withYear(self, int: int) -> 'ZonedDateTime': ...
    @typing.overload
    def withZoneSameInstant(self, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @typing.overload
    def withZoneSameInstant(self, zoneId: ZoneId) -> java.time.chrono.ChronoZonedDateTime: ...
    @typing.overload
    def withZoneSameLocal(self, zoneId: ZoneId) -> 'ZonedDateTime': ...
    @typing.overload
    def withZoneSameLocal(self, zoneId: ZoneId) -> java.time.chrono.ChronoZonedDateTime: ...

class ZoneOffset(ZoneId, java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.ZoneOffset]):
    """
    Java class 'java.time.ZoneOffset'
    
        Extends:
            java.time.ZoneId
    
        Interfaces:
            java.time.temporal.TemporalAccessor,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable,
            java.io.Serializable
    
      Attributes:
        UTC (java.time.ZoneOffset): final static field
        MIN (java.time.ZoneOffset): final static field
        MAX (java.time.ZoneOffset): final static field
    
    """
    UTC: typing.ClassVar['ZoneOffset'] = ...
    MIN: typing.ClassVar['ZoneOffset'] = ...
    MAX: typing.ClassVar['ZoneOffset'] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, zoneOffset: 'ZoneOffset') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getId(self) -> java.lang.String: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getRules(self) -> java.time.zone.ZoneRules: ...
    def getTotalSeconds(self) -> int: ...
    def hashCode(self) -> int: ...
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @classmethod
    @typing.overload
    def of(cls, string: java.lang.String) -> ZoneId: ...
    @classmethod
    @typing.overload
    def of(cls, string: java.lang.String, map: typing.Union[java.util.Map[java.lang.String, java.lang.String], typing.Mapping[java.lang.String, java.lang.String]]) -> ZoneId: ...
    @classmethod
    @typing.overload
    def of(cls, string: java.lang.String) -> 'ZoneOffset': ...
    @classmethod
    def ofHours(cls, int: int) -> 'ZoneOffset': ...
    @classmethod
    def ofHoursMinutes(cls, int: int, int2: int) -> 'ZoneOffset': ...
    @classmethod
    def ofHoursMinutesSeconds(cls, int: int, int2: int, int3: int) -> 'ZoneOffset': ...
    @classmethod
    def ofTotalSeconds(cls, int: int) -> 'ZoneOffset': ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toString(self) -> java.lang.String: ...

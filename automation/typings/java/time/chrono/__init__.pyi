import java
import java.io
import java.lang
import java.time
import java.time.format
import java.time.temporal
import java.util
import typing


class ChronoLocalDate(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.chrono.ChronoLocalDate]):
    """
    Java class 'java.time.chrono.ChronoLocalDate'
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable
    
    """
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atTime(self, localTime: java.time.LocalTime) -> 'ChronoLocalDateTime'[typing.Any]: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronoLocalDate: 'ChronoLocalDate') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def getChronology(self) -> 'Chronology': ...
    def getEra(self) -> 'Era': ...
    def hashCode(self) -> int: ...
    def isAfter(self, chronoLocalDate: 'ChronoLocalDate') -> bool: ...
    def isBefore(self, chronoLocalDate: 'ChronoLocalDate') -> bool: ...
    def isEqual(self, chronoLocalDate: 'ChronoLocalDate') -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoLocalDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoLocalDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoLocalDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoLocalDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    @classmethod
    def timeLineOrder(cls) -> java.util.Comparator['ChronoLocalDate']: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: 'ChronoLocalDate') -> 'ChronoPeriod': ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

_ChronoLocalDateTime__D = typing.TypeVar('_ChronoLocalDateTime__D', bound=ChronoLocalDate)  # <D>
class ChronoLocalDateTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[java.time.chrono.ChronoLocalDateTime[typing.Any]], typing.Generic[_ChronoLocalDateTime__D]):
    """
    Java class 'java.time.chrono.ChronoLocalDateTime'
    
        Interfaces:
            java.time.temporal.Temporal,
            java.time.temporal.TemporalAdjuster, java.lang.Comparable
    
    """
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def atZone(self, zoneId: java.time.ZoneId) -> 'ChronoZonedDateTime'[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronoLocalDateTime: 'ChronoLocalDateTime'[typing.Any]) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def getChronology(self) -> 'Chronology': ...
    def hashCode(self) -> int: ...
    def isAfter(self, chronoLocalDateTime: 'ChronoLocalDateTime'[typing.Any]) -> bool: ...
    def isBefore(self, chronoLocalDateTime: 'ChronoLocalDateTime'[typing.Any]) -> bool: ...
    def isEqual(self, chronoLocalDateTime: 'ChronoLocalDateTime'[typing.Any]) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoLocalDateTime'[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoLocalDateTime'[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoLocalDateTime'[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoLocalDateTime'[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    @classmethod
    def timeLineOrder(cls) -> java.util.Comparator['ChronoLocalDateTime'[typing.Any]]: ...
    def toEpochSecond(self, zoneOffset: java.time.ZoneOffset) -> int: ...
    def toInstant(self, zoneOffset: java.time.ZoneOffset) -> java.time.Instant: ...
    def toLocalDate(self) -> _ChronoLocalDateTime__D: ...
    def toLocalTime(self) -> java.time.LocalTime: ...
    def toString(self) -> java.lang.String: ...

class ChronoPeriod(java.time.temporal.TemporalAmount):
    """
    public interface ChronoPeriod extends :class:`~java.time.temporal.TemporalAmount`
    
        A date-based amount of time, such as '3 years, 4 months and 5 days' in an arbitrary chronology, intended for advanced
        globalization use cases.
    
        This interface models a date-based amount of time in a calendar system. While most calendar systems use years, months
        and days, some do not. Therefore, this interface operates solely in terms of a set of supported units that are defined
        by the :code:`Chronology`. The set of supported units is fixed for a given chronology. The amount of a supported unit
        may be set to zero.
    
        The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.
    
        Implementation Requirements:
            This interface must be implemented with care to ensure other classes operate correctly. All implementations that can be
            instantiated must be final, immutable and thread-safe. Subclasses should be Serializable wherever possible.
    
        Since:
            1.8
    
    
    """
    def addTo(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    @classmethod
    def between(cls, chronoLocalDate: ChronoLocalDate, chronoLocalDate2: ChronoLocalDate) -> 'ChronoPeriod': ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def getChronology(self) -> 'Chronology': ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoPeriod': ...
    def multipliedBy(self, int: int) -> 'ChronoPeriod': ...
    def negated(self) -> 'ChronoPeriod': ...
    def normalized(self) -> 'ChronoPeriod': ...
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoPeriod': ...
    def subtractFrom(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def toString(self) -> java.lang.String: ...

_ChronoZonedDateTime__D = typing.TypeVar('_ChronoZonedDateTime__D', bound=ChronoLocalDate)  # <D>
class ChronoZonedDateTime(java.time.temporal.Temporal, java.lang.Comparable[java.time.chrono.ChronoZonedDateTime[typing.Any]], typing.Generic[_ChronoZonedDateTime__D]):
    """
    Java class 'java.time.chrono.ChronoZonedDateTime'
    
        Interfaces:
            java.time.temporal.Temporal, java.lang.Comparable
    
    """
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronoZonedDateTime: 'ChronoZonedDateTime'[typing.Any]) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def format(self, dateTimeFormatter: java.time.format.DateTimeFormatter) -> java.lang.String: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getChronology(self) -> 'Chronology': ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getOffset(self) -> java.time.ZoneOffset: ...
    def getZone(self) -> java.time.ZoneId: ...
    def hashCode(self) -> int: ...
    def isAfter(self, chronoZonedDateTime: 'ChronoZonedDateTime'[typing.Any]) -> bool: ...
    def isBefore(self, chronoZonedDateTime: 'ChronoZonedDateTime'[typing.Any]) -> bool: ...
    def isEqual(self, chronoZonedDateTime: 'ChronoZonedDateTime'[typing.Any]) -> bool: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    @classmethod
    def timeLineOrder(cls) -> java.util.Comparator['ChronoZonedDateTime'[typing.Any]]: ...
    def toEpochSecond(self) -> int: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocalDate(self) -> _ChronoZonedDateTime__D: ...
    def toLocalDateTime(self) -> ChronoLocalDateTime[_ChronoZonedDateTime__D]: ...
    def toLocalTime(self) -> java.time.LocalTime: ...
    def toString(self) -> java.lang.String: ...
    def withEarlierOffsetAtOverlap(self) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    def withLaterOffsetAtOverlap(self) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    def withZoneSameInstant(self, zoneId: java.time.ZoneId) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...
    def withZoneSameLocal(self, zoneId: java.time.ZoneId) -> 'ChronoZonedDateTime'[_ChronoZonedDateTime__D]: ...

class Chronology(java.lang.Comparable[java.time.chrono.Chronology]):
    """
    Java class 'java.time.chrono.Chronology'
    
        Interfaces:
            java.lang.Comparable
    
    """
    @typing.overload
    def compareTo(self, chronology: 'Chronology') -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: 'Era', int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: 'Era', int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def epochSecond(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, zoneOffset: java.time.ZoneOffset) -> int: ...
    @typing.overload
    def epochSecond(self, era: 'Era', int: int, int2: int, int3: int, int4: int, int5: int, int6: int, zoneOffset: java.time.ZoneOffset) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def eraOf(self, int: int) -> 'Era': ...
    def eras(self) -> java.util.List['Era']: ...
    @classmethod
    def getAvailableChronologies(cls) -> java.util.Set['Chronology']: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, long: int) -> bool: ...
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime[ChronoLocalDate]: ...
    @classmethod
    def of(cls, string: java.lang.String) -> 'Chronology': ...
    @classmethod
    def ofLocale(cls, locale: java.util.Locale) -> 'Chronology': ...
    def period(self, int: int, int2: int, int3: int) -> ChronoPeriod: ...
    def prolepticYear(self, era: 'Era', int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime[ChronoLocalDate]: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime[ChronoLocalDate]: ...

class Era(java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    """
    public interface Era extends :class:`~java.time.temporal.TemporalAccessor`, :class:`~java.time.temporal.TemporalAdjuster`
    
        An era of the time-line.
    
        Most calendar systems have a single epoch dividing the time-line into two eras. However, some calendar systems, have
        multiple eras, such as one for the reign of each leader. In all cases, the era is conceptually the largest division of
        the time-line. Each chronology defines the Era's that are known Eras and a :meth:`~java.time.chrono.Chronology.eras` to
        get the valid eras.
    
        For example, the Thai Buddhist calendar system divides time into two eras, before and after a single date. By contrast,
        the Japanese calendar system has one era for the reign of each Emperor.
    
        Instances of :code:`Era` may be compared using the :code:`==` operator.
    
        Implementation Requirements:
            This interface must be implemented with care to ensure other classes operate correctly. All implementations must be
            singletons - final, immutable and thread-safe. It is recommended to use an enum whenever possible.
    
        Since:
            1.8
    
    
    """
    def adjustInto(self, temporal: java.time.temporal.Temporal) -> java.time.temporal.Temporal: ...
    def get(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, temporalQuery: typing.Union[java.time.temporal.TemporalQuery[_query__R], typing.Callable[[], _query__R]]) -> _query__R: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...

class AbstractChronology(Chronology):
    """
    Java class 'java.time.chrono.AbstractChronology'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.chrono.Chronology
    
    """
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, chronology: Chronology) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    def toString(self) -> java.lang.String: ...

class HijrahEra(java.lang.Enum[java.time.chrono.HijrahEra], Era):
    """
    Java class 'java.time.chrono.HijrahEra'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.chrono.Era
    
      Attributes:
        AH (java.time.chrono.HijrahEra): final static enum constant
    
    """
    AH: typing.ClassVar['HijrahEra'] = ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getValue(self) -> int: ...
    @classmethod
    def of(cls, int: int) -> 'HijrahEra': ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'HijrahEra': ...
    @classmethod
    def values(cls) -> typing.List['HijrahEra']: ...

class IsoEra(java.lang.Enum[java.time.chrono.IsoEra], Era):
    """
    Java class 'java.time.chrono.IsoEra'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.chrono.Era
    
      Attributes:
        BCE (java.time.chrono.IsoEra): final static enum constant
        CE (java.time.chrono.IsoEra): final static enum constant
    
    """
    BCE: typing.ClassVar['IsoEra'] = ...
    CE: typing.ClassVar['IsoEra'] = ...
    def getValue(self) -> int: ...
    @classmethod
    def of(cls, int: int) -> 'IsoEra': ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'IsoEra': ...
    @classmethod
    def values(cls) -> typing.List['IsoEra']: ...

class JapaneseEra(Era, java.io.Serializable):
    """
    Java class 'java.time.chrono.JapaneseEra'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.time.chrono.Era, java.io.Serializable
    
      Attributes:
        MEIJI (java.time.chrono.JapaneseEra): final static field
        TAISHO (java.time.chrono.JapaneseEra): final static field
        SHOWA (java.time.chrono.JapaneseEra): final static field
        HEISEI (java.time.chrono.JapaneseEra): final static field
    
    """
    MEIJI: typing.ClassVar['JapaneseEra'] = ...
    TAISHO: typing.ClassVar['JapaneseEra'] = ...
    SHOWA: typing.ClassVar['JapaneseEra'] = ...
    HEISEI: typing.ClassVar['JapaneseEra'] = ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getValue(self) -> int: ...
    @classmethod
    def of(cls, int: int) -> 'JapaneseEra': ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toString(self) -> java.lang.String: ...
    @classmethod
    def valueOf(cls, string: java.lang.String) -> 'JapaneseEra': ...
    @classmethod
    def values(cls) -> typing.List['JapaneseEra']: ...

class MinguoEra(java.lang.Enum[java.time.chrono.MinguoEra], Era):
    """
    Java class 'java.time.chrono.MinguoEra'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.chrono.Era
    
      Attributes:
        BEFORE_ROC (java.time.chrono.MinguoEra): final static enum constant
        ROC (java.time.chrono.MinguoEra): final static enum constant
    
    """
    BEFORE_ROC: typing.ClassVar['MinguoEra'] = ...
    ROC: typing.ClassVar['MinguoEra'] = ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getValue(self) -> int: ...
    @classmethod
    def of(cls, int: int) -> 'MinguoEra': ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'MinguoEra': ...
    @classmethod
    def values(cls) -> typing.List['MinguoEra']: ...

class ThaiBuddhistEra(java.lang.Enum[java.time.chrono.ThaiBuddhistEra], Era):
    """
    Java class 'java.time.chrono.ThaiBuddhistEra'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.time.chrono.Era
    
      Attributes:
        BEFORE_BE (java.time.chrono.ThaiBuddhistEra): final static enum constant
        BE (java.time.chrono.ThaiBuddhistEra): final static enum constant
    
    """
    BEFORE_BE: typing.ClassVar['ThaiBuddhistEra'] = ...
    BE: typing.ClassVar['ThaiBuddhistEra'] = ...
    def getDisplayName(self, textStyle: java.time.format.TextStyle, locale: java.util.Locale) -> java.lang.String: ...
    def getValue(self) -> int: ...
    @classmethod
    def of(cls, int: int) -> 'ThaiBuddhistEra': ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'ThaiBuddhistEra': ...
    @classmethod
    def values(cls) -> typing.List['ThaiBuddhistEra']: ...

class HijrahChronology(AbstractChronology, java.io.Serializable):
    """
    Java class 'java.time.chrono.HijrahChronology'
    
        Extends:
            java.time.chrono.AbstractChronology
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        INSTANCE (java.time.chrono.HijrahChronology): final static field
    
    """
    INSTANCE: typing.ClassVar['HijrahChronology'] = ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> 'HijrahDate': ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> 'HijrahDate': ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> 'HijrahDate': ...
    @typing.overload
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> 'HijrahDate': ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> 'HijrahDate': ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> 'HijrahDate': ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> 'HijrahDate': ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> 'HijrahDate': ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> 'HijrahDate': ...
    @typing.overload
    def eraOf(self, int: int) -> Era: ...
    @typing.overload
    def eraOf(self, int: int) -> HijrahEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def isLeapYear(self, long: int) -> bool: ...
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime['HijrahDate']: ...
    def prolepticYear(self, era: Era, int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def resolveDate(self, map: java.util.Map, resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    @typing.overload
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> 'HijrahDate': ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime['HijrahDate']: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime['HijrahDate']: ...

class IsoChronology(AbstractChronology, java.io.Serializable):
    """
    Java class 'java.time.chrono.IsoChronology'
    
        Extends:
            java.time.chrono.AbstractChronology
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        INSTANCE (java.time.chrono.IsoChronology): final static field
    
    """
    INSTANCE: typing.ClassVar['IsoChronology'] = ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> java.time.LocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> java.time.LocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> java.time.LocalDate: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> java.time.LocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> java.time.LocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> java.time.LocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def epochSecond(self, era: Era, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, zoneOffset: java.time.ZoneOffset) -> int: ...
    @typing.overload
    def epochSecond(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int, zoneOffset: java.time.ZoneOffset) -> int: ...
    @typing.overload
    def eraOf(self, int: int) -> Era: ...
    @typing.overload
    def eraOf(self, int: int) -> IsoEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def isLeapYear(self, long: int) -> bool: ...
    @typing.overload
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> java.time.LocalDateTime: ...
    @typing.overload
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime: ...
    @typing.overload
    def period(self, int: int, int2: int, int3: int) -> java.time.Period: ...
    @typing.overload
    def period(self, int: int, int2: int, int3: int) -> ChronoPeriod: ...
    def prolepticYear(self, era: Era, int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> java.time.LocalDate: ...
    @typing.overload
    def resolveDate(self, map: java.util.Map, resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> java.time.ZonedDateTime: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> java.time.ZonedDateTime: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime: ...

class JapaneseChronology(AbstractChronology, java.io.Serializable):
    """
    Java class 'java.time.chrono.JapaneseChronology'
    
        Extends:
            java.time.chrono.AbstractChronology
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        INSTANCE (java.time.chrono.JapaneseChronology): final static field
    
    """
    INSTANCE: typing.ClassVar['JapaneseChronology'] = ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> 'JapaneseDate': ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> 'JapaneseDate': ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> 'JapaneseDate': ...
    @typing.overload
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> 'JapaneseDate': ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> 'JapaneseDate': ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> 'JapaneseDate': ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> 'JapaneseDate': ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> 'JapaneseDate': ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> 'JapaneseDate': ...
    @typing.overload
    def eraOf(self, int: int) -> Era: ...
    @typing.overload
    def eraOf(self, int: int) -> JapaneseEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def isLeapYear(self, long: int) -> bool: ...
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime['JapaneseDate']: ...
    def prolepticYear(self, era: Era, int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def resolveDate(self, map: java.util.Map, resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    @typing.overload
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> 'JapaneseDate': ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime['JapaneseDate']: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime['JapaneseDate']: ...

class MinguoChronology(AbstractChronology, java.io.Serializable):
    """
    Java class 'java.time.chrono.MinguoChronology'
    
        Extends:
            java.time.chrono.AbstractChronology
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        INSTANCE (java.time.chrono.MinguoChronology): final static field
    
    """
    INSTANCE: typing.ClassVar['MinguoChronology'] = ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> 'MinguoDate': ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> 'MinguoDate': ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> 'MinguoDate': ...
    @typing.overload
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> 'MinguoDate': ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> 'MinguoDate': ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> 'MinguoDate': ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> 'MinguoDate': ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> 'MinguoDate': ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> 'MinguoDate': ...
    @typing.overload
    def eraOf(self, int: int) -> Era: ...
    @typing.overload
    def eraOf(self, int: int) -> MinguoEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def isLeapYear(self, long: int) -> bool: ...
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime['MinguoDate']: ...
    def prolepticYear(self, era: Era, int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def resolveDate(self, map: java.util.Map, resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    @typing.overload
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> 'MinguoDate': ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime['MinguoDate']: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime['MinguoDate']: ...

class ThaiBuddhistChronology(AbstractChronology, java.io.Serializable):
    """
    Java class 'java.time.chrono.ThaiBuddhistChronology'
    
        Extends:
            java.time.chrono.AbstractChronology
    
        Interfaces:
            java.io.Serializable
    
      Attributes:
        INSTANCE (java.time.chrono.ThaiBuddhistChronology): final static field
    
    """
    INSTANCE: typing.ClassVar['ThaiBuddhistChronology'] = ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, int: int, int2: int, int3: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def date(self, era: Era, int: int, int2: int, int3: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def date(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateEpochDay(self, long: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateEpochDay(self, long: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateNow(self, zoneId: java.time.ZoneId) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, int: int, int2: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def dateYearDay(self, era: Era, int: int, int2: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def eraOf(self, int: int) -> Era: ...
    @typing.overload
    def eraOf(self, int: int) -> ThaiBuddhistEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def isLeapYear(self, long: int) -> bool: ...
    def localDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoLocalDateTime['ThaiBuddhistDate']: ...
    def prolepticYear(self, era: Era, int: int) -> int: ...
    def range(self, chronoField: java.time.temporal.ChronoField) -> java.time.temporal.ValueRange: ...
    @typing.overload
    def resolveDate(self, map: java.util.Map, resolverStyle: java.time.format.ResolverStyle) -> ChronoLocalDate: ...
    @typing.overload
    def resolveDate(self, map: typing.Union[java.util.Map[java.time.temporal.TemporalField, int], typing.Mapping[java.time.temporal.TemporalField, int]], resolverStyle: java.time.format.ResolverStyle) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zoneId: java.time.ZoneId) -> ChronoZonedDateTime['ThaiBuddhistDate']: ...
    @typing.overload
    def zonedDateTime(self, temporalAccessor: java.time.temporal.TemporalAccessor) -> ChronoZonedDateTime['ThaiBuddhistDate']: ...

class HijrahDate(java.time.chrono.ChronoLocalDateImpl[java.time.chrono.HijrahDate]):
    """
    Java class 'java.time.chrono.HijrahDate'
    
        Extends:
            java.time.chrono.ChronoLocalDateImpl
    
        Interfaces:
            java.time.chrono.ChronoLocalDate, java.io.Serializable
    
    """
    def atTime(self, localTime: java.time.LocalTime) -> ChronoLocalDateTime['HijrahDate']: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getChronology(self) -> Chronology: ...
    @typing.overload
    def getChronology(self) -> HijrahChronology: ...
    @typing.overload
    def getEra(self) -> Era: ...
    @typing.overload
    def getEra(self) -> HijrahEra: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'HijrahDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'HijrahDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @classmethod
    @typing.overload
    def now(cls) -> 'HijrahDate': ...
    @classmethod
    @typing.overload
    def now(cls, clock: java.time.Clock) -> 'HijrahDate': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: java.time.ZoneId) -> 'HijrahDate': ...
    @classmethod
    def of(cls, int: int, int2: int, int3: int) -> 'HijrahDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'HijrahDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'HijrahDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: ChronoLocalDate) -> ChronoPeriod: ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...
    def withVariant(self, hijrahChronology: HijrahChronology) -> 'HijrahDate': ...

class JapaneseDate(java.time.chrono.ChronoLocalDateImpl[java.time.chrono.JapaneseDate]):
    """
    Java class 'java.time.chrono.JapaneseDate'
    
        Extends:
            java.time.chrono.ChronoLocalDateImpl
    
        Interfaces:
            java.time.chrono.ChronoLocalDate, java.io.Serializable
    
    """
    def atTime(self, localTime: java.time.LocalTime) -> ChronoLocalDateTime['JapaneseDate']: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getChronology(self) -> Chronology: ...
    @typing.overload
    def getChronology(self) -> JapaneseChronology: ...
    @typing.overload
    def getEra(self) -> Era: ...
    @typing.overload
    def getEra(self) -> JapaneseEra: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def isSupported(self, temporalField: java.time.temporal.TemporalField) -> bool: ...
    @typing.overload
    def isSupported(self, temporalUnit: java.time.temporal.TemporalUnit) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'JapaneseDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'JapaneseDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @classmethod
    @typing.overload
    def now(cls) -> 'JapaneseDate': ...
    @classmethod
    @typing.overload
    def now(cls, clock: java.time.Clock) -> 'JapaneseDate': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: java.time.ZoneId) -> 'JapaneseDate': ...
    @classmethod
    @typing.overload
    def of(cls, int: int, int2: int, int3: int) -> 'JapaneseDate': ...
    @classmethod
    @typing.overload
    def of(cls, japaneseEra: JapaneseEra, int: int, int2: int, int3: int) -> 'JapaneseDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'JapaneseDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'JapaneseDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: ChronoLocalDate) -> ChronoPeriod: ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

class MinguoDate(java.time.chrono.ChronoLocalDateImpl[java.time.chrono.MinguoDate]):
    """
    Java class 'java.time.chrono.MinguoDate'
    
        Extends:
            java.time.chrono.ChronoLocalDateImpl
    
        Interfaces:
            java.time.chrono.ChronoLocalDate, java.io.Serializable
    
    """
    def atTime(self, localTime: java.time.LocalTime) -> ChronoLocalDateTime['MinguoDate']: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getChronology(self) -> Chronology: ...
    @typing.overload
    def getChronology(self) -> MinguoChronology: ...
    @typing.overload
    def getEra(self) -> Era: ...
    @typing.overload
    def getEra(self) -> MinguoEra: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def hashCode(self) -> int: ...
    def lengthOfMonth(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'MinguoDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'MinguoDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @classmethod
    @typing.overload
    def now(cls) -> 'MinguoDate': ...
    @classmethod
    @typing.overload
    def now(cls, clock: java.time.Clock) -> 'MinguoDate': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: java.time.ZoneId) -> 'MinguoDate': ...
    @classmethod
    def of(cls, int: int, int2: int, int3: int) -> 'MinguoDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'MinguoDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'MinguoDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: ChronoLocalDate) -> ChronoPeriod: ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

class ThaiBuddhistDate(java.time.chrono.ChronoLocalDateImpl[java.time.chrono.ThaiBuddhistDate]):
    """
    Java class 'java.time.chrono.ThaiBuddhistDate'
    
        Extends:
            java.time.chrono.ChronoLocalDateImpl
    
        Interfaces:
            java.time.chrono.ChronoLocalDate, java.io.Serializable
    
    """
    def atTime(self, localTime: java.time.LocalTime) -> ChronoLocalDateTime['ThaiBuddhistDate']: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getChronology(self) -> Chronology: ...
    @typing.overload
    def getChronology(self) -> ThaiBuddhistChronology: ...
    @typing.overload
    def getEra(self) -> Era: ...
    @typing.overload
    def getEra(self) -> ThaiBuddhistEra: ...
    def getLong(self, temporalField: java.time.temporal.TemporalField) -> int: ...
    def hashCode(self) -> int: ...
    def lengthOfMonth(self) -> int: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def minus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def minus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    @classmethod
    @typing.overload
    def now(cls) -> 'ThaiBuddhistDate': ...
    @classmethod
    @typing.overload
    def now(cls, clock: java.time.Clock) -> 'ThaiBuddhistDate': ...
    @classmethod
    @typing.overload
    def now(cls, zoneId: java.time.ZoneId) -> 'ThaiBuddhistDate': ...
    @classmethod
    def of(cls, int: int, int2: int, int3: int) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'ThaiBuddhistDate': ...
    @typing.overload
    def plus(self, temporalAmount: java.time.temporal.TemporalAmount) -> java.time.temporal.Temporal: ...
    @typing.overload
    def plus(self, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> java.time.temporal.Temporal: ...
    def range(self, temporalField: java.time.temporal.TemporalField) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, chronoLocalDate: ChronoLocalDate) -> ChronoPeriod: ...
    @typing.overload
    def until(self, temporal: java.time.temporal.Temporal, temporalUnit: java.time.temporal.TemporalUnit) -> int: ...

class ChronoLocalDateImpl: ...

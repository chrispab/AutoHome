import java
import java.io
import java.lang
import java.nio.channels
import java.nio.charset
import java.security
import java.security.cert
import java.util
import java.util.jar
import java.util.stream
import typing


class Authenticator(java.lang.Object):
    """
    Java class 'java.net.Authenticator'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Authenticator()
    
    """
    def __init__(self): ...
    @classmethod
    def getDefault(cls) -> 'Authenticator': ...
    @classmethod
    @typing.overload
    def requestPasswordAuthentication(cls, string: java.lang.String, inetAddress: 'InetAddress', int: int, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String) -> 'PasswordAuthentication': ...
    @classmethod
    @typing.overload
    def requestPasswordAuthentication(cls, string: java.lang.String, inetAddress: 'InetAddress', int: int, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String, uRL: 'URL', requestorType: 'Authenticator.RequestorType') -> 'PasswordAuthentication': ...
    @classmethod
    @typing.overload
    def requestPasswordAuthentication(cls, authenticator: 'Authenticator', string: java.lang.String, inetAddress: 'InetAddress', int: int, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String, uRL: 'URL', requestorType: 'Authenticator.RequestorType') -> 'PasswordAuthentication': ...
    @classmethod
    @typing.overload
    def requestPasswordAuthentication(cls, inetAddress: 'InetAddress', int: int, string: java.lang.String, string2: java.lang.String, string3: java.lang.String) -> 'PasswordAuthentication': ...
    def requestPasswordAuthenticationInstance(self, string: java.lang.String, inetAddress: 'InetAddress', int: int, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String, uRL: 'URL', requestorType: 'Authenticator.RequestorType') -> 'PasswordAuthentication': ...
    @classmethod
    def setDefault(cls, authenticator: 'Authenticator') -> None: ...
    class RequestorType(java.lang.Enum[java.net.Authenticator.RequestorType]):
        """
        Java class 'java.net.Authenticator$RequestorType'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            PROXY (java.net.Authenticator$RequestorType): final static enum constant
            SERVER (java.net.Authenticator$RequestorType): final static enum constant
        
        """
        PROXY: typing.ClassVar['Authenticator.RequestorType'] = ...
        SERVER: typing.ClassVar['Authenticator.RequestorType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Authenticator.RequestorType': ...
        @classmethod
        def values(cls) -> typing.List['Authenticator.RequestorType']: ...

class CacheRequest(java.lang.Object):
    """
    Java class 'java.net.CacheRequest'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * CacheRequest()
    
    """
    def __init__(self): ...
    def abort(self) -> None: ...
    def getBody(self) -> java.io.OutputStream: ...

class CacheResponse(java.lang.Object):
    """
    Java class 'java.net.CacheResponse'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * CacheResponse()
    
    """
    def __init__(self): ...
    def getBody(self) -> java.io.InputStream: ...
    def getHeaders(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...

class ContentHandler(java.lang.Object):
    """
    Java class 'java.net.ContentHandler'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ContentHandler()
    
    """
    def __init__(self): ...
    @typing.overload
    def getContent(self, uRLConnection: 'URLConnection') -> typing.Any: ...
    @typing.overload
    def getContent(self, uRLConnection: 'URLConnection', classArray: typing.List[typing.Type]) -> typing.Any: ...

class ContentHandlerFactory(java.lang.Object):
    """
    public interface ContentHandlerFactory
    
        This interface defines a factory for content handlers. An implementation of this interface should map a MIME type into
        an instance of :code:`ContentHandler`.
    
        This interface is used by the :code:`URLStreamHandler` class to create a :code:`ContentHandler` for a MIME type.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.net.ContentHandler`, :class:`~java.net.URLStreamHandler`
    
    
    """
    def createContentHandler(self, string: java.lang.String) -> ContentHandler: ...

class CookieHandler(java.lang.Object):
    """
    Java class 'java.net.CookieHandler'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * CookieHandler()
    
    """
    def __init__(self): ...
    def get(self, uRI: 'URI', map: typing.Union[java.util.Map[java.lang.String, java.util.List[java.lang.String]], typing.Mapping[java.lang.String, java.util.List[java.lang.String]]]) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    @classmethod
    def getDefault(cls) -> 'CookieHandler': ...
    def put(self, uRI: 'URI', map: typing.Union[java.util.Map[java.lang.String, java.util.List[java.lang.String]], typing.Mapping[java.lang.String, java.util.List[java.lang.String]]]) -> None: ...
    @classmethod
    def setDefault(cls, cookieHandler: 'CookieHandler') -> None: ...

class CookiePolicy(java.lang.Object):
    """
    public interface CookiePolicy
    
        CookiePolicy implementations decide which cookies should be accepted and which should be rejected. Three pre-defined
        policy implementations are provided, namely ACCEPT_ALL, ACCEPT_NONE and ACCEPT_ORIGINAL_SERVER.
    
        See RFC 2965 sec. 3.3 and 7 for more detail.
    
        Since:
            1.6
    
    
    """
    ACCEPT_ALL: typing.ClassVar['CookiePolicy'] = ...
    ACCEPT_NONE: typing.ClassVar['CookiePolicy'] = ...
    ACCEPT_ORIGINAL_SERVER: typing.ClassVar['CookiePolicy'] = ...
    def shouldAccept(self, uRI: 'URI', httpCookie: 'HttpCookie') -> bool: ...

class CookieStore(java.lang.Object):
    """
    public interface CookieStore
    
        A CookieStore object represents a storage for cookie. Can store and retrieve cookies.
    
        :class:`~java.net.CookieManager` will call :code:`CookieStore.add` to save cookies for every incoming HTTP response, and
        call :code:`CookieStore.get` to retrieve cookie for every outgoing HTTP request. A CookieStore is responsible for
        removing HttpCookie instances which have expired.
    
        Since:
            1.6
    
    
    """
    def add(self, uRI: 'URI', httpCookie: 'HttpCookie') -> None: ...
    def get(self, uRI: 'URI') -> java.util.List['HttpCookie']: ...
    def getCookies(self) -> java.util.List['HttpCookie']: ...
    def getURIs(self) -> java.util.List['URI']: ...
    def remove(self, uRI: 'URI', httpCookie: 'HttpCookie') -> bool: ...
    def removeAll(self) -> bool: ...

class DatagramPacket(java.lang.Object):
    """
    Java class 'java.net.DatagramPacket'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * DatagramPacket(byte[], int, java.net.SocketAddress)
        * DatagramPacket(byte[], int, java.net.InetAddress, int)
        * DatagramPacket(byte[], int, int, java.net.SocketAddress)
        * DatagramPacket(byte[], int, int)
        * DatagramPacket(byte[], int)
        * DatagramPacket(byte[], int, int, java.net.InetAddress, int)
    
    """
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int, inetAddress: 'InetAddress', int3: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, int2: int, socketAddress: 'SocketAddress'): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, inetAddress: 'InetAddress', int2: int): ...
    @typing.overload
    def __init__(self, byteArray: typing.List[int], int: int, socketAddress: 'SocketAddress'): ...
    def getAddress(self) -> 'InetAddress': ...
    def getData(self) -> typing.List[int]: ...
    def getLength(self) -> int: ...
    def getOffset(self) -> int: ...
    def getPort(self) -> int: ...
    def getSocketAddress(self) -> 'SocketAddress': ...
    def setAddress(self, inetAddress: 'InetAddress') -> None: ...
    @typing.overload
    def setData(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def setData(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def setLength(self, int: int) -> None: ...
    def setPort(self, int: int) -> None: ...
    def setSocketAddress(self, socketAddress: 'SocketAddress') -> None: ...

class DatagramSocket(java.io.Closeable):
    """
    Java class 'java.net.DatagramSocket'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * DatagramSocket(int, java.net.InetAddress)
        * DatagramSocket(java.net.SocketAddress)
        * DatagramSocket()
        * DatagramSocket(int)
    
      Raises:
        java.net.SocketException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, inetAddress: 'InetAddress'): ...
    @typing.overload
    def __init__(self, socketAddress: 'SocketAddress'): ...
    def bind(self, socketAddress: 'SocketAddress') -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, inetAddress: 'InetAddress', int: int) -> None: ...
    @typing.overload
    def connect(self, socketAddress: 'SocketAddress') -> None: ...
    def disconnect(self) -> None: ...
    def getBroadcast(self) -> bool: ...
    def getChannel(self) -> java.nio.channels.DatagramChannel: ...
    def getInetAddress(self) -> 'InetAddress': ...
    def getLocalAddress(self) -> 'InetAddress': ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> 'SocketAddress': ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, socketOption: 'SocketOption'[_getOption__T]) -> _getOption__T: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> 'SocketAddress': ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def receive(self, datagramPacket: DatagramPacket) -> None: ...
    def send(self, datagramPacket: DatagramPacket) -> None: ...
    def setBroadcast(self, boolean: bool) -> None: ...
    @classmethod
    def setDatagramSocketImplFactory(cls, datagramSocketImplFactory: 'DatagramSocketImplFactory') -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, socketOption: 'SocketOption'[_setOption__T], t: _setOption__T) -> 'DatagramSocket': ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSendBufferSize(self, int: int) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    def setTrafficClass(self, int: int) -> None: ...
    def supportedOptions(self) -> java.util.Set['SocketOption'[typing.Any]]: ...

class DatagramSocketImplFactory(java.lang.Object):
    """
    public interface DatagramSocketImplFactory
    
        This interface defines a factory for datagram socket implementations. It is used by the classes :code:`DatagramSocket`
        to create actual socket implementations.
    
        Since:
            1.3
    
        Also see:
            :class:`~java.net.DatagramSocket`
    
    
    """
    def createDatagramSocketImpl(self) -> 'DatagramSocketImpl': ...

class FileNameMap(java.lang.Object):
    """
    public interface FileNameMap
    
        A simple interface which provides a mechanism to map between a file name and a MIME type string.
    
        Since:
            1.1
    
    
    """
    def getContentTypeFor(self, string: java.lang.String) -> java.lang.String: ...

class HttpCookie(java.lang.Cloneable):
    """
    Java class 'java.net.HttpCookie'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Cloneable
    
      Constructors:
        * HttpCookie(java.lang.String, java.lang.String)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def clone(self) -> typing.Any: ...
    @classmethod
    def domainMatches(cls, string: java.lang.String, string2: java.lang.String) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getComment(self) -> java.lang.String: ...
    def getCommentURL(self) -> java.lang.String: ...
    def getDiscard(self) -> bool: ...
    def getDomain(self) -> java.lang.String: ...
    def getMaxAge(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPortlist(self) -> java.lang.String: ...
    def getSecure(self) -> bool: ...
    def getValue(self) -> java.lang.String: ...
    def getVersion(self) -> int: ...
    def hasExpired(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isHttpOnly(self) -> bool: ...
    @classmethod
    def parse(cls, string: java.lang.String) -> java.util.List['HttpCookie']: ...
    def setComment(self, string: java.lang.String) -> None: ...
    def setCommentURL(self, string: java.lang.String) -> None: ...
    def setDiscard(self, boolean: bool) -> None: ...
    def setDomain(self, string: java.lang.String) -> None: ...
    def setHttpOnly(self, boolean: bool) -> None: ...
    def setMaxAge(self, long: int) -> None: ...
    def setPath(self, string: java.lang.String) -> None: ...
    def setPortlist(self, string: java.lang.String) -> None: ...
    def setSecure(self, boolean: bool) -> None: ...
    def setValue(self, string: java.lang.String) -> None: ...
    def setVersion(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class HttpRetryException(java.io.IOException):
    """
    Java class 'java.net.HttpRetryException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * HttpRetryException(java.lang.String, int)
        * HttpRetryException(java.lang.String, int, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, int: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int, string2: java.lang.String): ...
    def getLocation(self) -> java.lang.String: ...
    def getReason(self) -> java.lang.String: ...
    def responseCode(self) -> int: ...

class IDN(java.lang.Object):
    """
    Java class 'java.net.IDN'
    
        Extends:
            java.lang.Object
    
      Attributes:
        ALLOW_UNASSIGNED (int): final static field
        USE_STD3_ASCII_RULES (int): final static field
    
    """
    ALLOW_UNASSIGNED: typing.ClassVar[int] = ...
    USE_STD3_ASCII_RULES: typing.ClassVar[int] = ...
    @classmethod
    @typing.overload
    def toASCII(cls, string: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toASCII(cls, string: java.lang.String, int: int) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toUnicode(cls, string: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def toUnicode(cls, string: java.lang.String, int: int) -> java.lang.String: ...

class InetAddress(java.io.Serializable):
    """
    Java class 'java.net.InetAddress'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.List[int]: ...
    @classmethod
    def getAllByName(cls, string: java.lang.String) -> typing.List['InetAddress']: ...
    @classmethod
    @typing.overload
    def getByAddress(cls, byteArray: typing.List[int]) -> 'InetAddress': ...
    @classmethod
    @typing.overload
    def getByAddress(cls, string: java.lang.String, byteArray: typing.List[int]) -> 'InetAddress': ...
    @classmethod
    def getByName(cls, string: java.lang.String) -> 'InetAddress': ...
    def getCanonicalHostName(self) -> java.lang.String: ...
    def getHostAddress(self) -> java.lang.String: ...
    def getHostName(self) -> java.lang.String: ...
    @classmethod
    def getLocalHost(cls) -> 'InetAddress': ...
    @classmethod
    def getLoopbackAddress(cls) -> 'InetAddress': ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    @typing.overload
    def isReachable(self, int: int) -> bool: ...
    @typing.overload
    def isReachable(self, networkInterface: 'NetworkInterface', int: int, int2: int) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class InterfaceAddress(java.lang.Object):
    """
    Java class 'java.net.InterfaceAddress'
    
        Extends:
            java.lang.Object
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getBroadcast(self) -> InetAddress: ...
    def getNetworkPrefixLength(self) -> int: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class MalformedURLException(java.io.IOException):
    """
    Java class 'java.net.MalformedURLException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * MalformedURLException()
        * MalformedURLException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class NetPermission(java.security.BasicPermission):
    """
    Java class 'java.net.NetPermission'
    
        Extends:
            java.security.BasicPermission
    
      Constructors:
        * NetPermission(java.lang.String)
        * NetPermission(java.lang.String, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...

class NetworkInterface(java.lang.Object):
    """
    Java class 'java.net.NetworkInterface'
    
        Extends:
            java.lang.Object
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    @classmethod
    def getByIndex(cls, int: int) -> 'NetworkInterface': ...
    @classmethod
    def getByInetAddress(cls, inetAddress: InetAddress) -> 'NetworkInterface': ...
    @classmethod
    def getByName(cls, string: java.lang.String) -> 'NetworkInterface': ...
    def getDisplayName(self) -> java.lang.String: ...
    def getHardwareAddress(self) -> typing.List[int]: ...
    def getIndex(self) -> int: ...
    def getInetAddresses(self) -> java.util.Enumeration[InetAddress]: ...
    def getInterfaceAddresses(self) -> java.util.List[InterfaceAddress]: ...
    def getMTU(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    @classmethod
    def getNetworkInterfaces(cls) -> java.util.Enumeration['NetworkInterface']: ...
    def getParent(self) -> 'NetworkInterface': ...
    def getSubInterfaces(self) -> java.util.Enumeration['NetworkInterface']: ...
    def hashCode(self) -> int: ...
    def inetAddresses(self) -> java.util.stream.Stream[InetAddress]: ...
    def isLoopback(self) -> bool: ...
    def isPointToPoint(self) -> bool: ...
    def isUp(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    @classmethod
    def networkInterfaces(cls) -> java.util.stream.Stream['NetworkInterface']: ...
    def subInterfaces(self) -> java.util.stream.Stream['NetworkInterface']: ...
    def supportsMulticast(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class PasswordAuthentication(java.lang.Object):
    """
    Java class 'java.net.PasswordAuthentication'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * PasswordAuthentication(java.lang.String, char[])
    
    """
    def __init__(self, string: java.lang.String, charArray: typing.List[str]): ...
    def getPassword(self) -> typing.List[str]: ...
    def getUserName(self) -> java.lang.String: ...

class ProtocolException(java.io.IOException):
    """
    Java class 'java.net.ProtocolException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * ProtocolException(java.lang.String)
        * ProtocolException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ProtocolFamily(java.lang.Object):
    """
    public interface ProtocolFamily
    
        Represents a family of communication protocols.
    
        Since:
            1.7
    
    
    """
    def name(self) -> java.lang.String: ...

class Proxy(java.lang.Object):
    """
    Java class 'java.net.Proxy'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * Proxy(java.net.Proxy.Type, java.net.SocketAddress)
    
      Attributes:
        NO_PROXY (java.net.Proxy): final static field
    
    """
    NO_PROXY: typing.ClassVar['Proxy'] = ...
    def __init__(self, type: 'Proxy.Type', socketAddress: 'SocketAddress'): ...
    def address(self) -> 'SocketAddress': ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def type(self) -> 'Proxy.Type': ...
    class Type(java.lang.Enum[java.net.Proxy.Type]):
        """
        Java class 'java.net.Proxy$Type'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            DIRECT (java.net.Proxy$Type): final static enum constant
            HTTP (java.net.Proxy$Type): final static enum constant
            SOCKS (java.net.Proxy$Type): final static enum constant
        
        """
        DIRECT: typing.ClassVar['Proxy.Type'] = ...
        HTTP: typing.ClassVar['Proxy.Type'] = ...
        SOCKS: typing.ClassVar['Proxy.Type'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @typing.overload
        def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
        @classmethod
        @typing.overload
        def valueOf(cls, string: java.lang.String) -> 'Proxy.Type': ...
        @classmethod
        def values(cls) -> typing.List['Proxy.Type']: ...

class ProxySelector(java.lang.Object):
    """
    Java class 'java.net.ProxySelector'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ProxySelector()
    
    """
    def __init__(self): ...
    def connectFailed(self, uRI: 'URI', socketAddress: 'SocketAddress', iOException: java.io.IOException) -> None: ...
    @classmethod
    def getDefault(cls) -> 'ProxySelector': ...
    @classmethod
    def of(cls, inetSocketAddress: 'InetSocketAddress') -> 'ProxySelector': ...
    def select(self, uRI: 'URI') -> java.util.List[Proxy]: ...
    @classmethod
    def setDefault(cls, proxySelector: 'ProxySelector') -> None: ...

class ResponseCache(java.lang.Object):
    """
    Java class 'java.net.ResponseCache'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ResponseCache()
    
    """
    def __init__(self): ...
    def get(self, uRI: 'URI', string: java.lang.String, map: typing.Union[java.util.Map[java.lang.String, java.util.List[java.lang.String]], typing.Mapping[java.lang.String, java.util.List[java.lang.String]]]) -> CacheResponse: ...
    @classmethod
    def getDefault(cls) -> 'ResponseCache': ...
    def put(self, uRI: 'URI', uRLConnection: 'URLConnection') -> CacheRequest: ...
    @classmethod
    def setDefault(cls, responseCache: 'ResponseCache') -> None: ...

class ServerSocket(java.io.Closeable):
    """
    Java class 'java.net.ServerSocket'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * ServerSocket(int, int, java.net.InetAddress)
        * ServerSocket(int, int)
        * ServerSocket(int)
        * ServerSocket()
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, inetAddress: InetAddress): ...
    def accept(self) -> 'Socket': ...
    @typing.overload
    def bind(self, socketAddress: 'SocketAddress') -> None: ...
    @typing.overload
    def bind(self, socketAddress: 'SocketAddress', int: int) -> None: ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.ServerSocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> 'SocketAddress': ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, socketOption: 'SocketOption'[_getOption__T]) -> _getOption__T: ...
    def getReceiveBufferSize(self) -> int: ...
    def getReuseAddress(self) -> bool: ...
    def getSoTimeout(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, socketOption: 'SocketOption'[_setOption__T], t: _setOption__T) -> 'ServerSocket': ...
    def setPerformancePreferences(self, int: int, int2: int, int3: int) -> None: ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    @classmethod
    def setSocketFactory(cls, socketImplFactory: 'SocketImplFactory') -> None: ...
    def supportedOptions(self) -> java.util.Set['SocketOption'[typing.Any]]: ...
    def toString(self) -> java.lang.String: ...

class Socket(java.io.Closeable):
    """
    Java class 'java.net.Socket'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * Socket(java.net.InetAddress, int)
        * Socket(java.lang.String, int, java.net.InetAddress, int)
        * Socket(java.net.InetAddress, int, java.net.InetAddress, int)
        * Socket(java.lang.String, int, boolean)
        * Socket(java.net.InetAddress, int, boolean)
        * Socket()
        * Socket(java.net.Proxy)
        * Socket(java.lang.String, int)
    
      Raises:
        java.io.IOException: from java
        java.net.UnknownHostException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int, boolean: bool): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int, inetAddress: InetAddress, int2: int): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int, boolean: bool): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int, inetAddress2: InetAddress, int2: int): ...
    @typing.overload
    def __init__(self, proxy: Proxy): ...
    def bind(self, socketAddress: 'SocketAddress') -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, socketAddress: 'SocketAddress') -> None: ...
    @typing.overload
    def connect(self, socketAddress: 'SocketAddress', int: int) -> None: ...
    def getChannel(self) -> java.nio.channels.SocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getKeepAlive(self) -> bool: ...
    def getLocalAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> 'SocketAddress': ...
    def getOOBInline(self) -> bool: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, socketOption: 'SocketOption'[_getOption__T]) -> _getOption__T: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> 'SocketAddress': ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoLinger(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTcpNoDelay(self) -> bool: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def isInputShutdown(self) -> bool: ...
    def isOutputShutdown(self) -> bool: ...
    def sendUrgentData(self, int: int) -> None: ...
    def setKeepAlive(self, boolean: bool) -> None: ...
    def setOOBInline(self, boolean: bool) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, socketOption: 'SocketOption'[_setOption__T], t: _setOption__T) -> 'Socket': ...
    def setPerformancePreferences(self, int: int, int2: int, int3: int) -> None: ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSendBufferSize(self, int: int) -> None: ...
    def setSoLinger(self, boolean: bool, int: int) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    @classmethod
    def setSocketImplFactory(cls, socketImplFactory: 'SocketImplFactory') -> None: ...
    def setTcpNoDelay(self, boolean: bool) -> None: ...
    def setTrafficClass(self, int: int) -> None: ...
    def shutdownInput(self) -> None: ...
    def shutdownOutput(self) -> None: ...
    def supportedOptions(self) -> java.util.Set['SocketOption'[typing.Any]]: ...
    def toString(self) -> java.lang.String: ...

class SocketAddress(java.io.Serializable):
    """
    Java class 'java.net.SocketAddress'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * SocketAddress()
    
    """
    def __init__(self): ...

class SocketException(java.io.IOException):
    """
    Java class 'java.net.SocketException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * SocketException(java.lang.String)
        * SocketException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class SocketImplFactory(java.lang.Object):
    """
    public interface SocketImplFactory
    
        This interface defines a factory for socket implementations. It is used by the classes :code:`Socket` and
        :code:`ServerSocket` to create actual socket implementations.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.net.Socket`, :class:`~java.net.ServerSocket`
    
    
    """
    def createSocketImpl(self) -> 'SocketImpl': ...

_SocketOption__T = typing.TypeVar('_SocketOption__T')  # <T>
class SocketOption(java.lang.Object, typing.Generic[_SocketOption__T]):
    """
    public interface SocketOption<T>
    
        A socket option associated with a socket.
    
        In the :class:`~java.nio.channels.package` package, the :class:`~java.nio.channels.NetworkChannel` interface defines the
        :meth:`~java.nio.channels.NetworkChannel.setOption` and :meth:`~java.nio.channels.NetworkChannel.getOption` methods to
        set and query the channel's socket options.
    
        Since:
            1.7
    
        Also see:
            :class:`~java.net.StandardSocketOptions`
    
    
    """
    def name(self) -> java.lang.String: ...
    def type(self) -> typing.Type[_SocketOption__T]: ...

class SocketOptions(java.lang.Object):
    """
    public interface SocketOptions
    
        Interface of methods to get/set socket options. This interface is implemented by: **SocketImpl** and
        **DatagramSocketImpl**. Subclasses of these should override the methods of this interface in order to support their own
        options.
    
        The methods and constants which specify options in this interface are for implementation only. If you're not subclassing
        SocketImpl or DatagramSocketImpl, **you won't use these directly.** There are type-safe methods to get/set each of these
        options in Socket, ServerSocket, DatagramSocket and MulticastSocket.
    
        Since:
            1.1
    
    
    """
    TCP_NODELAY: typing.ClassVar[int] = ...
    SO_BINDADDR: typing.ClassVar[int] = ...
    SO_REUSEADDR: typing.ClassVar[int] = ...
    SO_REUSEPORT: typing.ClassVar[int] = ...
    SO_BROADCAST: typing.ClassVar[int] = ...
    IP_MULTICAST_IF: typing.ClassVar[int] = ...
    IP_MULTICAST_IF2: typing.ClassVar[int] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[int] = ...
    IP_TOS: typing.ClassVar[int] = ...
    SO_LINGER: typing.ClassVar[int] = ...
    SO_TIMEOUT: typing.ClassVar[int] = ...
    SO_SNDBUF: typing.ClassVar[int] = ...
    SO_RCVBUF: typing.ClassVar[int] = ...
    SO_KEEPALIVE: typing.ClassVar[int] = ...
    SO_OOBINLINE: typing.ClassVar[int] = ...
    def getOption(self, int: int) -> typing.Any: ...
    def setOption(self, int: int, object: typing.Any) -> None: ...

class SocketPermission(java.security.Permission):
    """
    Java class 'java.net.SocketPermission'
    
        Extends:
            java.security.Permission
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * SocketPermission(java.lang.String, java.lang.String)
    
    """
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class SocketTimeoutException(java.io.InterruptedIOException):
    """
    Java class 'java.net.SocketTimeoutException'
    
        Extends:
            java.io.InterruptedIOException
    
      Constructors:
        * SocketTimeoutException(java.lang.String)
        * SocketTimeoutException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class StandardSocketOptions(java.lang.Object):
    """
    Java class 'java.net.StandardSocketOptions'
    
        Extends:
            java.lang.Object
    
      Attributes:
        SO_BROADCAST (java.net.SocketOption): final static field
        SO_KEEPALIVE (java.net.SocketOption): final static field
        SO_SNDBUF (java.net.SocketOption): final static field
        SO_RCVBUF (java.net.SocketOption): final static field
        SO_REUSEADDR (java.net.SocketOption): final static field
        SO_REUSEPORT (java.net.SocketOption): final static field
        SO_LINGER (java.net.SocketOption): final static field
        IP_TOS (java.net.SocketOption): final static field
        IP_MULTICAST_IF (java.net.SocketOption): final static field
        IP_MULTICAST_TTL (java.net.SocketOption): final static field
        IP_MULTICAST_LOOP (java.net.SocketOption): final static field
        TCP_NODELAY (java.net.SocketOption): final static field
    
    """
    SO_BROADCAST: typing.ClassVar[SocketOption] = ...
    SO_KEEPALIVE: typing.ClassVar[SocketOption] = ...
    SO_SNDBUF: typing.ClassVar[SocketOption] = ...
    SO_RCVBUF: typing.ClassVar[SocketOption] = ...
    SO_REUSEADDR: typing.ClassVar[SocketOption] = ...
    SO_REUSEPORT: typing.ClassVar[SocketOption] = ...
    SO_LINGER: typing.ClassVar[SocketOption] = ...
    IP_TOS: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_IF: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_TTL: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[SocketOption] = ...
    TCP_NODELAY: typing.ClassVar[SocketOption] = ...

class URI(java.lang.Comparable[java.net.URI], java.io.Serializable):
    """
    Java class 'java.net.URI'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Comparable, java.io.Serializable
    
      Constructors:
        * URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
        * URI(java.lang.String, java.lang.String, java.lang.String)
        * URI(java.lang.String)
        * URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)
        * URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
    
      Raises:
        java.net.URISyntaxException: from java
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String, int: int, string4: java.lang.String, string5: java.lang.String, string6: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String, string4: java.lang.String, string5: java.lang.String): ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, uRI: 'URI') -> int: ...
    @classmethod
    def create(cls, string: java.lang.String) -> 'URI': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAuthority(self) -> java.lang.String: ...
    def getFragment(self) -> java.lang.String: ...
    def getHost(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getQuery(self) -> java.lang.String: ...
    def getRawAuthority(self) -> java.lang.String: ...
    def getRawFragment(self) -> java.lang.String: ...
    def getRawPath(self) -> java.lang.String: ...
    def getRawQuery(self) -> java.lang.String: ...
    def getRawSchemeSpecificPart(self) -> java.lang.String: ...
    def getRawUserInfo(self) -> java.lang.String: ...
    def getScheme(self) -> java.lang.String: ...
    def getSchemeSpecificPart(self) -> java.lang.String: ...
    def getUserInfo(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def normalize(self) -> 'URI': ...
    def parseServerAuthority(self) -> 'URI': ...
    def relativize(self, uRI: 'URI') -> 'URI': ...
    @typing.overload
    def resolve(self, string: java.lang.String) -> 'URI': ...
    @typing.overload
    def resolve(self, uRI: 'URI') -> 'URI': ...
    def toASCIIString(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def toURL(self) -> 'URL': ...

class URISyntaxException(java.lang.Exception):
    """
    Java class 'java.net.URISyntaxException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * URISyntaxException(java.lang.String, java.lang.String, int)
        * URISyntaxException(java.lang.String, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, int: int): ...
    def getIndex(self) -> int: ...
    def getInput(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...
    def getReason(self) -> java.lang.String: ...

class URL(java.io.Serializable):
    """
    Java class 'java.net.URL'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)
        * URL(java.net.URL, java.lang.String)
        * URL(java.lang.String)
        * URL(java.lang.String, java.lang.String, int, java.lang.String)
        * URL(java.lang.String, java.lang.String, java.lang.String)
        * URL(java.lang.String, java.lang.String, int, java.lang.String, java.net.URLStreamHandler)
    
      Raises:
        java.net.MalformedURLException: from java
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, int: int, string3: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, int: int, string3: java.lang.String, uRLStreamHandler: 'URLStreamHandler'): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String, string3: java.lang.String): ...
    @typing.overload
    def __init__(self, uRL: 'URL', string: java.lang.String): ...
    @typing.overload
    def __init__(self, uRL: 'URL', string: java.lang.String, uRLStreamHandler: 'URLStreamHandler'): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAuthority(self) -> java.lang.String: ...
    @typing.overload
    def getContent(self) -> typing.Any: ...
    @typing.overload
    def getContent(self, classArray: typing.List[typing.Type[typing.Any]]) -> typing.Any: ...
    def getDefaultPort(self) -> int: ...
    def getFile(self) -> java.lang.String: ...
    def getHost(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getProtocol(self) -> java.lang.String: ...
    def getQuery(self) -> java.lang.String: ...
    def getRef(self) -> java.lang.String: ...
    def getUserInfo(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def openConnection(self) -> 'URLConnection': ...
    @typing.overload
    def openConnection(self, proxy: Proxy) -> 'URLConnection': ...
    def openStream(self) -> java.io.InputStream: ...
    def sameFile(self, uRL: 'URL') -> bool: ...
    @classmethod
    def setURLStreamHandlerFactory(cls, uRLStreamHandlerFactory: 'URLStreamHandlerFactory') -> None: ...
    def toExternalForm(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def toURI(self) -> URI: ...

class URLClassLoader(java.security.SecureClassLoader, java.io.Closeable):
    """
    Java class 'java.net.URLClassLoader'
    
        Extends:
            java.security.SecureClassLoader
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * URLClassLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
        * URLClassLoader(java.lang.String, java.net.URL[], java.lang.ClassLoader)
        * URLClassLoader(java.lang.String, java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
        * URLClassLoader(java.net.URL[], java.lang.ClassLoader)
        * URLClassLoader(java.net.URL[])
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String, uRLArray: typing.List[URL], classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, string: java.lang.String, uRLArray: typing.List[URL], classLoader: java.lang.ClassLoader, uRLStreamHandlerFactory: 'URLStreamHandlerFactory'): ...
    @typing.overload
    def __init__(self, uRLArray: typing.List[URL]): ...
    @typing.overload
    def __init__(self, uRLArray: typing.List[URL], classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, uRLArray: typing.List[URL], classLoader: java.lang.ClassLoader, uRLStreamHandlerFactory: 'URLStreamHandlerFactory'): ...
    def close(self) -> None: ...
    def findResource(self, string: java.lang.String) -> URL: ...
    def findResources(self, string: java.lang.String) -> java.util.Enumeration[URL]: ...
    def getResourceAsStream(self, string: java.lang.String) -> java.io.InputStream: ...
    def getURLs(self) -> typing.List[URL]: ...
    @classmethod
    @typing.overload
    def newInstance(cls, uRLArray: typing.List[URL]) -> 'URLClassLoader': ...
    @classmethod
    @typing.overload
    def newInstance(cls, uRLArray: typing.List[URL], classLoader: java.lang.ClassLoader) -> 'URLClassLoader': ...

class URLConnection(java.lang.Object):
    """
    Java class 'java.net.URLConnection'
    
        Extends:
            java.lang.Object
    
    """
    def addRequestProperty(self, string: java.lang.String, string2: java.lang.String) -> None: ...
    def connect(self) -> None: ...
    def getAllowUserInteraction(self) -> bool: ...
    def getConnectTimeout(self) -> int: ...
    @typing.overload
    def getContent(self) -> typing.Any: ...
    @typing.overload
    def getContent(self, classArray: typing.List[typing.Type[typing.Any]]) -> typing.Any: ...
    def getContentEncoding(self) -> java.lang.String: ...
    def getContentLength(self) -> int: ...
    def getContentLengthLong(self) -> int: ...
    def getContentType(self) -> java.lang.String: ...
    def getDate(self) -> int: ...
    @classmethod
    def getDefaultAllowUserInteraction(cls) -> bool: ...
    @classmethod
    def getDefaultRequestProperty(cls, string: java.lang.String) -> java.lang.String: ...
    @typing.overload
    def getDefaultUseCaches(self) -> bool: ...
    @classmethod
    @typing.overload
    def getDefaultUseCaches(cls, string: java.lang.String) -> bool: ...
    def getDoInput(self) -> bool: ...
    def getDoOutput(self) -> bool: ...
    def getExpiration(self) -> int: ...
    @classmethod
    def getFileNameMap(cls) -> FileNameMap: ...
    @typing.overload
    def getHeaderField(self, int: int) -> java.lang.String: ...
    @typing.overload
    def getHeaderField(self, string: java.lang.String) -> java.lang.String: ...
    def getHeaderFieldDate(self, string: java.lang.String, long: int) -> int: ...
    def getHeaderFieldInt(self, string: java.lang.String, int: int) -> int: ...
    def getHeaderFieldKey(self, int: int) -> java.lang.String: ...
    def getHeaderFieldLong(self, string: java.lang.String, long: int) -> int: ...
    def getHeaderFields(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getIfModifiedSince(self) -> int: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getLastModified(self) -> int: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPermission(self) -> java.security.Permission: ...
    def getReadTimeout(self) -> int: ...
    def getRequestProperties(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getRequestProperty(self, string: java.lang.String) -> java.lang.String: ...
    def getURL(self) -> URL: ...
    def getUseCaches(self) -> bool: ...
    @classmethod
    def guessContentTypeFromName(cls, string: java.lang.String) -> java.lang.String: ...
    @classmethod
    def guessContentTypeFromStream(cls, inputStream: java.io.InputStream) -> java.lang.String: ...
    def setAllowUserInteraction(self, boolean: bool) -> None: ...
    def setConnectTimeout(self, int: int) -> None: ...
    @classmethod
    def setContentHandlerFactory(cls, contentHandlerFactory: ContentHandlerFactory) -> None: ...
    @classmethod
    def setDefaultAllowUserInteraction(cls, boolean: bool) -> None: ...
    @classmethod
    def setDefaultRequestProperty(cls, string: java.lang.String, string2: java.lang.String) -> None: ...
    @classmethod
    @typing.overload
    def setDefaultUseCaches(cls, string: java.lang.String, boolean: bool) -> None: ...
    @typing.overload
    def setDefaultUseCaches(self, boolean: bool) -> None: ...
    def setDoInput(self, boolean: bool) -> None: ...
    def setDoOutput(self, boolean: bool) -> None: ...
    @classmethod
    def setFileNameMap(cls, fileNameMap: FileNameMap) -> None: ...
    def setIfModifiedSince(self, long: int) -> None: ...
    def setReadTimeout(self, int: int) -> None: ...
    def setRequestProperty(self, string: java.lang.String, string2: java.lang.String) -> None: ...
    def setUseCaches(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...

class URLDecoder(java.lang.Object):
    """
    Java class 'java.net.URLDecoder'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * URLDecoder()
    
    """
    def __init__(self): ...
    @classmethod
    @typing.overload
    def decode(cls, string: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def decode(cls, string: java.lang.String, string2: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def decode(cls, string: java.lang.String, charset: java.nio.charset.Charset) -> java.lang.String: ...

class URLEncoder(java.lang.Object):
    """
    Java class 'java.net.URLEncoder'
    
        Extends:
            java.lang.Object
    
    """
    @classmethod
    @typing.overload
    def encode(cls, string: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def encode(cls, string: java.lang.String, string2: java.lang.String) -> java.lang.String: ...
    @classmethod
    @typing.overload
    def encode(cls, string: java.lang.String, charset: java.nio.charset.Charset) -> java.lang.String: ...

class URLPermission(java.security.Permission):
    """
    Java class 'java.net.URLPermission'
    
        Extends:
            java.security.Permission
    
      Constructors:
        * URLPermission(java.lang.String)
        * URLPermission(java.lang.String, java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, string2: java.lang.String): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...

class URLStreamHandler(java.lang.Object):
    """
    Java class 'java.net.URLStreamHandler'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * URLStreamHandler()
    
    """
    def __init__(self): ...

class URLStreamHandlerFactory(java.lang.Object):
    """
    public interface URLStreamHandlerFactory
    
        This interface defines a factory for :code:`URL` stream protocol handlers.
    
        A URL stream handler factory is used as specified in the :meth:`~java.net.URL.%3Cinit%3E`.
    
        Since:
            1.0
    
        Also see:
            :class:`~java.net.URL`, :class:`~java.net.URLStreamHandler`
    
    
    """
    def createURLStreamHandler(self, string: java.lang.String) -> URLStreamHandler: ...

class UnknownHostException(java.io.IOException):
    """
    Java class 'java.net.UnknownHostException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * UnknownHostException(java.lang.String)
        * UnknownHostException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class UnknownServiceException(java.io.IOException):
    """
    Java class 'java.net.UnknownServiceException'
    
        Extends:
            java.io.IOException
    
      Constructors:
        * UnknownServiceException()
        * UnknownServiceException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class BindException(SocketException):
    """
    Java class 'java.net.BindException'
    
        Extends:
            java.net.SocketException
    
      Constructors:
        * BindException(java.lang.String)
        * BindException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class ConnectException(SocketException):
    """
    Java class 'java.net.ConnectException'
    
        Extends:
            java.net.SocketException
    
      Constructors:
        * ConnectException(java.lang.String)
        * ConnectException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class CookieManager(CookieHandler):
    """
    Java class 'java.net.CookieManager'
    
        Extends:
            java.net.CookieHandler
    
      Constructors:
        * CookieManager()
        * CookieManager(java.net.CookieStore, java.net.CookiePolicy)
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, cookieStore: CookieStore, cookiePolicy: CookiePolicy): ...
    def get(self, uRI: URI, map: typing.Union[java.util.Map[java.lang.String, java.util.List[java.lang.String]], typing.Mapping[java.lang.String, java.util.List[java.lang.String]]]) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getCookieStore(self) -> CookieStore: ...
    def put(self, uRI: URI, map: typing.Union[java.util.Map[java.lang.String, java.util.List[java.lang.String]], typing.Mapping[java.lang.String, java.util.List[java.lang.String]]]) -> None: ...
    def setCookiePolicy(self, cookiePolicy: CookiePolicy) -> None: ...

class DatagramSocketImpl(SocketOptions):
    """
    Java class 'java.net.DatagramSocketImpl'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.net.SocketOptions
    
      Constructors:
        * DatagramSocketImpl()
    
    """
    def __init__(self): ...

class HttpURLConnection(URLConnection):
    """
    Java class 'java.net.HttpURLConnection'
    
        Extends:
            java.net.URLConnection
    
      Attributes:
        HTTP_OK (int): final static field
        HTTP_CREATED (int): final static field
        HTTP_ACCEPTED (int): final static field
        HTTP_NOT_AUTHORITATIVE (int): final static field
        HTTP_NO_CONTENT (int): final static field
        HTTP_RESET (int): final static field
        HTTP_PARTIAL (int): final static field
        HTTP_MULT_CHOICE (int): final static field
        HTTP_MOVED_PERM (int): final static field
        HTTP_MOVED_TEMP (int): final static field
        HTTP_SEE_OTHER (int): final static field
        HTTP_NOT_MODIFIED (int): final static field
        HTTP_USE_PROXY (int): final static field
        HTTP_BAD_REQUEST (int): final static field
        HTTP_UNAUTHORIZED (int): final static field
        HTTP_PAYMENT_REQUIRED (int): final static field
        HTTP_FORBIDDEN (int): final static field
        HTTP_NOT_FOUND (int): final static field
        HTTP_BAD_METHOD (int): final static field
        HTTP_NOT_ACCEPTABLE (int): final static field
        HTTP_PROXY_AUTH (int): final static field
        HTTP_CLIENT_TIMEOUT (int): final static field
        HTTP_CONFLICT (int): final static field
        HTTP_GONE (int): final static field
        HTTP_LENGTH_REQUIRED (int): final static field
        HTTP_PRECON_FAILED (int): final static field
        HTTP_ENTITY_TOO_LARGE (int): final static field
        HTTP_REQ_TOO_LONG (int): final static field
        HTTP_UNSUPPORTED_TYPE (int): final static field
        HTTP_SERVER_ERROR (int): final static field
        HTTP_INTERNAL_ERROR (int): final static field
        HTTP_NOT_IMPLEMENTED (int): final static field
        HTTP_BAD_GATEWAY (int): final static field
        HTTP_UNAVAILABLE (int): final static field
        HTTP_GATEWAY_TIMEOUT (int): final static field
        HTTP_VERSION (int): final static field
    
    """
    HTTP_OK: typing.ClassVar[int] = ...
    HTTP_CREATED: typing.ClassVar[int] = ...
    HTTP_ACCEPTED: typing.ClassVar[int] = ...
    HTTP_NOT_AUTHORITATIVE: typing.ClassVar[int] = ...
    HTTP_NO_CONTENT: typing.ClassVar[int] = ...
    HTTP_RESET: typing.ClassVar[int] = ...
    HTTP_PARTIAL: typing.ClassVar[int] = ...
    HTTP_MULT_CHOICE: typing.ClassVar[int] = ...
    HTTP_MOVED_PERM: typing.ClassVar[int] = ...
    HTTP_MOVED_TEMP: typing.ClassVar[int] = ...
    HTTP_SEE_OTHER: typing.ClassVar[int] = ...
    HTTP_NOT_MODIFIED: typing.ClassVar[int] = ...
    HTTP_USE_PROXY: typing.ClassVar[int] = ...
    HTTP_BAD_REQUEST: typing.ClassVar[int] = ...
    HTTP_UNAUTHORIZED: typing.ClassVar[int] = ...
    HTTP_PAYMENT_REQUIRED: typing.ClassVar[int] = ...
    HTTP_FORBIDDEN: typing.ClassVar[int] = ...
    HTTP_NOT_FOUND: typing.ClassVar[int] = ...
    HTTP_BAD_METHOD: typing.ClassVar[int] = ...
    HTTP_NOT_ACCEPTABLE: typing.ClassVar[int] = ...
    HTTP_PROXY_AUTH: typing.ClassVar[int] = ...
    HTTP_CLIENT_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_CONFLICT: typing.ClassVar[int] = ...
    HTTP_GONE: typing.ClassVar[int] = ...
    HTTP_LENGTH_REQUIRED: typing.ClassVar[int] = ...
    HTTP_PRECON_FAILED: typing.ClassVar[int] = ...
    HTTP_ENTITY_TOO_LARGE: typing.ClassVar[int] = ...
    HTTP_REQ_TOO_LONG: typing.ClassVar[int] = ...
    HTTP_UNSUPPORTED_TYPE: typing.ClassVar[int] = ...
    HTTP_SERVER_ERROR: typing.ClassVar[int] = ...
    HTTP_INTERNAL_ERROR: typing.ClassVar[int] = ...
    HTTP_NOT_IMPLEMENTED: typing.ClassVar[int] = ...
    HTTP_BAD_GATEWAY: typing.ClassVar[int] = ...
    HTTP_UNAVAILABLE: typing.ClassVar[int] = ...
    HTTP_GATEWAY_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_VERSION: typing.ClassVar[int] = ...
    def disconnect(self) -> None: ...
    def getErrorStream(self) -> java.io.InputStream: ...
    @classmethod
    def getFollowRedirects(cls) -> bool: ...
    @typing.overload
    def getHeaderField(self, int: int) -> java.lang.String: ...
    @typing.overload
    def getHeaderField(self, string: java.lang.String) -> java.lang.String: ...
    def getHeaderFieldDate(self, string: java.lang.String, long: int) -> int: ...
    def getHeaderFieldKey(self, int: int) -> java.lang.String: ...
    def getInstanceFollowRedirects(self) -> bool: ...
    def getPermission(self) -> java.security.Permission: ...
    def getRequestMethod(self) -> java.lang.String: ...
    def getResponseCode(self) -> int: ...
    def getResponseMessage(self) -> java.lang.String: ...
    def setAuthenticator(self, authenticator: Authenticator) -> None: ...
    def setChunkedStreamingMode(self, int: int) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, int: int) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, long: int) -> None: ...
    @classmethod
    def setFollowRedirects(cls, boolean: bool) -> None: ...
    def setInstanceFollowRedirects(self, boolean: bool) -> None: ...
    def setRequestMethod(self, string: java.lang.String) -> None: ...
    def usingProxy(self) -> bool: ...

class Inet4Address(InetAddress):
    """
    Java class 'java.net.Inet4Address'
    
        Extends:
            java.net.InetAddress
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.List[int]: ...
    def getHostAddress(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...

class Inet6Address(InetAddress):
    """
    Java class 'java.net.Inet6Address'
    
        Extends:
            java.net.InetAddress
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.List[int]: ...
    @classmethod
    @typing.overload
    def getByAddress(cls, string: java.lang.String, byteArray: typing.List[int], int: int) -> 'Inet6Address': ...
    @classmethod
    @typing.overload
    def getByAddress(cls, string: java.lang.String, byteArray: typing.List[int], networkInterface: NetworkInterface) -> 'Inet6Address': ...
    @classmethod
    @typing.overload
    def getByAddress(cls, byteArray: typing.List[int]) -> InetAddress: ...
    @classmethod
    @typing.overload
    def getByAddress(cls, string: java.lang.String, byteArray: typing.List[int]) -> InetAddress: ...
    def getHostAddress(self) -> java.lang.String: ...
    def getScopeId(self) -> int: ...
    def getScopedInterface(self) -> NetworkInterface: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isIPv4CompatibleAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...

class InetSocketAddress(SocketAddress):
    """
    Java class 'java.net.InetSocketAddress'
    
        Extends:
            java.net.SocketAddress
    
      Constructors:
        * InetSocketAddress(java.net.InetAddress, int)
        * InetSocketAddress(int)
        * InetSocketAddress(java.lang.String, int)
    
    """
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String, int: int): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int): ...
    @classmethod
    def createUnresolved(cls, string: java.lang.String, int: int) -> 'InetSocketAddress': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getHostName(self) -> java.lang.String: ...
    def getHostString(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def hashCode(self) -> int: ...
    def isUnresolved(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class JarURLConnection(URLConnection):
    """
    Java class 'java.net.JarURLConnection'
    
        Extends:
            java.net.URLConnection
    
    """
    def getAttributes(self) -> java.util.jar.Attributes: ...
    def getCertificates(self) -> typing.List[java.security.cert.Certificate]: ...
    def getEntryName(self) -> java.lang.String: ...
    def getJarEntry(self) -> java.util.jar.JarEntry: ...
    def getJarFile(self) -> java.util.jar.JarFile: ...
    def getJarFileURL(self) -> URL: ...
    def getMainAttributes(self) -> java.util.jar.Attributes: ...
    def getManifest(self) -> java.util.jar.Manifest: ...

class MulticastSocket(DatagramSocket):
    """
    Java class 'java.net.MulticastSocket'
    
        Extends:
            java.net.DatagramSocket
    
      Constructors:
        * MulticastSocket(java.net.SocketAddress)
        * MulticastSocket(int)
        * MulticastSocket()
    
      Raises:
        java.io.IOException: from java
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, socketAddress: SocketAddress): ...
    def getInterface(self) -> InetAddress: ...
    def getLoopbackMode(self) -> bool: ...
    def getNetworkInterface(self) -> NetworkInterface: ...
    def getTTL(self) -> int: ...
    def getTimeToLive(self) -> int: ...
    @typing.overload
    def joinGroup(self, inetAddress: InetAddress) -> None: ...
    @typing.overload
    def joinGroup(self, socketAddress: SocketAddress, networkInterface: NetworkInterface) -> None: ...
    @typing.overload
    def leaveGroup(self, inetAddress: InetAddress) -> None: ...
    @typing.overload
    def leaveGroup(self, socketAddress: SocketAddress, networkInterface: NetworkInterface) -> None: ...
    @typing.overload
    def send(self, datagramPacket: DatagramPacket) -> None: ...
    @typing.overload
    def send(self, datagramPacket: DatagramPacket, byte: int) -> None: ...
    def setInterface(self, inetAddress: InetAddress) -> None: ...
    def setLoopbackMode(self, boolean: bool) -> None: ...
    def setNetworkInterface(self, networkInterface: NetworkInterface) -> None: ...
    def setTTL(self, byte: int) -> None: ...
    def setTimeToLive(self, int: int) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[typing.Any]]: ...

class NoRouteToHostException(SocketException):
    """
    Java class 'java.net.NoRouteToHostException'
    
        Extends:
            java.net.SocketException
    
      Constructors:
        * NoRouteToHostException(java.lang.String)
        * NoRouteToHostException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class PortUnreachableException(SocketException):
    """
    Java class 'java.net.PortUnreachableException'
    
        Extends:
            java.net.SocketException
    
      Constructors:
        * PortUnreachableException(java.lang.String)
        * PortUnreachableException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String): ...

class SecureCacheResponse(CacheResponse):
    """
    Java class 'java.net.SecureCacheResponse'
    
        Extends:
            java.net.CacheResponse
    
      Constructors:
        * SecureCacheResponse()
    
    """
    def __init__(self): ...
    def getCipherSuite(self) -> java.lang.String: ...
    def getLocalCertificateChain(self) -> java.util.List[java.security.cert.Certificate]: ...
    def getLocalPrincipal(self) -> java.security.Principal: ...
    def getPeerPrincipal(self) -> java.security.Principal: ...
    def getServerCertificateChain(self) -> java.util.List[java.security.cert.Certificate]: ...

class SocketImpl(SocketOptions):
    """
    Java class 'java.net.SocketImpl'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.net.SocketOptions
    
      Constructors:
        * SocketImpl()
    
    """
    def __init__(self): ...
    def toString(self) -> java.lang.String: ...

class StandardProtocolFamily(java.lang.Enum[java.net.StandardProtocolFamily], ProtocolFamily):
    """
    Java class 'java.net.StandardProtocolFamily'
    
        Extends:
            java.lang.Enum
    
        Interfaces:
            java.net.ProtocolFamily
    
      Attributes:
        INET (java.net.StandardProtocolFamily): final static enum constant
        INET6 (java.net.StandardProtocolFamily): final static enum constant
    
    """
    INET: typing.ClassVar['StandardProtocolFamily'] = ...
    INET6: typing.ClassVar['StandardProtocolFamily'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @typing.overload
    def valueOf(cls, class_: typing.Type[_valueOf_0__T], string: java.lang.String) -> _valueOf_0__T: ...
    @classmethod
    @typing.overload
    def valueOf(cls, string: java.lang.String) -> 'StandardProtocolFamily': ...
    @classmethod
    def values(cls) -> typing.List['StandardProtocolFamily']: ...

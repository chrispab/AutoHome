import java.lang
import java.util
import typing


class Dimension(java.lang.Object):
    """
    Java class 'javax.measure.Dimension'
    
    """
    def divide(self, dimension: 'Dimension') -> 'Dimension': ...
    def getBaseDimensions(self) -> java.util.Map['Dimension', int]: ...
    def multiply(self, dimension: 'Dimension') -> 'Dimension': ...
    def pow(self, int: int) -> 'Dimension': ...
    def root(self, int: int) -> 'Dimension': ...

class IncommensurableException(java.lang.Exception):
    """
    Java class 'javax.measure.IncommensurableException'
    
        Extends:
            java.lang.Exception
    
      Constructors:
        * IncommensurableException(java.lang.String)
        * IncommensurableException(java.lang.Throwable)
        * IncommensurableException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class MeasurementException(java.lang.RuntimeException):
    """
    Java class 'javax.measure.MeasurementException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * MeasurementException(java.lang.String, java.lang.Throwable)
        * MeasurementException(java.lang.Throwable)
        * MeasurementException(java.lang.String)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

_Quantity__Q = typing.TypeVar('_Quantity__Q', bound='Quantity')  # <Q>
class Quantity(java.lang.Object, typing.Generic[_Quantity__Q]):
    """
    Java class 'javax.measure.Quantity'
    
    """
    def add(self, quantity: 'Quantity'[_Quantity__Q]) -> 'Quantity'[_Quantity__Q]: ...
    _asType__T = typing.TypeVar('_asType__T', bound='Quantity')  # <T>
    def asType(self, class_: typing.Type[_asType__T]) -> 'Quantity'[_asType__T]: ...
    @typing.overload
    def divide(self, number: java.lang.Number) -> 'Quantity'[_Quantity__Q]: ...
    @typing.overload
    def divide(self, quantity: 'Quantity'[typing.Any]) -> 'Quantity'[typing.Any]: ...
    def getUnit(self) -> 'Unit'[_Quantity__Q]: ...
    def getValue(self) -> java.lang.Number: ...
    def inverse(self) -> 'Quantity'[typing.Any]: ...
    @typing.overload
    def multiply(self, number: java.lang.Number) -> 'Quantity'[_Quantity__Q]: ...
    @typing.overload
    def multiply(self, quantity: 'Quantity'[typing.Any]) -> 'Quantity'[typing.Any]: ...
    def subtract(self, quantity: 'Quantity'[_Quantity__Q]) -> 'Quantity'[_Quantity__Q]: ...
    def to(self, unit: 'Unit'[_Quantity__Q]) -> 'Quantity'[_Quantity__Q]: ...

_Unit__Q = typing.TypeVar('_Unit__Q', bound=Quantity)  # <Q>
class Unit(java.lang.Object, typing.Generic[_Unit__Q]):
    """
    Java class 'javax.measure.Unit'
    
    """
    def alternate(self, string: java.lang.String) -> 'Unit'[_Unit__Q]: ...
    _asType__T = typing.TypeVar('_asType__T', bound=Quantity)  # <T>
    def asType(self, class_: typing.Type[_asType__T]) -> 'Unit'[_asType__T]: ...
    @typing.overload
    def divide(self, double: float) -> 'Unit'[_Unit__Q]: ...
    @typing.overload
    def divide(self, unit: 'Unit'[typing.Any]) -> 'Unit'[typing.Any]: ...
    def getBaseUnits(self) -> java.util.Map['Unit'[typing.Any], int]: ...
    def getConverterTo(self, unit: 'Unit'[_Unit__Q]) -> 'UnitConverter': ...
    def getConverterToAny(self, unit: 'Unit'[typing.Any]) -> 'UnitConverter': ...
    def getDimension(self) -> Dimension: ...
    def getName(self) -> java.lang.String: ...
    def getSymbol(self) -> java.lang.String: ...
    def getSystemUnit(self) -> 'Unit'[_Unit__Q]: ...
    def inverse(self) -> 'Unit'[typing.Any]: ...
    def isCompatible(self, unit: 'Unit'[typing.Any]) -> bool: ...
    @typing.overload
    def multiply(self, double: float) -> 'Unit'[_Unit__Q]: ...
    @typing.overload
    def multiply(self, unit: 'Unit'[typing.Any]) -> 'Unit'[typing.Any]: ...
    def pow(self, int: int) -> 'Unit'[typing.Any]: ...
    def root(self, int: int) -> 'Unit'[typing.Any]: ...
    def shift(self, double: float) -> 'Unit'[_Unit__Q]: ...
    def toString(self) -> java.lang.String: ...
    def transform(self, unitConverter: 'UnitConverter') -> 'Unit'[_Unit__Q]: ...

class UnitConverter(java.lang.Object):
    """
    Java class 'javax.measure.UnitConverter'
    
    """
    def concatenate(self, unitConverter: 'UnitConverter') -> 'UnitConverter': ...
    @typing.overload
    def convert(self, double: float) -> float: ...
    @typing.overload
    def convert(self, number: java.lang.Number) -> java.lang.Number: ...
    def getConversionSteps(self) -> java.util.List['UnitConverter']: ...
    def inverse(self) -> 'UnitConverter': ...
    def isIdentity(self) -> bool: ...
    def isLinear(self) -> bool: ...

class UnconvertibleException(MeasurementException):
    """
    Java class 'javax.measure.UnconvertibleException'
    
        Extends:
            javax.measure.MeasurementException
    
      Constructors:
        * UnconvertibleException(java.lang.String)
        * UnconvertibleException(java.lang.Throwable)
        * UnconvertibleException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: java.lang.String): ...
    @typing.overload
    def __init__(self, string: java.lang.String, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

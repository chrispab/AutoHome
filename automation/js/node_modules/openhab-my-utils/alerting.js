exports.sendAlert = function (message, logger) {
  var logger = (logger) ? logger : log('sendAlert');
  logger.warn('ALERT: ' + message);
  actions.NotificationAction.sendBroadcastNotification(message, 'alarm', 'alert');
  //  if(!actions.Things.getActions("mail", "mail:smtp:gmail").sendMail("email@server.com", "openHAB Alert", message)) {
  //    logger.warn("Failed to send email alert alert");
  //  }
}

exports.sendInfo = function (message, logger) {
  var logger = (logger) ? logger : log('sendInfo');
  logger.warn('INFO: ' + message);


  if (!actions.Things.getActions("mail", "mail:smtp:gmail").sendMail("cbattisson@gmail.com", "openHAB Info", message)) {
    logger.warn("Failed to send email info alert");
  }
  // var mailActions = actions.Things.getActions("mail", "mail:smtp:gmail");
  // success = mailActions.sendMail("cbattisson@gmail.com", "openHAB Info", message);
  // if(!success){
  // logger.warn("Failed to send email info alert");
  else {
    logger.warn("SUCCESS -- EMAIL SENT");
  }

}


exports.sendEmail = function (subject, message, logger) {
  const localLogger = (logger) || log('sendEmail');
  localLogger.debug(`Email message to send: ${message}`);

  // Prepend the subject with 'Openhab: ' if it doesn't already start with it
  if (!subject.startsWith('Openhab: ')) {
    subject = `Openhab: ${subject}`;
  }

  const mailActions = actions.Things.getActions('mail', 'mail:smtp:gmail');
  if (!mailActions) {
    localLogger.error("Could not get mail actions for Thing UID: mail:smtp:gmail. Is the mail binding configured correctly?");
    return;
  }

  if (!mailActions.sendMail('cbattisson@gmail.com', subject, message)) {
    localLogger.warn(`Failed to send email with subject: "${subject}"`);
  } else {
    localLogger.info(`Successfully sent email with subject: "${subject}"`);
  }
};
exports.isNight = function () {
  const currToD = items.getItem('TimeOfDay').state;
  return currToD == 'NIGHT' || currToD == 'BED';
}

exports.isAway = function () {
  return exports.isNight() || items.getItem('Presence').state != 'ON';
}

exports.getNames = function (group, filterFunc) {
  return items.getItem(group.name || group).members
    .filter(filterFunc)
    .map(s => s.getMetadataValue('name') || s.label)
    .join(', ');
}

//
//
// https://github.com/openhab/openhab-distro/releases/tag/4.3.0#breaking-changes-that-require-manual-interaction-after-the-upgrade
exports.flashItemAlert = function (flashItemName = 'CT_FairyLights433Socket', numFlashes = 1, pulseTimeMs = 500, logger) {
  const localLogger = (logger) || log('flashItemAlert');
  const item = items.getItem(flashItemName);
  if (!item) {
    localLogger.error(`Item not found: ${flashItemName}`);
    return;
  }
  const currentState = item.state;

  item.sendCommand('ON');
  localLogger.info(`${flashItemName} ON`);
  let index = 0;
  for (index = 0; index < numFlashes * 2; index++) {
    const state = (index % 2) === 1 ? 'ON' : 'OFF';
    const delay = (index + 1) * pulseTimeMs;
    actions.ScriptExecution.createTimer(time.toZDT(delay), () => {
      item.sendCommand(state);
      localLogger.debug(`${flashItemName}: ${state}`);
    });
  }

  const finalDelay = (index + 1) * pulseTimeMs;
  actions.ScriptExecution.createTimer(time.toZDT(finalDelay), () => {
    item.sendCommand(currentState);
    localLogger.debug(`${flashItemName}: Restored to ${currentState}`);
  });
};